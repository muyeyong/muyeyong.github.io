<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>折腾-NAS（Network Attached Storage）</title>
      <link href="/2022/01/06/zhe-teng-nas/"/>
      <url>/2022/01/06/zhe-teng-nas/</url>
      
        <content type="html"><![CDATA[<h1 id="NAS的折腾之路"><a href="#NAS的折腾之路" class="headerlink" title="NAS的折腾之路"></a>NAS的折腾之路</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    好久之前逛值得买的就看到了关于NAS的介绍，那时候就很心动，研究了很多搭建NAS的方式（主要是看值得买的文章和b站上的视频），自己组装省钱，买成品NAS省心，<del>那就买别人组装的NAS</del>，当时都下单了，想了想自己的钱包，退了😂。</p><p><img src="https://s2.loli.net/2022/01/06/lKxGEMtXa8jiVsJ.png" alt=""></p><p>今年又给自己创造了需求，想把自己以前骑行的照片、视频放到上面就可以随时观看了，以前是存在硬盘上的查看非常不方便，于是双十一在狗东上下单了<strong>威联通TS-453Dmini</strong>，主要是想省事，顺便买了两块4T的硬盘，后来发现不够用😔😔。</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="我都实现了什么功能"><a href="#我都实现了什么功能" class="headerlink" title="我都实现了什么功能"></a>我都实现了什么功能</h3><h4 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h4><h4 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h4><h4 id="资源下载-PT"><a href="#资源下载-PT" class="headerlink" title="资源下载-PT"></a>资源下载-PT</h4><h4 id="薅羊毛"><a href="#薅羊毛" class="headerlink" title="薅羊毛"></a>薅羊毛</h4><h2 id="观影自动化-or-半自动化"><a href="#观影自动化-or-半自动化" class="headerlink" title="观影自动化 or 半自动化"></a>观影自动化 or <del>半自动化</del></h2><p>​    我最开始是看这篇文章<a href="https://sleele.com/2020/03/16/%e9%ab%98%e9%98%b6%e6%95%99%e7%a8%8b-%e8%bf%bd%e5%89%a7%e5%85%a8%e6%b5%81%e7%a8%8b%e8%87%aa%e5%8a%a8%e5%8c%96/" target="_blank" rel="noopener">追剧全流程自动化</a>配置的，Jackett 管理PT站点、Sonarr 负责剧集管理、Radarr 负责电影管理、qBittorrent会去下载你想要的资源，但是总觉得少了点东西，在值得买看到了这篇文章<a href="https://post.smzdm.com/p/aqx9rgo7/" target="_blank" rel="noopener">家庭影音库的最终方案，从豆瓣选电影到进入Emby一气呵成-发挥NAS最大价值</a>，豆瓣 + Emby + 馒头 的组合方案，但这个方案不适合我😂😂😂（<del>有大佬给个馒头的邀请码吗</del>），贫穷的我需要想另外的办法。在这个期间了解了 <a href="https://overseerr.dev/" target="_blank" rel="noopener">overseerr</a> 和 <a href="https://ombi.io/" target="_blank" rel="noopener">ombi</a>（Docker版本），这两个东西是用来管理 Sonarr 和 Radarr，但是我的使用体验不是很好，overseerr 只支持Plex，但是有<a href="https://api-docs.overseerr.dev/" target="_blank" rel="noopener">OpenApi</a>，Ombi对Plex、Emby 和 Jellyfin都支持，但是没有OpenApi。于是我就从Sonarr 和 Radarr入手，发现这两东西也有OpenApi（<a href="https://radarr.video/docs/api/" target="_blank" rel="noopener">Radarr</a>, <a href="https://github.com/Sonarr/Sonarr">Sonarr</a>），这样事情就好办了，接下来实现平民版观影自动化。</p><p>​    基本思路还是从豆瓣爬取你想看的电影、电视剧数据，然后通过Sonarr 和 Radarr下载，最终的结果是做成一个docker，实现定时运行任务，手把手教学。</p><p>​    这个项目是建立在<a href="https://github.com/pofey/movie_robot">值得买老哥的基础上</a>，切图仔对此表示感谢。</p><p>​    我的运行设备是威联通 TS-453Dmini，需要一个可以访问外网的网络环境。</p><p>下面的安装都是直接在威联通ContainerStation里面搜索并创建，看那个docker人下载的多就安装那个，我只说我觉得需要注意的地方：</p><h3 id="Jackett-的安装"><a href="#Jackett-的安装" class="headerlink" title="Jackett 的安装"></a>Jackett 的安装</h3><ul><li>FlareSolverr</li></ul><p>​    添加完indexer后，发现基本上都是有红色感叹号，根据提示还需要安装FlareSolverr docker版本，然后将FlareSolverr的url填到Jackett就好了。</p><p><img src="https://s2.loli.net/2022/01/20/VcAm6o8q4fwhUu1.png" alt=""></p><h3 id="Sonarr"><a href="#Sonarr" class="headerlink" title="Sonarr"></a>Sonarr</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>创建docker的时候NetWork Mode 选择 host，对于剧集管理下面可能会分好几个子类，例如电视剧、动漫、综艺等，只需要挂载子类目的父级就好了，如下图：<br><img src="https://s2.loli.net/2022/01/20/xHhmIGpTrREW1cS.png" alt=""></p><p>导入的时候需要全部导入：</p></li></ul><p>​    <img src="https://s2.loli.net/2022/01/20/NbSqc5PUh4WDnLt.png" alt=""></p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><h4 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h4><p>​    Language Profiles 这里需要注意，最开始只有一个English，我建议新增一个包含所有语言的选项，这里标注的1、2、3在后面有用。</p><p><img src="https://s2.loli.net/2022/01/20/V6WnjITYtAm4UZP.png" alt=""></p><h4 id="Download-Clients"><a href="#Download-Clients" class="headerlink" title="Download Clients"></a>Download Clients</h4><p>​    参考Radarr</p><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>​    参考Radarr    </p><h3 id="Radarr"><a href="#Radarr" class="headerlink" title="Radarr"></a>Radarr</h3><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul><li>莫名其妙的报错  TypeError: I.responeseJSON.map is not a function</li></ul><p>在导入本地电影的时候会不成功，就像下面的图片一样，是因为接口超时导致的，十分恼火，导入很多次到了最后一步就出错了</p><p><img src="https://s2.loli.net/2022/01/20/9DHR1QKZvBPyzje.png" alt=""></p><p>​    经过不懈的查找，终于解决了，就是在创建docker需要修改NetWork Mode，<strong>将bridge 改成 host</strong>，建议Sonarr最好这样做。</p><p><img src="https://s2.loli.net/2022/01/20/Iibxrfmw75gYoBh.png" alt=""></p><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><pre><code>可以将UI改成中文界面在操作</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>为什么需要注意这一点，是因为我在下载电影的时候发现搜索出现了阻塞，虽然找到了资源，但是由于某些原型没有进行下载，例如</p><p><img src="https://s2.loli.net/2022/01/20/KVD1XEGWTxoviyO.png" alt=""></p><p>红色的感叹号提示： 需要找的是英文资源，但实际找到的是中文，导致了阻塞，所以需要这样设置：</p><p>​    <img src="https://s2.loli.net/2022/01/20/CIgefZiOp9kJ2bR.png" alt=""></p><p>​    </p><h4 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h4><p>​    这里需要注意的是远程路径映射，我的理解是将下载器的下载路径和想要将资源放入的路径做映射。</p><p>​    这个图片是创建docker容器时候需要配置的：</p><p>​    <img src="https://s2.loli.net/2022/01/20/EfQY2JZctryDOGz.png" alt=""></p><p>​    这个图片是需要配置的映射关系，Remote Path是你实际需要存入的路径， Local Path 是下载器的路径</p><p><img src="https://s2.loli.net/2022/01/20/FrkcnUKxySXoMVq.png" alt=""></p><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>​    可以选择开启一个刮削器</p><p><img src="https://s2.loli.net/2022/01/20/ECY7t8giBHqe9LS.png" alt=""></p><h4 id="系统-健康度"><a href="#系统-健康度" class="headerlink" title="系统-健康度"></a>系统-健康度</h4><p>​    可以在这里看到那些异常情况，上面的路径映射在这里提示我才改好的</p><p><img src="https://s2.loli.net/2022/01/20/V7SQtMIL431vJf6.png" alt=""></p><h3 id="制作自动下载视频资源的Docker"><a href="#制作自动下载视频资源的Docker" class="headerlink" title="制作自动下载视频资源的Docker"></a>制作自动下载视频资源的Docker</h3><ol><li><strong>下载代码</strong></li></ol><p>​    <a href="https://github.com/muyeyong/movie_robot">豆瓣电影下载</a></p><ol start="2"><li><strong>配置自己的user_config.yml</strong></li></ol><p>​    主要分为图片中的4点来说明    <img src="https://s2.loli.net/2022/01/20/B7IRxmFsvw1dgkY.png" alt=""></p><p><img src="https://s2.loli.net/2022/01/20/1Omf2XuWbLq4nG3.png" alt=""></p><p>​     1、2、3 点： 这里每个人可能不一样，这里以语言偏好为例介绍：</p><p>​    F12 或者 右键检查 ，根据图片提示，可以看到 allLanguage: 3 , Chiness: 2, English: 1</p><p>​    <img src="https://s2.loli.net/2022/01/20/bFLUaXmAeVOBukW.png" alt=""></p><p>​    4点： 测试有限，出现路径对应出错，请自行设置</p><ol start="3"><li><p><strong>制作Docker</strong></p><p>将你配置好的代码全部上传到你需要运行的机器上，运行下面的代码</p><pre><code>sudo docker build -t movie_robot  . -f Dockerfile  --platform linux/amd64 // 制作镜像docker images // 查看镜像sudo docker run -it -v data:放置user_config.yml的路径 movie_robot // 运行镜像，需要将/data和你放user_config.yml的目录做映射</code></pre></li></ol><p><img src="https://s2.loli.net/2022/01/25/6T2e8RXdriGbAsl.png" alt=""></p><p>最后的效果：    </p><p><img src="https://s2.loli.net/2022/01/20/pz6RiHwNS8MuehD.png" alt=""></p><p>个人水平有限，里面还是有很多问题，有几率添加不成功，马马虎虎能用，如果你能改进，请随意，切图仔不容易。</p><h2 id="2022-03-17-补充"><a href="#2022-03-17-补充" class="headerlink" title="2022-03-17 补充"></a>2022-03-17 补充</h2><h3 id="关于docker制作"><a href="#关于docker制作" class="headerlink" title="关于docker制作"></a>关于docker制作</h3><pre><code>sudo docker build -t movie_robot  . -f Dockerfile  --platform linux/amd64 // 制作镜像docker images // 查看镜像可以将镜像打包成tar格式，然后上传到安装机器： docker save -o movie_robot.tar movie_robot 就会在当前目录下生成movie_robot.tar上传到运行的机器即可sudo docker run -it -v data:放置user_config.yml的路径 movie_robot // 运行镜像，需要将/data和你放user_config.yml的目录做映射</code></pre><p>以威联通为例：</p><p>​    <img src="https://s2.loli.net/2022/03/17/yaMifmPXO5j3BnQ.png" alt=""></p><h3 id="FlareSolver-意外停止"><a href="#FlareSolver-意外停止" class="headerlink" title="FlareSolver 意外停止"></a>FlareSolver 意外停止</h3><p><img src="https://s2.loli.net/2022/03/17/6xZksRwLG25lAFh.png" alt=""></p><p>原因是访问不了google，需要在环境变量配置 <code>URL_TEST:https://www.baidu.com</code>就可以解决</p><p><img src="https://s2.loli.net/2022/03/17/ORZe3q1sy8Gg5Af.png" alt=""></p><h3 id="Sonarr-Radarr-索引器-Indexers-配置"><a href="#Sonarr-Radarr-索引器-Indexers-配置" class="headerlink" title="Sonarr Radarr 索引器(Indexers)配置"></a>Sonarr Radarr 索引器(Indexers)配置</h3><p>​    是否选择这个索引器搜索跟Categories有很大的关系，例如你想下载电影，但是Categories没有电影这个类别，就不会使用这个索引器搜索资源，如果不知道怎么选择，就全部勾上吧。</p><p><img src="https://s2.loli.net/2022/03/17/XWgT28qnrNLv7ay.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS 路由 内网穿透 影视 观影自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码-trigger</title>
      <link href="/2021/11/30/yuan-ma-trigger/"/>
      <url>/2021/11/30/yuan-ma-trigger/</url>
      
        <content type="html"><![CDATA[<h1 id="源码-trigger"><a href="#源码-trigger" class="headerlink" title="源码-trigger"></a>源码-trigger</h1><p>​    逛b站的时候，偶然发现一个有意思的<a href="https://github.com/triggerjs/trigger">动画效果库</a>，展示的效果如下</p><p><img src="https://i.loli.net/2021/11/30/2hSADCbfBmypjis.gif" alt=""></p><p>​    于是研究了下它的源码，具体的工作流程是将视口划分成指定的块，比如使用指令<code>tg-from:1 tg-to:10</code>那就是将视口划分成10份，在对应的dom上设置哪个区间(<code>tg-filter</code>)去出发什么样的效果(<code>tg-map</code>)，就涉及到怎么去定位dom到了哪个区间，分析下dom在屏幕中的运动过程</p><p><img src="https://i.loli.net/2021/11/30/z3ZohGuPaEbs9pB.png" alt=""></p><p>​    将已经运动的距离/ 整个运动距离，就可以得出一个百分比，将这个百分比再去✖️设定的运动长度(<code>(tg-to) - (tg-from) + 1</code>)，就可以得到dom运动到了哪个块，最后去设置你想要设置的css属性就可以了，这只是一个很粗略的过程，具体的实现比我说的复杂的多，比如要去解析不同的指令，比如<code>tg-name tg-map tg-filter</code>、将指令转化成css属性等等。</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token comment" spellcheck="true">// edge is 'cover' by default</span>    <span class="token keyword">let</span> percentage <span class="token operator">=</span> <span class="token comment" spellcheck="true">// 计算百分比</span>      edge <span class="token operator">===</span> <span class="token string">'cover'</span>        <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>            Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> <span class="token comment" spellcheck="true">// scrolled：  clientHeight：可见区域的高度 针对整个文档  top height 针对当前的元素</span>              <span class="token comment" spellcheck="true">// 不是实时的获取 top 的值，所以需要加上 scrolled，如果改成实时获取了？</span>              <span class="token punctuation">(</span>scrolled <span class="token operator">+</span> clientHeight <span class="token operator">-</span> top<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>clientHeight <span class="token operator">+</span> height<span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token number">0</span>            <span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token number">1</span>          <span class="token punctuation">)</span>        <span class="token punctuation">:</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scrolled <span class="token operator">-</span> top<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>height <span class="token operator">-</span> clientHeight<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Calculation result value of bezier</span>    percentage <span class="token operator">=</span> bezier <span class="token operator">?</span> <span class="token function">ease</span><span class="token punctuation">(</span>bezier<span class="token punctuation">,</span> percentage<span class="token punctuation">)</span> <span class="token punctuation">:</span> percentage<span class="token punctuation">;</span>    <span class="token keyword">let</span> value<span class="token punctuation">:</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>    <span class="token keyword">const</span> mappingValue <span class="token operator">=</span> <span class="token punctuation">(</span>      <span class="token keyword">from</span> <span class="token operator">+</span>      Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>segments <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> percentage<span class="token punctuation">)</span> <span class="token operator">*</span> increment <span class="token operator">*</span> multiplier    <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>decimals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 会有存在小数的情况 (to - from) / steps 小数</span>    <span class="token comment" spellcheck="true">// 这里实际上可以看成将视口分成 from - to 的间隔，(to - from ）+ 1) * percentage， 在向下取正</span>    value <span class="token operator">=</span> <span class="token operator">+</span>mappingValue<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>filter<span class="token punctuation">.</span>values<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>filter<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// If the mode is 'exact', remove the CSS property</span>      <span class="token comment" spellcheck="true">// Setting the lastValue to null to ensure correct comparison below</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>filter<span class="token punctuation">.</span>mode <span class="token operator">===</span> <span class="token string">'exact'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        element<span class="token punctuation">.</span>lastValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        el<span class="token punctuation">.</span>style<span class="token punctuation">.</span><span class="token function">removeProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> mapping<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      value <span class="token operator">=</span> mapping<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre><code>## 我学到的</code></pre><p>​    1. 私有属性的写法： –selfProperty</p><p>​    2. 以前想到是不是可以在css里面去使用动态变量，在这个库里面看到使用 <code>var</code>实现，动态改变私有属性，将私有属性的值赋予对应的        css属性</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有意思的npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-Vue/项目总结</title>
      <link href="/2021/11/24/xiang-mu-xue-xi-vue/xiang-mu-zong-jie/"/>
      <url>/2021/11/24/xiang-mu-xue-xi-vue/xiang-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="用户体验优化"><a href="#用户体验优化" class="headerlink" title="用户体验优化"></a>用户体验优化</h2><ol><li>加载页面的时候</li><li>数据刷新的时候</li><li>动画效果</li><li>组件切换时的过渡效果</li></ol><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><ol><li>不要把判断写的过死</li><li>合适的时候发请求</li></ol><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ol><li>样式结构<ul><li>不同组件的样式影响</li><li>结构分析以及命名</li></ul></li><li>逻辑结构<ul><li>函数职责单一</li><li>健壮性</li></ul></li></ol><h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><p>存储用户需要的数据</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-函数式编程</title>
      <link href="/2021/08/02/javascript-han-shu-shi-bian-cheng/"/>
      <url>/2021/08/02/javascript-han-shu-shi-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-函数式编程"><a href="#JavaScript-函数式编程" class="headerlink" title="JavaScript-函数式编程"></a>JavaScript-函数式编程</h1><p>函数<strong>显示输出</strong> 和 <strong>隐式输出</strong>，隐式输出也称为函数的<strong>副作用</strong>，没有副作用的函数称为<strong>纯函数</strong></p><p><strong>高阶函数</strong>： 可以接受或返回一个甚至多个函数，高阶函数可使用闭包。偏函数应用、柯里化</p><p>具名函数： 语义化代码，但箭头函数除外</p><p>丢掉this：this是函数的隐式输入</p><p>函数不仅仅是一个语句或操作的集合，而是需要一个或多个输入和一个输出</p><p>函数的参数逐渐减少的过程就是<strong>偏应用</strong></p><p>柯里化：接收单一实参（实参个数：1）并返回另一个接收下一个实参的函数，将f(a,b,c) 转化为f(a)(b)(c)</p><p>引用外部变量都会造成副作用</p><p>命令式编程 、 声明式编程 和响应式编程： 使用纯函数组合、使用promise 和 监听去除异步复杂度</p><p>​    声明式编程是命令式编程的抽象，命令式编程是具体实现</p><p>对于偏函数 和 柯里化需要练习</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-初步学习</title>
      <link href="/2021/06/30/vue3-chu-bu-xue-xi/"/>
      <url>/2021/06/30/vue3-chu-bu-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-初步学习"><a href="#Vue3-初步学习" class="headerlink" title="Vue3-初步学习"></a>Vue3-初步学习</h1><h2 id="六大亮点"><a href="#六大亮点" class="headerlink" title="六大亮点"></a>六大亮点</h2><ul><li>Performance: 性能比vue2.x快1.2~2倍</li><li>Tree shaking support: 按需编译，体积比Vue2.x更小</li><li>Composition API: 组合API（类似React Hooks）</li><li>Better TypeScript support: 更好的Ts支持</li><li>Custom Render API: 暴露了自定义渲染API</li><li>Fragment，Teleport(Protal)，Suspense: 更先进的组件</li></ul><h2 id="性能如何提升"><a href="#性能如何提升" class="headerlink" title="性能如何提升"></a>性能如何提升</h2><ul><li>新增静态标记(diff算法优化)</li></ul><p><strong>vue2.x diff算法(以<a href="https://github.com/snabbdom/snabbdom#opportunity-for-community-feedback">snabbdom</a>为例)</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>  init<span class="token punctuation">,</span>  classModule<span class="token punctuation">,</span>  propsModule<span class="token punctuation">,</span>  styleModule<span class="token punctuation">,</span>  eventListenersModule<span class="token punctuation">,</span>  h<span class="token punctuation">,</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"snabbdom"</span><span class="token punctuation">;</span><span class="token keyword">const</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token comment" spellcheck="true">// Init patch function with chosen modules</span>  classModule<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// makes it easy to toggle classes</span>  propsModule<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// for setting properties on DOM elements</span>  styleModule<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// handles styling on elements with support for animations</span>  eventListenersModule<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// attaches event listeners</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"container"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">"div#container.two.classes"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> on<span class="token punctuation">:</span> <span class="token punctuation">{</span> click<span class="token punctuation">:</span> someFn <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> style<span class="token punctuation">:</span> <span class="token punctuation">{</span> fontWeight<span class="token punctuation">:</span> <span class="token string">"bold"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"This is bold"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token string">" and this is just normal text"</span><span class="token punctuation">,</span>  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> props<span class="token punctuation">:</span> <span class="token punctuation">{</span> href<span class="token punctuation">:</span> <span class="token string">"/foo"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"I'll take you places!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Patch into empty DOM element – this modifies the DOM as a side effect</span><span class="token comment" spellcheck="true">// 将vnode 渲染到空的容器里面</span><span class="token function">patch</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> newVnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>  <span class="token string">"div#container.two.classes"</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> on<span class="token punctuation">:</span> <span class="token punctuation">{</span> click<span class="token punctuation">:</span> anotherEventHandler <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span>    <span class="token function">h</span><span class="token punctuation">(</span>      <span class="token string">"span"</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> style<span class="token punctuation">:</span> <span class="token punctuation">{</span> fontWeight<span class="token punctuation">:</span> <span class="token string">"normal"</span><span class="token punctuation">,</span> fontStyle<span class="token punctuation">:</span> <span class="token string">"italic"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token string">"This is now italic type"</span>    <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">" and this is still just normal text"</span><span class="token punctuation">,</span>    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> props<span class="token punctuation">:</span> <span class="token punctuation">{</span> href<span class="token punctuation">:</span> <span class="token string">"/bar"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"I'll take you places!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Second `patch` invocation</span><span class="token comment" spellcheck="true">// 更新vnode</span><span class="token function">patch</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Snabbdom efficiently updates the old view to the new state</span></code></pre><p>​    vnode：使用js来描述真实的dom节点</p><p>​    h函数：生成vnode</p><p>​                <img src="https://i.loli.net/2021/06/30/OYTRcAr9z1Vpn8o.png" alt=""></p><p>​            h函数最终返回的是<code>{ sel, data, children, text, elm, key }</code>集合对象</p><p>​                sel: 选择器， 类似于div、p    </p><p>​                data: 事件、样式等</p><p>​                children: 子节点（children与text只会存在一个）</p><p>​                text: 纯文本（children与text只会存在一个）</p><p>​                elm: 真实的dom元素</p><p>​                key: 唯一标志</p><p>​    patch函数：<strong>首次渲染将vnode渲染到空的容器</strong> 以及 <strong>更新vnode</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">:</span> VNode <span class="token operator">|</span> Element<span class="token punctuation">,</span> vnode<span class="token punctuation">:</span> VNode<span class="token punctuation">)</span><span class="token punctuation">:</span> VNode <span class="token punctuation">{</span>    <span class="token keyword">let</span> i<span class="token punctuation">:</span> number<span class="token punctuation">,</span> elm<span class="token punctuation">:</span> Node<span class="token punctuation">,</span> parent<span class="token punctuation">:</span> Node<span class="token punctuation">;</span>    <span class="token keyword">const</span> insertedVnodeQueue<span class="token punctuation">:</span> VNodeQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果oldVnode是dom，就去生成vnode，emptyNodeAt返回的是一个vnode</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      oldVnode <span class="token operator">=</span> <span class="token function">emptyNodeAt</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果两个是相同的vnode（比较vnode的sel和key），就去更新</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 不是相同的vnode</span>      elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">;</span>      parent <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token keyword">as</span> Node<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 创建dom元素</span>      <span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 插入新的dom元素</span>        api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除老的dom元素</span>        <span class="token function">removeVnodes</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token punctuation">[</span>oldVnode<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> insertedVnodeQueue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      insertedVnodeQueue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">!</span><span class="token punctuation">.</span>hook<span class="token operator">!</span><span class="token punctuation">.</span>insert<span class="token operator">!</span><span class="token punctuation">(</span>insertedVnodeQueue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>post<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>post<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> vnode<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>patchVnode：<strong>当老的vnode和新的vnode相等时，调用更新</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">patchVnode</span><span class="token punctuation">(</span>    oldVnode<span class="token punctuation">:</span> VNode<span class="token punctuation">,</span>    vnode<span class="token punctuation">:</span> VNode<span class="token punctuation">,</span>    insertedVnodeQueue<span class="token punctuation">:</span> VNodeQueue  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> hook <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token operator">?</span><span class="token punctuation">.</span>hook<span class="token punctuation">;</span>    hook<span class="token operator">?</span><span class="token punctuation">.</span>prepatch<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给新的vnode关联dom元素</span>    <span class="token keyword">const</span> elm <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children <span class="token keyword">as</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> ch <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token keyword">as</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">===</span> vnode<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>data <span class="token operator">!==</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>update<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cbs<span class="token punctuation">.</span>update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>      vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>hook<span class="token operator">?</span><span class="token punctuation">.</span>update<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果新的vnode不存在文本节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 老的vnode存在children &amp; 新的vnode存在存在children</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 两者的children不相等，进行更新</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">!==</span> ch<span class="token punctuation">)</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新的vnode存在children，老的vnode不存在children</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将elm的text设置为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 更新elm，插入children</span>        <span class="token function">addVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ch<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新的vnode不存在children，老的vnode存在children</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 更新elm，移除老vnode的children</span>        <span class="token function">removeVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 两者都不存在children，新的vnode即不存在children 也不存在text，老的vnode存在text</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 更新elm，设置text为空</span>        api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 两者的text并不相等，可能为null</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 如果老的vnode存在children则移除</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">removeVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 更新elm，设置text</span>      api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>text<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    hook<span class="token operator">?</span><span class="token punctuation">.</span>postpatch<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>updateChildren：<strong>当老的vnode的children和新的vnode的children不相等是调用，进行后代更新</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span>    parentElm<span class="token punctuation">:</span> Node<span class="token punctuation">,</span>    oldCh<span class="token punctuation">:</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    newCh<span class="token punctuation">:</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    insertedVnodeQueue<span class="token punctuation">:</span> VNodeQueue  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> oldStartIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> newStartIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> newEndIdx <span class="token operator">=</span> newCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> oldEndIdx <span class="token operator">=</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>oldEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>newEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> oldKeyToIdx<span class="token punctuation">:</span> KeyToIndexMap <span class="token operator">|</span> undefined<span class="token punctuation">;</span>    <span class="token keyword">let</span> idxInOld<span class="token punctuation">:</span> number<span class="token punctuation">;</span>    <span class="token keyword">let</span> elmToMove<span class="token punctuation">:</span> VNode<span class="token punctuation">;</span>    <span class="token keyword">let</span> before<span class="token punctuation">:</span> any<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Vnode might have been moved left</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newStartVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newEndVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Vnode moved right</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>          parentElm<span class="token punctuation">,</span>          oldStartVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">,</span>          api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Vnode moved left</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldEndVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldKeyToIdx <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>          oldKeyToIdx <span class="token operator">=</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        idxInOld <span class="token operator">=</span> oldKeyToIdx<span class="token punctuation">[</span>newStartVnode<span class="token punctuation">.</span>key <span class="token keyword">as</span> string<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>idxInOld<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// New element</span>          api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>            parentElm<span class="token punctuation">,</span>            <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">,</span>            oldStartVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span>          <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          elmToMove <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>elmToMove<span class="token punctuation">.</span>sel <span class="token operator">!==</span> newStartVnode<span class="token punctuation">.</span>sel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>              parentElm<span class="token punctuation">,</span>              <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">,</span>              oldStartVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">patchVnode</span><span class="token punctuation">(</span>elmToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>            oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> undefined <span class="token keyword">as</span> any<span class="token punctuation">;</span>            api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> elmToMove<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">||</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">></span> oldEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        before <span class="token operator">=</span> newCh<span class="token punctuation">[</span>newEndIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> newCh<span class="token punctuation">[</span>newEndIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>elm<span class="token punctuation">;</span>        <span class="token function">addVnodes</span><span class="token punctuation">(</span>          parentElm<span class="token punctuation">,</span>          before<span class="token punctuation">,</span>          newCh<span class="token punctuation">,</span>          newStartIdx<span class="token punctuation">,</span>          newEndIdx<span class="token punctuation">,</span>          insertedVnodeQueue        <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">removeVnodes</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>​    Vue2中虚拟dom是进行全量比较</p><p>​    Vue3新增静态标记(PatchFlag)，在于上次虚拟节点进行比较的时候，只对比带有patch falg的节点</p><ul><li>静态提升</li></ul><ul><li><p>事件监听缓存</p></li><li><p>ssr渲染</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue-初识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript核心-深浅拷贝</title>
      <link href="/2021/05/27/javascript-he-xin-shen-qian-kao-bei/"/>
      <url>/2021/05/27/javascript-he-xin-shen-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript核心-深浅拷贝"><a href="#JavaScript核心-深浅拷贝" class="headerlink" title="JavaScript核心-深浅拷贝"></a>JavaScript核心-深浅拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h3><p>​    对于引用对象类型只能复制引用地址</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><h4 id="object-asign"><a href="#object-asign" class="headerlink" title="object.asign()"></a>object.asign()</h4><h4 id="Array-slice"><a href="#Array-slice" class="headerlink" title="Array.slice()"></a>Array.slice()</h4><h4 id="解构运算符-…"><a href="#解构运算符-…" class="headerlink" title="解构运算符(…)"></a>解构运算符(…)</h4><h4 id="Array-concat"><a href="#Array-concat" class="headerlink" title="Array.concat()"></a>Array.concat()</h4><h4 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h4><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="什么是深拷贝"><a href="#什么是深拷贝" class="headerlink" title="什么是深拷贝"></a>什么是深拷贝</h3><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><h4 id="Json-strin-amp-Json-param"><a href="#Json-strin-amp-Json-param" class="headerlink" title="Json.strin &amp; Json.param()"></a>Json.strin &amp; Json.param()</h4><h4 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h4><p>不可枚举的属性以及 Symbol 类型</p><p>WeakMap</p><p>Reflect.ownKeys()</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript核心 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的API-IntersectionObserver</title>
      <link href="/2021/05/21/hao-yong-de-api-intersectionobserver/"/>
      <url>/2021/05/21/hao-yong-de-api-intersectionobserver/</url>
      
        <content type="html"><![CDATA[<h1 id="好用的API-IntersectionObserver"><a href="#好用的API-IntersectionObserver" class="headerlink" title="好用的API-IntersectionObserver"></a>好用的API-IntersectionObserver</h1><blockquote><p>​    前段时间研究PDF展示的时候，在github上找到了一段写的很好的代码（向大佬致敬），它实现加载更多的时候使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">IntersectionObserver</a>这个API，我觉得挺好的，分享给大家，然后写了一个<a href="https://github.com/muyeyong/test/tree/main/intersection-demo">demo</a>，实现了惰性加载和无限滚动。</p></blockquote><p>​    如果你不熟悉可以看看<a href="https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">这篇文章</a>，里面的内容可能没有及时更新，可搭配<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">MDN</a>食用。先看一下demo效果：</p><p>​        <img src="https://i.loli.net/2021/05/21/XoALV34m7zeaMYK.gif" alt=""></p><p>​    动图太快，我们看静态.png</p><p><img src="https://i.loli.net/2021/05/21/IGifLM7ZNVD6wnH.png" alt=""></p><p>​    最开始渲染了，<strong>11</strong>个<code>li</code>标签，但是只有在屏幕上显示的<strong>5</strong>个<code>li</code>标签才加载了图片，其他在不可见范围内的<code>li</code>是没有加载图片的，实现了<code>资源的懒加载</code>，在滚动的过程中，会加载可视范围内<code>li</code>的图片资源，滚动到底后，会加载更多图片，实现<code>无限滚动</code>。</p><p><img src="https://i.loli.net/2021/05/21/mYSUk7qElPZXOoF.png" alt=""></p><p>​    这一切的一切全是全部是<code>IntersectionObserver</code>的功劳。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// APP.vue</span><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"imgs"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">" i in wrapMaxCount"</span> <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"i"</span> v<span class="token operator">-</span>visible<span class="token punctuation">.</span>once<span class="token operator">=</span><span class="token string">"loadImg"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"img-item"</span> <span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>    <span class="token operator">&lt;</span>div  v<span class="token operator">-</span>visible <span class="token operator">=</span> <span class="token string">"loadMore"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"observer"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> visible <span class="token keyword">from</span> <span class="token string">'./directives/visible'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"App"</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  directives<span class="token punctuation">:</span> <span class="token punctuation">{</span>    visible<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      maxCount<span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">,</span>      currIndex<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      wrapMaxCount<span class="token punctuation">:</span> <span class="token number">11</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">getImg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> i <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./assets/demo</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.jpg`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">loadImg</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currIndex <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxCount      <span class="token keyword">const</span> elImg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span>      elImg<span class="token punctuation">.</span>src <span class="token operator">=</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getImg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>      e<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elImg<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>currIndex <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">loadMore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'loadMore'</span><span class="token punctuation">)</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>wrapMaxCount <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">smartNav</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span>        nav<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> params <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> defaults<span class="token punctuation">,</span> options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> elements <span class="token operator">==</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        elements <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>elements<span class="token punctuation">.</span>forEach<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 导航元素创建，如果没有</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>params<span class="token punctuation">.</span>nav<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span>nav <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span>nav<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"title-nav-ul"</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span>nav<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">var</span> lastScrollTop <span class="token operator">=</span> document<span class="token punctuation">.</span>scrollingElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>      <span class="token keyword">var</span> zxxObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span>isAvoid<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        entries<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>            entry<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>target<span class="token punctuation">.</span>isActived<span class="token punctuation">)</span> <span class="token punctuation">{</span>            entry<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">unactive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lastScrollTop <span class="token operator">=</span> document<span class="token punctuation">.</span>scrollingElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      elements<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>ele<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> id <span class="token operator">=</span> ele<span class="token punctuation">.</span>id <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token string">"smartNav"</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"0."</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ele<span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 导航元素创建</span>        <span class="token keyword">var</span> eleNav <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        eleNav<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"#"</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        eleNav<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"title-nav-li"</span><span class="token punctuation">;</span>        eleNav<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> ele<span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>        params<span class="token punctuation">.</span>nav<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>eleNav<span class="token punctuation">)</span><span class="token punctuation">;</span>        ele<span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 对应的导航元素高亮</span>          eleNav<span class="token punctuation">.</span>parentElement            <span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">".active"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>eleActive<span class="token punctuation">)</span> <span class="token punctuation">{</span>              ele<span class="token punctuation">.</span>isActived <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              eleActive<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"active"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          eleNav<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"active"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          ele<span class="token punctuation">.</span>isActived <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        ele<span class="token punctuation">.</span>unactive <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 对应的导航元素高亮</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>scrollingElement<span class="token punctuation">.</span>scrollTop <span class="token operator">></span> lastScrollTop<span class="token punctuation">)</span> <span class="token punctuation">{</span>            elements<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> elements<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            elements<span class="token punctuation">[</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> elements<span class="token punctuation">[</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          eleNav<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"active"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          ele<span class="token punctuation">.</span>isActived <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察元素</span>        zxxObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      params<span class="token punctuation">.</span>nav<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> eleLink <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">closest</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 导航对应的标题元素</span>        <span class="token keyword">var</span> eleTarget <span class="token operator">=</span>          eleLink <span class="token operator">&amp;&amp;</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eleTarget<span class="token punctuation">)</span> <span class="token punctuation">{</span>          event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// Safari不支持平滑滚动</span>          eleTarget<span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            behavior<span class="token punctuation">:</span> <span class="token string">"smooth"</span><span class="token punctuation">,</span>            block<span class="token punctuation">:</span> <span class="token string">"center"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>CSS<span class="token punctuation">.</span><span class="token function">supports</span><span class="token punctuation">(</span><span class="token string">"scroll-behavior: smooth"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            params<span class="token punctuation">.</span>isAvoid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              eleTarget<span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              params<span class="token punctuation">.</span>isAvoid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>              eleTarget<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top <span class="token operator">-</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">/</span> <span class="token number">2</span>            <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            eleTarget<span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span>#app <span class="token punctuation">{</span>  font<span class="token operator">-</span>family<span class="token punctuation">:</span> Avenir<span class="token punctuation">,</span> Helvetica<span class="token punctuation">,</span> Arial<span class="token punctuation">,</span> sans<span class="token operator">-</span>serif<span class="token punctuation">;</span>  <span class="token operator">-</span>webkit<span class="token operator">-</span>font<span class="token operator">-</span>smoothing<span class="token punctuation">:</span> antialiased<span class="token punctuation">;</span>  <span class="token operator">-</span>moz<span class="token operator">-</span>osx<span class="token operator">-</span>font<span class="token operator">-</span>smoothing<span class="token punctuation">:</span> grayscale<span class="token punctuation">;</span>  color<span class="token punctuation">:</span> #2c3e50<span class="token punctuation">;</span>  margin<span class="token operator">-</span>top<span class="token punctuation">:</span> 60px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span>imgs<span class="token punctuation">{</span>  display<span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  flex<span class="token operator">-</span>direction<span class="token punctuation">:</span> column<span class="token punctuation">;</span>  align<span class="token operator">-</span>items<span class="token punctuation">:</span> center<span class="token punctuation">;</span>  margin<span class="token punctuation">:</span> 1rem auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span>img<span class="token operator">-</span>item<span class="token punctuation">{</span>  width<span class="token punctuation">:</span> <span class="token number">31</span><span class="token punctuation">.</span>25rem<span class="token punctuation">;</span>  height<span class="token punctuation">:</span> <span class="token number">31</span><span class="token punctuation">.</span>25rem<span class="token punctuation">;</span>  list<span class="token operator">-</span>style<span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span>img<span class="token operator">-</span>item img<span class="token punctuation">{</span>  width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>  height<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// directive visible</span><span class="token keyword">const</span> observerMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> createObserve <span class="token operator">=</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span>vnode<span class="token punctuation">,</span>modifiers<span class="token punctuation">,</span>callBack<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>entries<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">const</span> entry <span class="token operator">=</span> entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">callBack</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> modifiers <span class="token operator">&amp;&amp;</span> modifiers<span class="token punctuation">.</span>once<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">disconnectObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    vnode<span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> observer<span class="token punctuation">}</span><span class="token keyword">const</span> disconnectObserver <span class="token operator">=</span> <span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">{</span>    observer<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> bind <span class="token operator">=</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span><span class="token punctuation">{</span>value<span class="token punctuation">,</span>modifiers <span class="token punctuation">}</span><span class="token punctuation">,</span>vnode<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> window<span class="token punctuation">.</span>IntersectionObserver <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">'IntersectionObserver API is not available in your browser.'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">createObserve</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span>vnode<span class="token punctuation">,</span>modifiers<span class="token punctuation">,</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">const</span> callback <span class="token operator">=</span> value            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>            <span class="token function">callback</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        observerMap<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span><span class="token punctuation">{</span>observer<span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span>modifiers <span class="token punctuation">}</span><span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">===</span> oldValue<span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>observer<span class="token punctuation">}</span> <span class="token operator">=</span> observerMap<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>    <span class="token function">disconnectObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>    <span class="token function">bind</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span><span class="token punctuation">{</span>value<span class="token punctuation">,</span>modifiers<span class="token punctuation">}</span><span class="token punctuation">,</span>vnode<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> unbind <span class="token operator">=</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>observerMap<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span>observer<span class="token punctuation">}</span> <span class="token operator">=</span> observerMap<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>        <span class="token function">disconnectObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>        observerMap<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    bind<span class="token punctuation">,</span>    update<span class="token punctuation">,</span>    unbind<span class="token punctuation">}</span></code></pre><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>​    懒加载：</p><p>​        <code>IntersectionObserver</code>提供<code>isIntersecting</code>方法，检测元素是否出现在可视区域内，如果出现在可视区域内就去执行回调函数。once修饰符确保只执行一次回调，update方法中的 <code>if(value === oldValue) return</code>判断是为了保证已经渲染过的元素不在重新渲染，<code>value</code>是你绑定的值，也是需要回调的函数，不要使用<code>()=&gt;doSome()</code>，会被判定成不相等，会重复渲染。</p><p>无限加载：</p><p>​    放一个空白的<code>div</code>在底部，当出现的时候去执行相应的加载回调函数。        </p><p>​    </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 好用的API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无限循环 惰性加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件-toast</title>
      <link href="/2021/05/06/zu-jian-toast/"/>
      <url>/2021/05/06/zu-jian-toast/</url>
      
        <content type="html"><![CDATA[<h1 id="一个比较好用的Toast"><a href="#一个比较好用的Toast" class="headerlink" title="一个比较好用的Toast"></a>一个比较好用的Toast</h1><p><a href="https://www.npmjs.com/package/m-toast-vue" target="_blank" rel="noopener">NPM</a></p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://i.loli.net/2021/05/08/XgNa6PwTM19x4io.gif" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue toast 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结-统一认证平台</title>
      <link href="/2021/04/13/xiang-mu-zong-jie-tong-yi-ren-zheng-ping-tai/"/>
      <url>/2021/04/13/xiang-mu-zong-jie-tong-yi-ren-zheng-ping-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="项目总结-认证平台"><a href="#项目总结-认证平台" class="headerlink" title="项目总结-认证平台"></a>项目总结-认证平台</h1><h2 id="遇到的问题及解决"><a href="#遇到的问题及解决" class="headerlink" title="遇到的问题及解决"></a>遇到的问题及解决</h2><h3 id="PDF展示"><a href="#PDF展示" class="headerlink" title="PDF展示"></a>PDF展示</h3><h4 id="怎样实现"><a href="#怎样实现" class="headerlink" title="怎样实现"></a>怎样实现</h4><h5 id="pdf-vue"><a href="#pdf-vue" class="headerlink" title="pdf-vue"></a><a href="https://github.com/FranckFreiburger/vue-pdf">pdf-vue</a></h5><p>​    使用很简单，直接看教程就可以了，但在使用的过程中遇到了几个问题：</p><p>​        1：pdf存在多页的加载</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>pdf<span class="token operator">-</span>vue            v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"i in pageCount"</span>            <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"i"</span>            <span class="token punctuation">:</span>src<span class="token operator">=</span><span class="token string">"src"</span>            <span class="token punctuation">:</span>page<span class="token operator">=</span><span class="token string">"i"</span>            style<span class="token operator">=</span><span class="token string">"display: inline-block; width: 25%"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>pdf<span class="token operator">></span></code></pre><p>​            <img src="https://i.loli.net/2021/04/25/SFJecpRWkAdjNGb.png" alt=""></p><p>​    通过for循环来加载多页，虽然可以解决多页展示的问题，但是如果你的pdf存N页的话，就会发送N个请求，等所有请求结束后才会展示pdf内容，网速不好、pdf过大….都会导致加载慢，用户体验不好。其实并不是一开始就加载所有的pdf，看多少就加载多少，于是就有了下面的代码</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>pdf<span class="token operator">-</span>vue         v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"i in copyPageCount"</span>     <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"i"</span>     <span class="token punctuation">:</span>page<span class="token operator">=</span><span class="token string">"i"</span>     <span class="token punctuation">:</span>src<span class="token operator">=</span><span class="token string">"src"</span>         style<span class="token operator">=</span><span class="token string">"display: inline-block; width: 25%"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>pdf<span class="token operator">-</span>vue<span class="token operator">></span></code></pre><p>​    就改了一个变量就这么神奇吗？当然不是，你以为我就只？少侠看下面</p><pre class=" language-javascript"><code class="language-javascript">listenScroll <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>dialogBody <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.dialog-confirm .el-dialog__wrapper .el-dialog .el-dialog__body'</span><span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>dialogBody<span class="token punctuation">.</span>scrollTop <span class="token operator">=</span> <span class="token number">0</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dialogBody<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dialogBody<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>loading <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dialogBody<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dialogBody<span class="token punctuation">.</span>scrollTop <span class="token operator">-</span>                          <span class="token keyword">this</span><span class="token punctuation">.</span>dialogBody<span class="token punctuation">.</span>clientHeight <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>loading <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>copyPageCount <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>copyPageCount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>pageCount <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pageCount <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>copyPageCount <span class="token operator">+</span> <span class="token number">1</span>          <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>​    原理是这样的，<code>copyPageCount</code>是一个假象，它并不是所有的pdf页数，初始值为1，当用户向下查看的是的，由于监听了滚动，会自动增加<code>copyPageCount</code>的值，<code>copyPageCount</code>变化了，pdf也会相应的加载。首次加载只加载了第一页，速度就快多了。</p><p><img src="https://i.loli.net/2021/04/25/dhCYm9SMctgO6GI.gif" alt=""></p><p>​        2：IE上的兼容</p><p>​            当在IE上打开页面的时候，发现是白屏，并且报错语法不兼容(来自pdfjs-dist)，虽然在<code>vue.config.js</code>里面加了 <code>transpileDependencies: ['pdfjs-dist'],</code>，虽然可以正常的打开页面，但是不能正常显示pdf，而且打包变得巨慢，所以需要在IE上使用的话，建议放弃。</p><p>说了这么多坏话，我们来夸一下它：</p><p>​    1：使用方便（相对于pdfjs）</p><p>​    2：展示效果更好，页面的缩放里面的内容也会相应的变化</p><p>​    <img src="https://i.loli.net/2021/04/25/LxhPslBCi3DdG64.gif" alt=""></p><h5 id="pdfjs"><a href="#pdfjs" class="headerlink" title="pdfjs"></a><a href="https://github.com/mozilla/pdf.js">pdfjs</a></h5><p>​    在使用之前最好看一下<a href="https://mozilla.github.io/pdf.js/legacy/web/viewer.html" target="_blank" rel="noopener">在线的demo</a>看看能不能满足你的需求，首先需要安装:<code>npm install pdfjs-dist</code>，如果有莫名其奥妙的报错，建议安装不一样的版本在尝试（2.2.228 or 2.3.200）。使用的话，需要先建一个<code>pdf.vue</code>的文件封装</p><pre class=" language-vue"><code class="language-vue"><template>    <div class="home_wrap" ref="pdf_wrap">        <!-- <div class="pdf_down">            <div class="pdf_set_left" @click="scaleD()">放大</div>            <div class="pdf_set_middle" @click="scaleX()">缩小</div>        </div> -->        <div :style="{ width: pdf_div_width, margin: '0 auto' }">            <canvas v-for="page in pdf_pages" :id="'the_canvas' + page" :key="page"></canvas>        </div>    </div></template><script>const PDFJS = require('pdfjs-dist')PDFJS.GlobalWorkerOptions.workerSrc = require("pdfjs-dist/build/pdf.worker.js")export default {  props: ['src', 'pageCount'],  watch: {    src () {      this.get_pdfurl()    }  },  data () {    return {      pdf_scale: 1,// pdf放大系数      pdf_pages: [],      pdf_div_width: '',      pdf_src: null,    }  },  mounted () {    this.get_pdfurl()  },  methods: {    scaleD () {  // 放大      let max = 0      if (window.screen.width > 1440) {        max = 1.4      } else {        max = 1.2      }      if (this.pdf_scale >= max) {        return      }      this.pdf_scale += 0.1      this.loadFile(this.pdf_src)    },    scaleX () {  // 缩小      const min = 1.0      if (this.pdf_scale <= min) {        return      }      this.pdf_scale -= 0.1      this.loadFile(this.pdf_src)    },    get_pdfurl () {  // 获得pdf教案      this.pdf_src = this.src      this.loadFile(this.pdf_src)    },    loadFile (url) {  // 初始化pdf      const loadingTask = PDFJS.getDocument(url)      loadingTask.promise        .then((pdf) => {          this.pdfDoc = pdf          this.pdf_pages = this.pageCount // this.pdfDoc.numPages          this.$nextTick(() => {            this.renderPage(1)            this.$emit('loaded')          })        })    },    renderPage (num) {  // 渲染pdf页      const that = this      this.pdfDoc.getPage(num)        .then((page) => {          const canvas = document.getElementById(`the_canvas${num}`)          const ctx = canvas.getContext('2d')          const dpr = window.devicePixelRatio || 1          const bsr = ctx.webkitBackingStorePixelRatio ||            ctx.mozBackingStorePixelRatio ||            ctx.msBackingStorePixelRatio ||            ctx.oBackingStorePixelRatio ||            ctx.backingStorePixelRatio || 1          const ratio = dpr / bsr          const viewport = page.getViewport({ scale: this.pdf_scale })          canvas.width = viewport.width * ratio          canvas.height = viewport.height * ratio          canvas.style.width = `${viewport.width}px`          that.pdf_div_width = `${viewport.width}px`          canvas.style.height = `${viewport.height}px`          ctx.setTransform(ratio, 0, 0, ratio, 0, 0)          const renderContext = {            canvasContext: ctx,            viewport          }          page.render(renderContext)          if (this.pdf_pages > num) {            this.renderPage(num + 1)          }        })    },  }}</script><style lang="less" scoped>.home_wrap {    width: 100%;    height: 100%;    .pdf_down {        position: fixed;        display: flex;        z-index: 20;        right: 26px;        bottom: 7%;        .pdf_set_left {            width: 30px;            height: 40px;            color: #408fff;            font-size: 11px;            padding-top: 25px;            text-align: center;            margin-right: 5px;            cursor: pointer;        }        .pdf_set_middle {            width: 30px;            height: 40px;            color: #408fff;            font-size: 11px;            padding-top: 25px;            text-align: center;            margin-right: 5px;            cursor: pointer;        }    }}</style></code></pre><p>​    在需要展示pdf的地方引用就好。但在使用的过程中还是遇到的问题，上图：</p><p><img src="https://i.loli.net/2021/04/25/Hb9AgKSlMTpQ1Eu.png" alt=""></p><p>​    两侧的留白太多，不美观。机智的我在官方的demo上看到了这个：</p><p><img src="https://i.loli.net/2021/04/25/5atrLp84iOmfJ2w.png" alt=""></p><p>​    如果选择适合页宽不就完美了吗？于是去找了下源码，发现了惊天大秘密，其实就是改变<code>scale</code>缩放来实现需要的效果。</p><p><a href="https://github.com/muyeyong/commonUtils/tree/master/pdf-vue">源码，适配IE</a></p><p>​    效果如下：</p><p><img src="https://i.loli.net/2021/04/25/TGXYvO5NPh8nuf1.png" alt=""></p><p>​    但还是存在些许优化，浏览器缩放的时候不能实现内容的缩放，相应的方法是监听窗口变化，改变<code>scale</code>值，相信你一定会写~。<code>pdf.js</code>相对<code>pdf-vue</code>在多页pdf上使用比较友好，不需要自己额外写方法实现，IE上也可以使用，综合体验更胜一筹。</p><h5 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h5><p>​    如果存在pdf跨域展示的问题，需要后端的配合，允许跨域。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    如果仅仅是展示pdf，为了获取更好的体验，可以考虑将pdf转成图片返回给前端进行展示，这样兼容和体验都不错。    </p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p><img src="https://i.loli.net/2021/04/25/36gCy7RslMEvWfZ.png" alt=""></p><pre class=" language-vue"><code class="language-vue">Vue.directive('down', {  update: (el, binding) => {    el.style.cssText = 'cursor: pointer;color:write;'    el.addEventListener('click', () => {      const link = document.createElement('a')      const url = binding.value      if (!url) return      // 这里是将url转成blob地址，      fetch(url).then(res => res.blob()).then(blob => { // 将链接地址字符内容转变成blob地址        link.href = URL.createObjectURL(blob)        link.download = ''        document.body.appendChild(link)        link.click()      })    })  }})</code></pre><p>​    最开始是通过vue directive实现的但是IE不兼容，会直接打开需要下载的pdf，于是写了两套逻辑。</p><p>​    非IE，直接调用<code>downloadFile</code>这个方法就可以了，例如：<code>downloadFile(this.pdfUrl, '授权书.pdf')</code></p><pre><code>function downloadBlob (url) {  return new Promise((resolve, reject) =&gt; {    const xhr = new XMLHttpRequest()    xhr.open("GET", url)    xhr.responseType = "blob"    xhr.onload = function () {      resolve(xhr.response)    }    xhr.onerror = function () {      reject(new Error("Download failed."))    }    xhr.send()  })}export function downloadFile (url, fileName = "") {  return downloadBlob(url, fileName)    .then(resp =&gt; {      if (resp.blob) {        return resp.blob()      }      return new Blob([resp])    })    .then(blob =&gt; URL.createObjectURL(blob))    // eslint-disable-next-line no-shadow    .then(url =&gt; {      // eslint-disable-next-line no-use-before-define      downloadURL(url, fileName)      URL.revokeObjectURL(url)    })    .catch(err =&gt; {      throw new Error(err.message)    })}export function downloadURL (url, name = "") {  const link = document.createElement("a")  link.download = name  link.href = url  if ("download" in document.createElement("a")) {    document.body.appendChild(link)    link.click()    document.body.removeChild(link)  } else {    // 对不支持download进行兼容    // eslint-disable-next-line no-use-before-define    click(link, (link.target = "_blank"))  }}function click (node) {  try {    node.dispatchEvent(new MouseEvent("click"))  } catch (e) {    const evt = document.createEvent("MouseEvents")    evt.initMouseEvent(      "click",      true,      true,      window,      0,      0,      0,      80,      20,      false,      false,      false,      false,      0,      null    )    node.dispatchEvent(evt)  }}</code></pre><p>​    IE版本，没错就这么简单，点击下载会询问你打开/保存</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pdfUrl<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>down-a<span class="token punctuation">"</span></span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>下载《授权书》<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>​    只有为什么没有用vue directive的原因，我也忘了。。。。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>​    没错还是IE的问题，使用的是vue directive，但是在IE上没有上传文件成功。</p><pre class=" language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'uploadImg'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  inserted<span class="token punctuation">:</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// eslint-disable-next-line no-param-reassign</span>    el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">'cursor: pointer;color:write;'</span>    el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> upload <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span>      <span class="token keyword">const</span> uploadResult <span class="token operator">=</span> binding<span class="token punctuation">.</span>value      upload<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>      upload<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'file'</span>      upload<span class="token punctuation">.</span>accept <span class="token operator">=</span> <span class="token string">'image/png, image/jpeg'</span>      upload<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isIE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">toBase64</span><span class="token punctuation">(</span>upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token function">uploadResult</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^data:image\/\w+;base64,/</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>type<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"image/"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        upload<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'change'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">toBase64</span><span class="token punctuation">(</span>upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token function">uploadResult</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^data:image\/\w+;base64,/</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>type<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"image/"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>​    这段代码是为了兼容IE设计的，解决change事件不响应，利用的是IE的一个特点：IE在关闭对话框之前都会挂起一个timeout</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">toBase64</span><span class="token punctuation">(</span>upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token function">uploadResult</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^data:image\/\w+;base64,/</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> upload<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>type<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"image/"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><h3 id="前端视频压缩"><a href="#前端视频压缩" class="headerlink" title="前端视频压缩"></a>前端视频压缩</h3><p>​        使用的是<a href="https://github.com/ffmpegwasm/ffmpeg.wasm">ffmpeg</a>，DEMO代码如下：</p><pre class=" language-vue"><code class="language-vue"><template>  <div id="app">    <input type="file" accept="video/*" capture="user" @change="videoChange">   </div></template><script>const { createFFmpeg, fetchFile } = require('@ffmpeg/ffmpeg');const ffmpeg = createFFmpeg({})export default {  name: 'App',  components: {  },  methods:{   async videoChange(e){      console.time('loadTime')      console.time('endTime')       const file = e.target.files[e.target.files.length-1];       const {name} = file       console.log(file)       console.log('fileSize', file.size /1024 /1024)       if(!ffmpeg.isLoaded()) {         await ffmpeg.load();       }       console.timeEnd('loadTime')      ffmpeg.FS('writeFile', name, await fetchFile(file));      //       await ffmpeg.run('-i', name, '-preset','ultrafast','-b:v', '1048576','-fs','10240','-vf', 'format=pix_fmts=yuv420p,fps=25,scale=320:-16','output.mp4')     const buffer = ffmpeg.FS('readFile', 'output.mp4')     console.log(this.transformArrayBufferToBase64(buffer))        console.timeEnd('endTime')    },   transformArrayBufferToBase64 (buffer) {      var binary = '';      var bytes = new Uint8Array(buffer);      for (var len = bytes.byteLength, i = 0; i < len; i++) {          binary += String.fromCharCode(bytes[i]);      }      return window.btoa(binary);    }  }}</script><style>#app {  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;}</style></code></pre><p>​    遇到的问题是在使用的过程中还需要下载20多兆的资源，导致体验不好，当然你也可以把这些资源放到本地or自己的服务器。<a href="https://unpkg.com/@ffmpeg/core@0.9.0/dist/" target="_blank" rel="noopener">依赖资源</a></p><h3 id="Vue代理"><a href="#Vue代理" class="headerlink" title="Vue代理"></a>Vue代理</h3><p>​        开发使用的Vue版本是2.6.11，需要代理的话，需要在<code>vue.config.js</code>里面配置：</p><pre class=" language-javascript"><code class="language-javascript"> configureWebpack<span class="token punctuation">:</span> <span class="token punctuation">{</span>    devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>      proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'/apis'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将www.example.com映射为/apis</span>          target<span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 接口域名</span>          secure<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 如果是https接口，需要配置这个参数</span>          changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 是否跨域</span>          pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">'^/apis'</span><span class="token punctuation">:</span> <span class="token string">''</span>   <span class="token comment" spellcheck="true">// 需要rewrite的,</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>​    后面就直接用<code>/apis</code>就可以直接代替<code>target</code></p><h3 id="流水线处理"><a href="#流水线处理" class="headerlink" title="流水线处理"></a>流水线处理</h3><p>​    用户的认证分为好几个步骤，每个步骤里面还包含子步骤，每个子步骤之间还可以相互跳转，用户可以从上次中断步骤开始操作，我可以从接口获取用户当前操作步骤以及整个需要经历的步骤，最开始我是想通过接口返回给我的参数把完整的流水线算出来，但是步骤间的相互跳转不好处理，然后想到我只算出<strong>主流水线</strong>，其他的<strong>细支小流</strong>我不处理，细支小流的处理放到每个主流水线的步骤中处理。</p><p><img src="https://i.loli.net/2021/05/10/McuGRfl5FkxNB6Z.png" alt=""></p><h3 id="代码健壮性"><a href="#代码健壮性" class="headerlink" title="代码健壮性"></a>代码健壮性</h3><p>​    这次写项目中，对于异常操作的处理不好，下次需要加强。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>​    有一个功能是通过Iframe（一个对话框）嵌入到系统的，有一个功能点需要用到接口轮询查询状态，但是用户直接关闭弹框的话，轮询还是会一直存在的，对于一个有着代码洁癖的我来说，肯定是不可以接受的，于是想到通过发布订阅模式来解决这个问题。对于轮询的操作发布一个取消轮询的时间，对于那些无操作的操作订阅这个事件，这样就解决了这个问题，在Vue中需要将这些事件挂载到同一个对象中， 。</p><p><img src="https://i.loli.net/2021/05/10/VthXJoZRvajcNyg.png" alt=""></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>​        需求需要需要写一个toast提示，但是最初的一版，存在一个问题，如果提示过于频繁会叠加在一起，就像下面的效果</p><p><img src="https://i.loli.net/2021/05/10/IJ35XQVwirWn8Uu.png" alt=""></p><p>​    于是我动用我灵泛的大脑<del>各种搜索</del>，用单例模式解决了这个问题，下图是演示效果 ：</p><p><img src="https://i.loli.net/2021/05/08/XgNa6PwTM19x4io.gif" alt=""></p><p>贴心的我已经我大家准备好了<a href="https://www.npmjs.com/package/m-toast-vue" target="_blank" rel="noopener">NPM包</a>，一起欢快的使用吧！</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h3><p>​    这次写代码自我感觉技术上提升了，但是对于数据与视图之间的关系把握不好，组件之间的<code>高聚合 低耦合</code>处理不太好，设计模式需要加强练习。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>​    用户之前的操作会保存一些信息下来，以备后续的操作，但是在项目中，所有的基础信息全部放到一个接口中返回，个人认为不太友好，最好是按模块、按功能返回这些信息。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>​    正则表达式：需要加强学习，现在基本上不会写正则，全靠搜索引擎。</p><h2 id="这次使用的脚手架"><a href="#这次使用的脚手架" class="headerlink" title="这次使用的脚手架"></a>这次使用的脚手架</h2><p>​        <a href="https://github.com/muyeyong/Vue2.xCLI">好用的话点了小星星</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微前端-Vue实践</title>
      <link href="/2021/02/20/wei-qian-duan-vue-shi-jian/"/>
      <url>/2021/02/20/wei-qian-duan-vue-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="微前端-Vue3-0实践"><a href="#微前端-Vue3-0实践" class="headerlink" title="微前端-Vue3.0实践"></a>微前端-Vue3.0实践</h1><h2 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h2><p>微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用，核心在于拆，拆完在合。</p><h2 id="为什么使用微前端"><a href="#为什么使用微前端" class="headerlink" title="为什么使用微前端"></a>为什么使用微前端</h2><ol><li>忽略技术栈区别</li><li>子应用可以单独打包部署</li><li>可以兼容老代码</li></ol><h2 id="怎么落地"><a href="#怎么落地" class="headerlink" title="怎么落地"></a>怎么落地</h2><h3 id="Single-Spa实现"><a href="#Single-Spa实现" class="headerlink" title="Single-Spa实现"></a>Single-Spa实现</h3><p><a href="https://github.com/single-spa/single-spa">Single-SPA</a>是一个用于前端微服务化的JavaScript前端解决方案（没有处理样式隔离、js隔离）实现了路由劫持和应用加载。</p><p>先上一张图，这是基于Single-Spa实现的效果：</p><p><img src="https://i.loli.net/2021/02/22/kyoO9SzKu4XmEvY.gif" alt=""></p><ol><li>创建两个vue工程（我是通过vue cli创建的）</li></ol><pre><code>vue create parent-app // 创建父应用vue create child-app // 创建子应用两个工程自定义只选择了 bable 和 vueRouter</code></pre><ol start="2"><li><p>改造子应用</p><pre><code>子应用需要暴露出 bootstrap mount unmount 方法</code></pre><ul><li>子应用安装<code>single-spa-vue</code>：<code>npm insatll sigle-spa-vue</code>，在<code>main.js</code>里面引入<code>single-spa-vue</code>，singleSpa会重新包装Vue，返回的对象包含子应用需要导出的三个方法。</li></ul><p><img src="https://i.loli.net/2021/02/22/IOZ4acA5CqdbhTB.png" alt=""></p><ul><li>新建<code>vue.config.js</code>文件，output设置是将打包输出成umd格式，被父应用引用，deveServer设置了启动的端口号</li></ul><p><img src="https://i.loli.net/2021/02/22/ctSJGdmxWYqOnLA.png" alt=""></p></li><li><p>改造父应用</p><ul><li><p>父应用安装<code>single-spa</code>：<code>npm install single-spa</code>，父应用需要注册并挂载子应用。</p><p><img src="https://i.loli.net/2021/02/22/BWaeHyJKj5pxQ7w.png" alt=""></p><p>引入<code>single-spa</code>，<code>registerApplication</code> 是注册子应用，第一个参数是子应用的名字，第二个参数是一个方法，主要是加载子应用打包出来的结果，注意加载的顺序先加载公共模块，在加载app.js，不然就会出现下面的报错。返回值包含了子应用导出的三个方法。</p><p><img src="https://i.loli.net/2021/02/22/38FmfO5uAadIMgr.png" alt=""></p><p>第三个参数是触发加载子应用的条件：当路由匹配到开头是<code>subapp</code>就加载子应用。当然可以传入自定义参数，具体参考<a href="https://single-spa.js.org/docs/api" target="_blank" rel="noopener">这个网址</a>。</p><p>start方法是加载注册的子应用。</p><ul><li>App.vue 需要提供子应用的挂载点，<code>id</code>跟子应用<code>appOptions</code>的<code>el</code>属性相对应。</li></ul></li></ul><p><img src="https://i.loli.net/2021/02/22/34GgFc8CKMLvtZ7.png" alt=""></p><p>到这里基本上就可以跑起来了，但还是会遇到一些问题：子应用的路由点击不了 和 子路由中的图片也显示不了。</p><p><img src="https://i.loli.net/2021/02/22/FvcWQtTYG9gOB4C.gif" alt=""></p></li><li><p>细节修正</p><p>上面的问题是应为子应用路由跳转没有基于自身跳转以及请求资源的路径不对（图片显示不出来）</p><p>在子应用的路由配置中加入base选项，解决的是路由跳转的问题</p><p><img src="https://i.loli.net/2021/02/22/GpNt4dWmxsuIz7X.png" alt=""></p><p><code>main.js</code>中加入如下判断，如果被主应用引用的话，资源请求路径以配置的为主</p><p><img src="https://i.loli.net/2021/02/22/8kgpKJVTicvDb79.png" alt=""></p><p>这样的话基于<code>Single-Spa</code>的微前端应用已经实现了</p></li></ol><h3 id="Single-Spa-缺陷"><a href="#Single-Spa-缺陷" class="headerlink" title="Single-Spa 缺陷"></a>Single-Spa 缺陷</h3><p>基于single-spa实现的微前端还存在几个问题，样式隔离以及js隔离。在上面的动图演示中，当加载子应用的时候，父应用的样式就被影响了。共用全局对象(window)就造成了全局对象的污染，接下来就针对这两点解决问题。</p><h4 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h4><ul><li>BEM（Block Element Modifier）约定项目前缀（约定仅仅是约定而已）</li><li>CSS-Modules 打包时生成不冲突的选择器名</li><li>Shadow DOM 真正意义的隔离</li><li>Css-in-js</li></ul><p>上面这这几种方法都可以解决样式不隔离的问题，以<code>Shadow DOM</code>为例：</p><p>上图：</p><p><img src="https://i.loli.net/2021/02/22/uaKw6keZOo8Frxn.png" alt=""></p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>样式隔离<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>我是P标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shadow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">let</span> shadowDOM <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'shadow'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>mode<span class="token punctuation">:</span><span class="token string">'closed'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> pEle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> shadowStyles <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'style'</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> commonStyles <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'style'</span><span class="token punctuation">)</span>        shadowStyles<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'p{color:red}'</span>        commonStyles<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'p{color:green}'</span>        pEle<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'我是shadow P'</span>        shadowDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>pEle<span class="token punctuation">)</span>        shadowDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>shadowStyles<span class="token punctuation">)</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>commonStyles<span class="token punctuation">)</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>Shadow API是dom对象自带的，shadow里面的元素外界不能访问</p><h4 id="Js隔离"><a href="#Js隔离" class="headerlink" title="Js隔离"></a>Js隔离</h4><p>沙箱： 快照沙箱（单应用沙箱，浅拷贝） 代理沙箱（多应用沙箱，es6 proxy）</p><p>沙箱目的是为了实现逻辑上的隔离，一个应用的逻辑变化不会影响其他应用</p><h5 id="单应用"><a href="#单应用" class="headerlink" title="单应用"></a>单应用</h5><p>只有一个应用实例可以使用浅拷贝将快照记录下来</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>js沙箱隔离<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>        <span class="token keyword">class</span> <span class="token class-name">SnapshotSandbox</span><span class="token punctuation">{</span>            <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>proxy <span class="token operator">=</span> window                <span class="token keyword">this</span><span class="token punctuation">.</span>modifyProps <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 记录变化量</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>snapshot <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> prop <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>snapshot<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> window<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>                <span class="token punctuation">}</span>                Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>modifyProps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    window<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>modifyProps<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token function">inactive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> prop <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>snapshot<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">!==</span> window<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>modifyProps<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> window<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>                        window<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>snapshot<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 确保不会影响</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">let</span> sandbox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SnapshotSandbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">function</span> <span class="token function">start</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">{</span>            window<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>window<span class="token punctuation">.</span>b<span class="token punctuation">)</span>            sandbox<span class="token punctuation">.</span><span class="token function">inactive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>window<span class="token punctuation">.</span>b<span class="token punctuation">)</span>            sandbox<span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>window<span class="token punctuation">.</span>b<span class="token punctuation">)</span>        <span class="token punctuation">}</span>       <span class="token function">start</span><span class="token punctuation">(</span>sandbox<span class="token punctuation">.</span>proxy<span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p><img src="https://i.loli.net/2021/02/22/GfgM3WiuV29CF7w.png" alt=""></p><h5 id="多应用"><a href="#多应用" class="headerlink" title="多应用"></a>多应用</h5><p>存在多个应用实例的话，可以借助<code>es6 proxy</code>实现js隔离</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>多应用JS隔离<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>        <span class="token keyword">class</span> <span class="token class-name">ProxySandbox</span><span class="token punctuation">{</span>            <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">const</span> rawWindow <span class="token operator">=</span> window                <span class="token keyword">const</span> fakeWindow <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>fakeWindow<span class="token punctuation">,</span><span class="token punctuation">{</span>                    <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> p <span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>                        target<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> value                        <span class="token keyword">return</span> <span class="token boolean">true</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">return</span> target<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">||</span> rawWindow<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>proxy <span class="token operator">=</span> proxy            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">let</span> sandbox1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxySandbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> sandbox2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxySandbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        window<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">function</span> <span class="token function">start</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>            window<span class="token punctuation">.</span>a <span class="token operator">=</span> value            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span>        <span class="token punctuation">}</span>     <span class="token function">start</span><span class="token punctuation">(</span>sandbox1<span class="token punctuation">.</span>proxy<span class="token punctuation">,</span><span class="token string">'hello sandbox1'</span><span class="token punctuation">)</span>    <span class="token function">start</span><span class="token punctuation">(</span>sandbox2<span class="token punctuation">.</span>proxy<span class="token punctuation">,</span><span class="token string">'hello sandbox2'</span><span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p><img src="https://i.loli.net/2021/02/22/U4Ype1XmfLbPH9r.png" alt=""></p><p>Bingo……</p><h3 id="QianKun实现"><a href="#QianKun实现" class="headerlink" title="QianKun实现"></a>QianKun实现</h3><p><a href="https://github.com/umijs/qiankun">qiankun</a>基于Single-SPA，提供了开箱即用的API（single-spa    +    sandbox    +    import-html-entry）做到的，技术栈无关，接入简单（像iframe）。</p><p><img src="https://i.loli.net/2021/02/22/b5rGPsCj8cUyhY6.gif" alt=""></p><p>上图效果是基于qinakun2.0^ + vue3.0^ + antd-vue + mockJs + TS等技术实现的，一个主应用+ 两个子应用（我的代码和生活快照），当然两个子应用也可以独立运行。主要从以下几个方面分享：</p><ul><li>主、子应用的构建</li><li>应用间的通信</li><li>mock数据</li><li>根据环境（local、develop、 product）的不同动态mock数据</li><li>权限控制</li></ul><h4 id="构建主、子应用"><a href="#构建主、子应用" class="headerlink" title="构建主、子应用"></a>构建主、子应用</h4><p><img src="https://i.loli.net/2021/02/22/DqzetjEHX1QBVdZ.png" alt=""></p><p>​                                                                                                            结构</p><h5 id="构建主应用"><a href="#构建主应用" class="headerlink" title="构建主应用"></a>构建主应用</h5><p>main.ts</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp<span class="token punctuation">,</span> h <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> registerMicroApps<span class="token punctuation">,</span> runAfterFirstMounted<span class="token punctuation">,</span> setDefaultMountApp<span class="token punctuation">,</span> start <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'qiankun'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> message <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'ant-design-vue'</span><span class="token keyword">import</span> actions <span class="token keyword">from</span> <span class="token string">'./shared/actions'</span><span class="token keyword">import</span> loadBaseUiComponent <span class="token keyword">from</span> <span class="token string">'./plugins/antd'</span><span class="token keyword">import</span> loadOneUiComponent <span class="token keyword">from</span> <span class="token string">'./library/ui/install'</span><span class="token keyword">import</span> OneUi <span class="token keyword">from</span> <span class="token string">'./library/ui'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token keyword">let</span> app<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> msg <span class="token operator">=</span> <span class="token punctuation">{</span>     data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    uiComponent<span class="token punctuation">:</span> OneUi<span class="token punctuation">,</span>    actions<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">{</span> appContent<span class="token punctuation">,</span> loading <span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> appContent<span class="token operator">?</span><span class="token punctuation">:</span> any<span class="token punctuation">;</span> loading<span class="token operator">?</span><span class="token punctuation">:</span> any <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>app<span class="token punctuation">)</span> <span class="token punctuation">{</span>        app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span>                    content<span class="token punctuation">:</span> appContent<span class="token punctuation">,</span>                    loading<span class="token punctuation">,</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">,</span> <span class="token punctuation">{</span>                    props<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        content<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">,</span>                        loading<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loading<span class="token punctuation">,</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        app<span class="token punctuation">.</span>content <span class="token operator">=</span> appContent        app<span class="token punctuation">.</span>loading <span class="token operator">=</span> loading    <span class="token punctuation">}</span>    app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>    <span class="token function">loadBaseUiComponent</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>    <span class="token function">loadOneUiComponent</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>    app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#contain'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">getActiveRule</span><span class="token punctuation">(</span>routerPrefix<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>location<span class="token punctuation">:</span> <span class="token punctuation">{</span> pathname<span class="token punctuation">:</span> string <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> location<span class="token punctuation">.</span>pathname<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>routerPrefix<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">registerMicroApps</span><span class="token punctuation">(</span>  <span class="token comment" spellcheck="true">//注册子应用</span>    <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'sub-app-code'</span><span class="token punctuation">,</span>            entry<span class="token punctuation">:</span> <span class="token string">'//localhost:8895'</span><span class="token punctuation">,</span>            container<span class="token punctuation">:</span> <span class="token string">'#sub-app-view'</span><span class="token punctuation">,</span>             activeRule<span class="token punctuation">:</span> <span class="token function">getActiveRule</span><span class="token punctuation">(</span><span class="token string">'/code'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 激活子应用的条件</span>            props<span class="token punctuation">:</span> msg<span class="token punctuation">,</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'sub-app-life'</span><span class="token punctuation">,</span>            entry<span class="token punctuation">:</span> <span class="token string">'//localhost:8099'</span><span class="token punctuation">,</span>            container<span class="token punctuation">:</span> <span class="token string">'#sub-app-view'</span><span class="token punctuation">,</span>            activeRule<span class="token punctuation">:</span> <span class="token function">getActiveRule</span><span class="token punctuation">(</span><span class="token string">'/life'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            props<span class="token punctuation">:</span> msg<span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        beforeLoad<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">(</span>currentApp<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'before load'</span><span class="token punctuation">,</span> currentApp<span class="token punctuation">)</span>                <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 挂载前回调</span>        beforeMount<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">(</span>currentApp<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'before mount'</span><span class="token punctuation">,</span> currentApp<span class="token punctuation">)</span>                <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 挂载后回调</span>        afterUnmount<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">(</span>currentApp<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after unload'</span><span class="token punctuation">,</span> currentApp<span class="token punctuation">)</span>                <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token function">setDefaultMountApp</span><span class="token punctuation">(</span><span class="token string">'/code'</span><span class="token punctuation">)</span><span class="token function">runAfterFirstMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>App.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sub-app-view<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sub-app-view<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span> //提供挂载点</code></pre><p>相对于<code>single-spa</code>实现中构建主应用，<code>qiankun</code>可以动态的获取子应用打包的结果</p><h5 id="构建子应用"><a href="#构建子应用" class="headerlink" title="构建子应用"></a>构建子应用</h5><p>main.ts</p><p>导出三大金刚<code>bootstrap mount unmount</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/* eslint-disable no-underscore-dangle */</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> loadBaseUiComponent <span class="token keyword">from</span> <span class="token string">'./plugins/antd'</span><span class="token keyword">import</span> loadOneUiComponent <span class="token keyword">from</span> <span class="token string">'./library/ui/install'</span><span class="token keyword">import</span> <span class="token string">'./utils/micro/public-path'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token keyword">import</span> actions <span class="token keyword">from</span> <span class="token string">'./shared/actions'</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token keyword">let</span> instance<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bootstrap</span><span class="token punctuation">(</span>props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span>props<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>    instance <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>    <span class="token function">loadBaseUiComponent</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>    <span class="token function">loadOneUiComponent</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>    instance<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#sub-app-code'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    instance<span class="token punctuation">.</span>$destroy<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// eslint-disable-next-line no-unused-expressions</span>window<span class="token punctuation">.</span>__POWERED_BY_QIANKUN__ <span class="token operator">||</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>vue.config.js</p><p>与<code>single-spa</code>构建不同的是这里需要对跨域进行设置</p><pre class=" language-javascript"><code class="language-javascript"> devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// host: '0.0.0.0',</span>    hot<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    disableHostCheck<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    port<span class="token punctuation">,</span>    overlay<span class="token punctuation">:</span> <span class="token punctuation">{</span>      warnings<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>      errors<span class="token punctuation">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">:</span> <span class="token string">'*'</span>   <span class="token comment" spellcheck="true">//跨域设置</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>   configureWebpack<span class="token punctuation">:</span> <span class="token punctuation">{</span>    devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>      open<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 把子应用打包成 umd 库格式</span>      library<span class="token punctuation">:</span> <span class="token string">'sub-app-code'</span><span class="token punctuation">,</span>      libraryTarget<span class="token punctuation">:</span> <span class="token string">'umd'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>router的配置也要根据是否在qiankun环境里面动态设置</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    history<span class="token punctuation">:</span> <span class="token function">createWebHistory</span><span class="token punctuation">(</span>__qiankun__ <span class="token operator">?</span> <span class="token string">'/code'</span> <span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// todo /code 需要主应用下发</span>    routes<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>single-spa</code>构建子应用对<code>__webpack_public_path__</code>进行设置，在<code>qiankun</code>中也要进行设置，抽离到了<code>utils/micro/public-path.js</code>下</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/* eslint-disable camelcase */</span><span class="token comment" spellcheck="true">/* eslint-disable no-underscore-dangle */</span><span class="token comment" spellcheck="true">// eslint-disable-next-line no-underscore-dangle</span><span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>__POWERED_BY_QIANKUN__<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// window.__POWERED_BY_QIANKUN__ 是否是qiankun环境的标志</span>  <span class="token comment" spellcheck="true">// eslint-disable-next-line no-undef</span>  __webpack_public_path__ <span class="token operator">=</span> window<span class="token punctuation">.</span>__INJECTED_PUBLIC_PATH_BY_QIANKUN__<span class="token punctuation">}</span></code></pre><p>这样一个基于<code>qiankun</code>的微前端应用就构建完成了</p><h4 id="应用间通讯"><a href="#应用间通讯" class="headerlink" title="应用间通讯"></a>应用间通讯</h4><p>我使用官方提供的<code>actions通信</code>，<code>qiankun</code> 内部提供了 <code>initGlobalState</code> 方法用于注册 <code>MicroAppStateActions</code> 实例用于通信，该实例有三个方法，分别是：</p><ul><li><code>setGlobalState</code>：设置 <code>globalState</code> - 设置新的值时，内部将执行 <code>浅检查</code>，如果检查到 <code>globalState</code> 发生改变则触发通知，通知到所有的 <code>观察者</code> 函数。</li><li><code>onGlobalStateChange</code>：注册 <code>观察者</code> 函数 - 响应 <code>globalState</code> 变化，在 <code>globalState</code> 发生改变时触发该 <code>观察者</code> 函数。</li><li><code>offGlobalStateChange</code>：取消 <code>观察者</code> 函数 - 该实例不再响应 <code>globalState</code> 变化。</li></ul><p>效果就是<code>globalState</code>变化后，会有提示框出现</p><p><img src="https://i.loli.net/2021/02/22/KeXjSfb9LQUREh8.png" alt=""></p><ol><li><p>创建actions实例（主应用里面操作）</p><p><code>shared/actions.ts</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> initGlobalState<span class="token punctuation">,</span> MicroAppStateActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'qiankun'</span><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">const</span> actions<span class="token punctuation">:</span> MicroAppStateActions <span class="token operator">=</span> <span class="token function">initGlobalState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> actions</code></pre></li><li><p>观察globalState变化</p><p><code>main.ts</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">{</span> appContent<span class="token punctuation">,</span> loading <span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> appContent<span class="token operator">?</span><span class="token punctuation">:</span> any<span class="token punctuation">;</span> loading<span class="token operator">?</span><span class="token punctuation">:</span> any <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>   <span class="token operator">...</span>    actions<span class="token punctuation">.</span><span class="token function">onGlobalStateChange</span><span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> preState<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token string">'old'</span><span class="token punctuation">,</span> preState<span class="token punctuation">)</span>        message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`新消息提醒：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>state<span class="token punctuation">.</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当globalState变化会有提示框出现</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre></li><li><p>下发actions</p><p>目前只有主应用使用了<code>actions</code>，通信的话肯定不能一个人solo，我们需要将<code>actions</code>下发发到子应用，也很简单在需要在传递给子应用的props多传一个参数即可</p><p><code>main.ts</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> msg <span class="token operator">=</span> <span class="token punctuation">{</span>    data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    uiComponent<span class="token punctuation">:</span> OneUi<span class="token punctuation">,</span>    actions<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//actions 实例</span><span class="token punctuation">}</span><span class="token function">registerMicroApps</span><span class="token punctuation">(</span>    <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'sub-app-code'</span><span class="token punctuation">,</span>            entry<span class="token punctuation">:</span> <span class="token string">'//localhost:8895'</span><span class="token punctuation">,</span>            container<span class="token punctuation">:</span> <span class="token string">'#sub-app-view'</span><span class="token punctuation">,</span>            activeRule<span class="token punctuation">:</span> <span class="token function">getActiveRule</span><span class="token punctuation">(</span><span class="token string">'/code'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            props<span class="token punctuation">:</span> msg<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//下传给子应用</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'sub-app-life'</span><span class="token punctuation">,</span>            entry<span class="token punctuation">:</span> <span class="token string">'//localhost:8099'</span><span class="token punctuation">,</span>            container<span class="token punctuation">:</span> <span class="token string">'#sub-app-view'</span><span class="token punctuation">,</span>            activeRule<span class="token punctuation">:</span> <span class="token function">getActiveRule</span><span class="token punctuation">(</span><span class="token string">'/life'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            props<span class="token punctuation">:</span> msg<span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token operator">...</span><span class="token punctuation">)</span></code></pre><p>需要注意的是，在子应用里面需要构建<code>actions类</code>，接收主应用传来的<code>actions</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Actions</span> <span class="token punctuation">{</span>    actions <span class="token operator">=</span> <span class="token punctuation">{</span>        onGlobalStateChange<span class="token punctuation">:</span> <span class="token punctuation">(</span>args<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> args<span class="token punctuation">,</span>        setGlobalState<span class="token punctuation">:</span> <span class="token punctuation">(</span>args<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> args<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 设置 actions     */</span>    <span class="token comment" spellcheck="true">// eslint-disable-next-line no-unused-vars</span>    <span class="token function">setActions</span><span class="token punctuation">(</span>actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> onGlobalStateChange<span class="token punctuation">:</span> <span class="token punctuation">(</span>args<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> any<span class="token punctuation">;</span> setGlobalState<span class="token punctuation">:</span> <span class="token punctuation">(</span>args<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> any <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>actions <span class="token operator">=</span> actions    <span class="token punctuation">}</span></code></pre></li></ol><pre><code>   onGlobalStateChange(args: any) {       return this.actions.onGlobalStateChange({ ...args })   }   setGlobalState(args: any) {       return this.actions.setGlobalState({ ...args })   }</code></pre><p>   }</p><p>   const actions = new Actions()<br>   export default actions</p><pre><code>   子应用的 `main.ts`  mount方法调用   ```javascript   export async function mount(props: any) {       if (props.actions) {           actions.setActions(props.actions)           actions.setGlobalState({ message: 'BBB' })       }      ...   }</code></pre><p>   Bingo…</p><h4 id="mock数据和根据不同环境对请求拦截"><a href="#mock数据和根据不同环境对请求拦截" class="headerlink" title="mock数据和根据不同环境对请求拦截"></a>mock数据和根据不同环境对请求拦截</h4><p>   使用的是<code>mockjs</code>。根目录下创建这三个文件就可以设置不同环境的标志</p><p>   <img src="https://i.loli.net/2021/02/22/CHryLN2ou65x143.png" alt=""></p><p>   例如： .env.dev-local</p><pre><code>   VUE_APP_CURRENTMODE = 'dev-local'   VUE_APP_ENV = '本地开发环境'   VUE_APP_MOCK = true</code></pre><p>   当然还需要设置一下 npm script，例如我想运行本地环境命令就是 ： <code>npm run dev-local</code>，它会读取<code>.env.dev-local</code>里面的值加入到全局环境变量里面去。</p><pre class=" language-json"><code class="language-json">    <span class="token property">"dev-local"</span><span class="token operator">:</span> <span class="token string">"vue-cli-service serve --mode dev-local"</span><span class="token punctuation">,</span>   <span class="token property">"dev-remote"</span><span class="token operator">:</span> <span class="token string">"vue-cli-service serve --mode dev-remote"</span><span class="token punctuation">,</span></code></pre><p>   然后就可以根据你想要的环境动态开启mock了，我是这样做的，在<code>main.ts</code>里面调用<code>useMock()</code></p><pre class=" language-javascript"><code class="language-javascript">   <span class="token keyword">function</span> <span class="token function">useMock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'process.env'</span><span class="token punctuation">,</span> process<span class="token punctuation">.</span>env<span class="token punctuation">)</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>VUE_APP_MOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// eslint-disable-next-line global-require</span>           <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../mock'</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>   可以统一在主应用请求路由权限，然后下发到子应用去，就可以做到权限控制了。</p><p>   <del>我没写</del></p><pre><code>总结：子应用可以单独构建，运行时动态加载。主、子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出bootstrap、mount、unmount方法）</code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><h3 id="为什么不使用iframe"><a href="#为什么不使用iframe" class="headerlink" title="为什么不使用iframe"></a>为什么不使用iframe</h3><p>用户刷新页面会丢失当前状态</p><p>源码：  <a href="https://github.com/muyeyong/micro-qiankun">qiankun版本</a>      <a href="https://github.com/muyeyong/micro-singleSpa">single-spa</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 微前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码优化-无限循环列表</title>
      <link href="/2021/01/12/dai-ma-you-hua-wu-xian-xun-huan-lie-biao/"/>
      <url>/2021/01/12/dai-ma-you-hua-wu-xian-xun-huan-lie-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="无限循环列表Vue实现"><a href="#无限循环列表Vue实现" class="headerlink" title="无限循环列表Vue实现"></a>无限循环列表Vue实现</h1><p>为了实现上次的承诺<a href="/2020/05/18/jing-yan-kai-fa-zong-jie/" title="点开这里">点开这里</a>，我分装了一个组件，主要的功能是：</p><ol><li>自动滚动</li><li>无限循环</li><li>不断请求数据</li></ol><p>系统里面有类似的组件（基于happy-scroll实现），但是除了不太好用之外，功能上没有实现无限循环以及只能展示固定的数据。</p><p><a href="http://meyeyong.top/#/autoScrollList" target="_blank" rel="noopener">演示地址</a>，这个演示只能实现单向滚动，跟我要实现的不太一样，不过莫急，看👇</p><p><img src="https://i.loli.net/2021/01/12/CiQVAFOmncoXa57.gif" alt=""></p><p>好像不是很直观，可以看右边的滚动条，到了顶部和底部会自动加载数据数据，滑到顶部会自动滚动到请求数据的第一条数据，看下图</p><p><img src="https://i.loli.net/2021/01/12/VM74hy6wjckId2i.gif" alt=""></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="https://i.loli.net/2021/01/12/YmDXGanglLoe5jt.png" alt=""></p><p>组件名：esay-auto-scroll-list</p><p>属性：</p><table><thead><tr><th>属性</th><th></th></tr></thead><tbody><tr><td>width</td><td>设置组件的宽</td></tr><tr><td>height</td><td>设置组件的高</td></tr><tr><td>haveData</td><td>状态，是否有数据</td></tr><tr><td>loading</td><td>状态，是否在加载数据（请求数据是否返回）</td></tr><tr><td>flag</td><td>每个ul的唯一标志，ul必须增加data-flag的自定义标签</td></tr><tr><td>notice</td><td>当滚到底/顶部的回调函数</td></tr></tbody></table><p><strong>注意点</strong></p><ol><li>组件只是实现数据的滚动，以及滚动到边界（顶/底）调用回调函数，具体要实现无限上下滚动 or 单向有限滚动 or 其他，需要回调函数的配合（在线实例和博客动图就是回调函数的不同，效果就不一样）</li><li>haveData和loading是根据实际返回数据设置的。在发送请求前，havaData=false loading=true。请求结束后，haveData根据实际情况设置，loading=false</li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><a href="https://github.com/muyeyong/eleAnimation/tree/master/src/components/autoScrollList">组件源码</a>，注意也要使用config.js配置文件，在项目总请使用 autoScrollList实际使用版本.vue</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="clientHeight"><a href="#clientHeight" class="headerlink" title="clientHeight"></a>clientHeight</h4><blockquote><p>跟元素的滚动和位置无关，代表元素的高度，包括padding但不包括border、水平滚动条、margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读属性</p></blockquote><p><img src="https://i.loli.net/2021/01/12/zsxjP1mvtH2deqI.png" alt=""></p><h4 id="offsetHeight"><a href="#offsetHeight" class="headerlink" title="offsetHeight"></a>offsetHeight</h4><blockquote><p>跟元素的滚动和位置无关，代表元素的高度，包括padding、border、水平滚动条，但不包括margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读属性</p></blockquote><p><img src="https://i.loli.net/2021/01/12/JbRHgh2jAYTUSf9.png" alt=""></p><h4 id="scrollHeight"><a href="#scrollHeight" class="headerlink" title="scrollHeight"></a>scrollHeight</h4><blockquote><p>跟滚动条有关（子元素高于父元素），代表当前不可见部分的高度，可见部分就是clientHeight，单位px，只读属性</p></blockquote><p><img src="https://i.loli.net/2021/01/12/1MeUT4qCDPvnRlL.png" alt=""></p><p><strong>判断是否滑到底部： ele.scrollHeight - ele.scrollTop ==== ele.clientHeight</strong></p><h4 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h4><blockquote><p>代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时<code>scrollTop==0</code>恒成立。单位px，可读可写属性</p></blockquote><p><img src="https://i.loli.net/2021/01/12/4d7tY8A6FbTZjsq.png" alt=""></p><h4 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h4><blockquote><p>它返回当前元素相对于其 offsetParent 元素的顶部的距离（子边框外侧到父边框的内存的距离）,单位px，只读属性</p></blockquote><h4 id="clientTop"><a href="#clientTop" class="headerlink" title="clientTop"></a>clientTop</h4><blockquote><p>一个元素顶部边框的宽度，不包括顶部外边距或内边距。可以理解成定义<code>border</code>的高度，单位px，只读属性</p></blockquote><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>上滑顶部：当发出请求前（调用回调函数前），保存当前列表中的第一条数据以及scrollTop和offetHeight。当请求结束后，更新完数据，将保存的数据插入到最新数据的后面，并更新scrollTop保持视觉上的连续性。</p><p>下滑到底部：当发出请求前（调用回调函数前），保存当前列表最后一条数据以及scrollTop和offetHeight。当请求结束后，更新完数据，将保存的数据插入到最新数据的前面，并更新scrollTop保持视觉上的连续性。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>保存的的offsetHeight是多个子元素的offsetHeight的集合</li><li>使用<code>insertBefore</code>插入的元素，在下一次更新数据时，可能还会保存，需要去除多余的子元素（唯一标志flag的作用）</li><li>最后一组数据比较特殊，数量可能没有最开始请求那么多。例如设置的请求数量是10条，但最后一组数据可能只有1条，需要特殊处理。</li></ol><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是实现需要效果的关键，就是看你怎么处理边界位置的情况，下面是我的实例：</p><pre><code>async  loadData(type){            this.loading = true            this.moreData = false             this.flag++            let page             if(type === scrollDir.down){             if(this.endPage === this.totalPage){                 this.endPage = 1                 this.startPage = this.totalPage             }else{                const newStartPage = (this.startPage+1)%this.totalPage                const newEndPage = (this.endPage+1)%this.totalPage                this.endPage = newEndPage===0? this.totalPage: newEndPage                this.startPage = this.endPage%this.totalPage - 1&gt;0? this.endPage%this.totalPage - 1: this.totalPage             }             page = this.endPage           }else if(type === scrollDir.up){               if(this.startPage&lt;=1){                   this.startPage = this.totalPage                   this.endPage = 1               }else{                   const newStartPage = this.startPage-1                   const newEndPage = this.endPage-1                   this.startPage = newStartPage&gt;0? newStartPage:1                   this.endPage = this.startPage%this.totalPage + 1               }               page = this.startPage           }            this.investProjectList = await this.getInvestProjectsData({page})            this.totalPage = this.investProjectList.pages            this.moreData = true            this.loading = false        },</code></pre><h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><ol><li>需要定义startPage 和 endPage两个变量跟踪page变化，之所以要两个变量是因为当前可视窗口可以存在多个子元素</li></ol><p><img src="https://i.loli.net/2021/01/12/LzReYxk9pgFIyUt.png" alt=""></p><ol start="2"><li>上滑endPage根据startPage变化，下滑startPage根据endPage变化</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实现这个功能用的时间太长了，写到一半的时候发现不行，又推到重来了，浪费了很多时间，会这样还是因为自己前期没有考虑仔细就开始写代码，连写什么东西都不明确，需要反思。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无限循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画效果-div扇形</title>
      <link href="/2020/12/12/dong-hua-xiao-guo-div-shan-xing/"/>
      <url>/2020/12/12/dong-hua-xiao-guo-div-shan-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="div扇形动画"><a href="#div扇形动画" class="headerlink" title="div扇形动画"></a>div扇形动画</h1><p>先上效果图</p><p><img src="https://i.loli.net/2020/12/12/8NEiPuGOtTVg2j4.gif" alt=""></p><p>这是最近实现的一个需求效果，本来打算使用Echarts做的，但是动画效果达不到要求，遂卒。然后思考🤔怎么实现，写过一版用canvas实现的，但只写到画一个饼状图 （ <del>不如用Echarts</del>）😂，在文末补充画饼状图的过程。</p><p>回到正文，上面的效果图中完整的饼状图还是用Echarts画的，但后面的圆弧是用div画的。需求需要实现的主要功能点用圆弧实现圆的循环效果，但如Echarts画的饼状图，在旋转的过程中文字会飘，所以做了隐藏的处理。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="画一个静态的圆弧"><a href="#画一个静态的圆弧" class="headerlink" title="画一个静态的圆弧"></a>画一个静态的圆弧</h3><pre><code>通过设置border-radius实现（画三角形是通过border在实现的）</code></pre><p><img src="https://i.loli.net/2020/12/12/gLquzUEjBTw9YXp.png" alt=""></p><p>这就完成了最关键的一步了，现在已经画出了一个90°的圆弧，如果你想画出特定角度的圆弧可以通过叠加 or 遮盖实现视觉上的效果。</p><h3 id="画很多圆弧"><a href="#画很多圆弧" class="headerlink" title="画很多圆弧"></a>画很多圆弧</h3><p>既然画出了一个圆弧，画很多圆弧不也很简单吗🍀，确实是的，但要考虑到最边上的圆弧，中间的圆弧可以通过相互覆盖实现在视觉上画出特定角度的圆弧（实际上我们画的都是90°的圆弧），但最边上的两个圆弧没有谁帮它覆盖，没有就去创造，在这两个圆弧旁边再画圆弧帮它遮挡就可以了。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>当点击每个圆弧的时候需要实现无限循环的效果，可圆弧又不是圆，实在有点为难它了，但只要实现视觉上的效果，管它是牛是马。例如当我们点击最上面的圆弧，需要它实现往下旋转的效果，这就话暗藏需要实现的两个功能点：</p><ul><li>要实现旋转的视觉效果</li><li>旋转完后数据显示正常</li></ul><p>对于第一点：把整个圆弧放到一个容器（div）中，直接旋转父容器就可以在视觉上实现旋转效果</p><p>对于第二点：数据显示正常也就是显示的位置、数据数量以及顺序是不能发生变化的，点击最上面的圆弧，它向下旋转N（☞离视觉的中点隔得圆弧数量）个位置，它下旋了N个位置自然它上面要出现N个圆弧，下面要减少N个圆弧，这里就需要我们提前处理数据，在圆弧在开始以及结束处补数据。开始处补的数据自然是圆弧结尾的若干数据，补几个就要看最上面的圆弧距离视觉中点的距离，结束处补数据的原理同上。</p><p><img src="https://i.loli.net/2020/12/12/VEQIO4vrT5dgih8.png" alt=""></p><p><img src="https://i.loli.net/2020/12/12/PEWqUoxs2Lp49h1.gif" alt=""></p><p>动图看起来比较直观吧，虽然只有四条数据但是实际上有八条数据，多余的数据是为了保证正确的数据显示（这里就需要可是范围内的圆弧不能超过180°），然后每次旋转后在去更新圆弧的角度（例如整体向下旋转了18°，那每段圆弧需要向上偏转18°）以及隐藏的圆弧。</p><p>看一下整体结构吧😅</p><p><img src="https://i.loli.net/2020/12/12/OmKVgREN2Hd49cy.png" alt=""></p><p>这样我们需要实现的功能基本搞定</p><h3 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h3><p>每段圆弧共用的是同一个圆心，如下图第一段圆弧（扇形）有①那么长的长度，第二段圆弧（扇形）有②那么长的长度，但视觉以及功能上要达到它仅仅是一段圆弧以及它的点击区域也仅仅有圆弧那么大。</p><p><img src="https://i.loli.net/2020/12/12/1f265wLjOUkmd7t.png" alt=""></p><p>这里我设置了他们的层级关系（z-index）从左到右层级递减，通过前一级的遮挡实现功能上以及视觉上的效果。到了这里你应该可以自己实现了吧🤗，赶紧动手吧。</p><h2 id="Canvas-饼状图"><a href="#Canvas-饼状图" class="headerlink" title="Canvas 饼状图"></a>Canvas 饼状图</h2><p>效果</p><p><img src="https://i.loli.net/2020/12/12/QwXLN214uo58HSR.png" alt=""></p><p>你以为就这，年轻人大意了吧</p><p><img src="https://i.loli.net/2020/12/12/zcrNBvkniQDVXEI.gif" alt=""></p><p>我还做了“动效”，主要步骤有三步：</p><ol><li><p>画一个整圆弧</p></li><li><p>给中间添一个空白圆</p></li><li><p>调整文字位置</p><h3 id="需要注意的-1"><a href="#需要注意的-1" class="headerlink" title="需要注意的"></a>需要注意的</h3><p>1：Canvas画圆弧的位置</p><p><img src="https://i.loli.net/2020/12/12/J4q8P6ICmtvBEQd.png" alt=""></p><p>2：Canvas 不清晰（源码有代码解决）</p><p>3：Canvas点击是点击整块区域，对于点击事件需要代码判断区域</p><pre><code>//Canvas画圆弧&lt;template&gt;  &lt;div class="chain_wrap"&gt;      &lt;div :class="['pie_wrap',rotateClass]" &gt;          &lt;canvas id="pie" ref="pie" class="pie" @click="handleClickEvent" width="260" height="260" &gt;&lt;/canvas&gt;      &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {firstChain} from './mockData'export default {    data(){        return {            ctx: null,            angleList: [],            circleX: 0,            circleY: 0,            canRotate: false,            rotateClass: null,            ratio: 1,            rotateAngle: 0,            colorList: ['#5aa0ec','#66985d','#a4983c','#97522b','#88232c','#6e2c97','#4618c2']        }    },    created(){    },    mounted(){        this.createPieCanvas()    },    methods:{        createPieCanvas(initAngle = 0){            const doughnutHoleSize = 0.2            let total = 0            firstChain.forEach(item=&gt; total+= item.count)            let angleList = []            firstChain.forEach(item=&gt;{                // let angle = Math.PI*2*(item.count/total)                let angle = Math.PI*2/ firstChain.length                angleList.push(angle)            })            this.angleList = angleList            //保证最小角度            // angleList = this.handleAngle(angleList,0.2)            let pieDom = this.$refs.pie            let ctx = pieDom.getContext('2d')            this.ctx = ctx            var ratio = this.getPixelRatio(pieDom)            this.ratio = ratio            pieDom.style.width = pieDom.width + 'px'            pieDom.style.height = pieDom.height + 'px'            pieDom.width = pieDom.width * ratio;            pieDom.height = pieDom.height * ratio;            //使canvas清晰            ctx.scale(ratio, ratio);            const h = ctx.canvas.width/ratio            const w = ctx.canvas.height/ratio            const x0 = w/2            const y0 = h/2            this.circleX = x0            this.circleY = y0            let startAngle = 0            let pieRadius = Math.min(x0,y0)            let offset = (pieRadius*doughnutHoleSize)/2            angleList.forEach((item,index)=&gt;{                var endAngle = startAngle + item                let color  = this.getColor(index)                let lableX = x0+ (offset + pieRadius/2) * Math.cos(startAngle+ item/2)                let lableY = y0+ (offset + pieRadius/2) * Math.sin(startAngle+ item/2)                this.drawPieSlice(ctx,x0,y0,pieRadius,startAngle,endAngle,color)                 this.drawPieText(ctx,lableX,lableY,firstChain[index].name,startAngle+ item/2)                /*记录当前的结束位置作为下一次的起始位置*/                startAngle = endAngle            })            //画中间的圆心            this.drawPieSlice(ctx,x0,y0,doughnutHoleSize*Math.min(x0,y0),0,2*Math.PI,"#0e1134")        },        getColor(index) {            const len = this.colorList.length            return this.colorList[index%len]        },        getPixelRatio(context) {            var backingStore = context.backingStorePixelRatio ||                context.webkitBackingStorePixelRatio ||                context.mozBackingStorePixelRatio ||                context.msBackingStorePixelRatio ||                context.oBackingStorePixelRatio ||                context.backingStorePixelRatio || 1;            return (window.devicePixelRatio || 1) / backingStore;        },        drawPieSlice(ctx,centerX, centerY, radius, startAngle, endAngle, color ){            ctx.fillStyle = color;            ctx.beginPath();            ctx.moveTo(centerX,centerY);            ctx.arc(centerX, centerY, radius, startAngle, endAngle);            ctx.closePath();            ctx.fill();        },        drawPieText(ctx,lableX,lableY,text,rotateAngle){            // console.log(text,lableX,lableY,rotateAngle)            if(rotateAngle&gt;0.5*Math.PI &amp;&amp; rotateAngle&lt; 1.5*Math.PI) rotateAngle+= Math.PI            ctx.save()            ctx.fillStyle = 'white'            ctx.font = 'bold 10px Arial'            ctx.translate(lableX,lableY)            ctx.rotate(rotateAngle)            ctx.fillText(text,0,0)            // ctx.translate(lableX,lableY)            ctx.restore()        },        handleAngle(angleList,minAngle){            //beyondTotal: 超出360度的角度和 normalTotal: 大于minAngle的角度和            let newAngleList = [],beyondTotal = 0,normalTotal = 0            angleList.forEach(item=&gt;{                if(item&lt; minAngle) beyondTotal += (minAngle - item)                else if(item &gt; minAngle) normalTotal += item            })            angleList.forEach((item,index)=&gt;{                let resultAngle = item                if(item&lt; minAngle) resultAngle = minAngle                else if(item &gt; minAngle) resultAngle =(item  - beyondTotal*(item/normalTotal))                newAngleList[index] = resultAngle            })            return newAngleList        },        handleClickEvent(e){            let offsetTop = document.querySelectorAll('.company_chart')[0].offsetTop            let offsetLeft = document.querySelectorAll('.company_chart')[0].offsetLeft            let angle = this.getClickAreaAngle(e.pageX - offsetLeft ,e.pageY - offsetTop)            //清除画布            this.ctx.clearRect(0,0,this.ctx.canvas.width/this.ratio,this.ctx.canvas.height/this.ratio)            this.rotateAngle += angle            this.refreshCanvas(this.rotateAngle)            // this.rotateClass = this.createRotateAnimation(angle)            // setTimeout(()=&gt;{this.canRotate = false},0.5)        },        refreshCanvas(initAngle){            const doughnutHoleSize = 0.2            const h = this.ctx.canvas.width/this.ratio            const w = this.ctx.canvas.height/this.ratio            const x0 = w/2            const y0 = h/2            this.circleX = x0            this.circleY = y0            let startAngle = initAngle            let pieRadius = Math.min(x0,y0)            let offset = (pieRadius*doughnutHoleSize)/2            this.angleList.forEach((item,index)=&gt;{                var endAngle = startAngle + item                let color  = this.getColor(index)                let lableX = x0+ (offset + pieRadius/2) * Math.cos(startAngle+ item/2)                let lableY = y0+ (offset + pieRadius/2) * Math.sin(startAngle+ item/2)                this.drawPieSlice(this.ctx,x0,y0,pieRadius,startAngle,endAngle,color)                 this.drawPieText(this.ctx,lableX,lableY,firstChain[index].name,startAngle+ item/2)                /*记录当前的结束位置作为下一次的起始位置*/                startAngle = endAngle            })             //画中间的圆心            this.drawPieSlice(this.ctx,x0,y0,doughnutHoleSize*Math.min(x0,y0),0,2*Math.PI,"#0e1134")        },        getClickAreaAngle(x,y){         let angle = Math.atan(Math.abs(this.circleY - y) / Math.abs(this.circleX - x) )          //根据象限求出实际的角度          //一象限 二象限 三象限 四象限          if(x &gt; this.circleX &amp;&amp; y &lt; this.circleY){              return  angle          }else if(x &gt; this.circleX &amp;&amp; y &gt; this.circleY){              return  2*Math.PI - angle           }else if (x &lt; this.circleX &amp;&amp; y &gt; this.circleY){              return Math.PI +  angle          }else if(x &lt; this.circleX &amp;&amp; y &lt; this.circleY){              return  Math.PI - angle          }        },        createRotateAnimation(angle){           let  rotateAngle = (2* Math.PI - angle) * (180/Math.PI)            const uid = Math.random().toString(36).substr(2)           const style = document.createElement('style')           style.type = 'text/css'           style.innerHTML = `.rotateClass${uid}{transform: rotate(${rotateAngle}deg)}`           document.getElementsByTagName('head')[0].appendChild(style)           return `rotateClass${uid}`        }    }}&lt;/script&gt;&lt;style lang='less' scoped&gt;    .chain_wrap{        .pie_wrap{            width: 260px;            height: 260px;            transition: all 0.5s;             .pie{            // &amp;:hover{            //     transition: all 0.5s;            //     transform: rotate(180deg);            // }        }        }    }&lt;/style&gt;</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动画效果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-Less</title>
      <link href="/2020/12/09/css-less/"/>
      <url>/2020/12/09/css-less/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预处理语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画效果-饿了么购物车动效</title>
      <link href="/2020/12/09/dong-hua-xiao-guo-e-liao-me-gou-wu-che-dong-xiao/"/>
      <url>/2020/12/09/dong-hua-xiao-guo-e-liao-me-gou-wu-che-dong-xiao/</url>
      
        <content type="html"><![CDATA[<h1 id="饿了么购物车动画实现"><a href="#饿了么购物车动画实现" class="headerlink" title="饿了么购物车动画实现"></a>饿了么购物车动画实现</h1><p>NO PICTURE SAY JB</p><p><img src="https://i.loli.net/2020/12/09/J5PikUvSjVFIMXO.gif" alt=""></p><p><a href="https://github.com/muyeyong/eleAnimation">源码自取</a></p><p><a href="http://meyeyong.top/" target="_blank" rel="noopener">演示网址，可能是其他练习🤣</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久好久没有更新博客了，最近工作确实有点忙，最近的项目总结也一直拖着没写，但是懒才是原罪😔，年轻人要努力啊😤</p><h1 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h1><ol><li>移动端布局： flex + rem + <a href="https://github.com/amfe/lib-flexible">flexible</a>(移动端貌似用视口单位更好)  + SVG</li><li>前端框架： VUE(使用了VUE脚手架，版本3+)</li><li>第三方插件：<a href="https://github.com/ustbhuangyi/better-scroll">better-scroll</a></li></ol><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="基本结构的搭建"><a href="#基本结构的搭建" class="headerlink" title="基本结构的搭建"></a>基本结构的搭建</h2><p>开发是以宽750px的屏幕为基准的，使用rem是为了适应不同尺寸的屏幕。flexible的原理是将屏幕直接分为10等份，以750的屏幕来说，每一份是75px，然后设置1rem === 75px就可以了。</p><p><strong>引入flexible</strong></p><p>​    <img src="https://i.loli.net/2020/12/09/ciI31BuHnWN8pPb.png" alt=""></p><p><strong>需要注意的地方</strong></p><p><img src="https://i.loli.net/2020/12/09/mvkNo6GEHeIzygF.png" alt=""></p><p>当屏幕宽度小于750的时候强制指定根元素的： font-size: 75px去覆盖flexible的值，rem(root rm)是根据根元素的font-size大小确定的。</p><p><strong>好用的vscode插件</strong></p><p><code>px to rem &amp; rpx</code>：自动帮你把px转化为rem，前提是需要设置好参考值：1rem对应多少px</p><p><img src="https://i.loli.net/2020/12/09/z4LsuZagtQPkBdC.png" alt=""></p><p><strong>在项目中使用SVG</strong></p><ol><li>安装插件： <code>npm install vue-svg-loader --save</code></li><li>在根目录下新建vue.config.js</li></ol><pre><code>const path = require('path')function resolve(dir) {  return path.join(__dirname, './', dir)}module.exports = {  chainWebpack: config =&gt; {    config.plugin('define').tap(args =&gt; {      const argv = process.argv      const icourt = argv[argv.indexOf('--icourt-mode') + 1]      args[0]['process.env'].MODE = `"${icourt}"`      return args    })    // svg rule loader    const svgRule = config.module.rule('svg') // 找到svg-loader    svgRule.uses.clear() // 清除已有的loader, 如果不这样做会添加在此loader之后    svgRule.exclude.add(/node_modules/) // 正则匹配排除node_modules目录    svgRule // 添加svg新的loader处理      .test(/\.svg$/)      .use('svg-sprite-loader')      .loader('svg-sprite-loader')      .options({        symbolId: 'icon-[name]',      })    // 修改images loader 添加svg处理    const imagesRule = config.module.rule('images')    imagesRule.exclude.add(resolve('src/icons')) //存储svg文件的根目录    config.module      .rule('images')      .test(/\.(png|jpe?g|gif|svg)(\?.*)?$/)  },  configureWebpack: {    devServer: {      open: true,      // https: true,      proxy: {        '/user': {          target: 'https://devadminschool.icourt.cc',        },        '/live': {          target: 'https://devadminschool.icourt.cc',        },      },    },  },}</code></pre><ol start="3"><li>新建 svgIcon.vue组件</li></ol><pre><code>&lt;template&gt;  &lt;svg :class="svgClass" aria-hidden="true"&gt;    &lt;use :xlink:href="iconName"/&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "svgIcon",  props: {    iconClass: {      type: String,      required: true,    },    className: {      type: String,      default: '',    },  },  computed: {    iconName() {      return `#icon-${this.iconClass}`    },    svgClass() {      if (this.className) {        return 'svg-icon ' + this.className      } else {        return 'svg-icon'      }    },  }}&lt;/script&gt;&lt;style scoped&gt;.svg-icon {  width: 1em;  height: 1em;  fill: currentColor;  overflow: hidden;}&lt;/style&gt;</code></pre><ol start="4"><li>src目录下新建icons文件夹</li></ol><p>这个文件夹跟第二步中的对应，如下图</p><p><img src="https://i.loli.net/2020/12/10/Q5oBgncz2Ddb6Rx.png" alt=""></p><ol start="5"><li><p>icons中新建svg文件夹（存储svg文件）和 index.js</p><pre><code>//index.js 内容import Vue from 'vue'import SvgIcon from '@/components/svgIcon' // svg组件// 注册到全局Vue.component('svg-icon', SvgIcon)const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context('./svg', false, /\.svg$/)requireAll(req)</code></pre></li><li><p>在项目中使用</p><p><img src="https://i.loli.net/2020/12/10/BLVwiFv7qxTCgZJ.png" alt=""></p></li></ol><h2 id="功能点实现"><a href="#功能点实现" class="headerlink" title="功能点实现"></a>功能点实现</h2><h3 id="滑动效果实现"><a href="#滑动效果实现" class="headerlink" title="滑动效果实现"></a>滑动效果实现</h3><p><img src="https://i.loli.net/2020/12/10/InrWoYpRbLhA2Fs.png" alt=""></p><p>滑动效果要考虑到左侧与右侧的联动，点击左侧，右侧需要调到相应位置，滑动右侧，左侧也要相应变化。</p><p>对于右侧：获取每一个大类（例如：湘菜、川菜）距离顶部的距离（offsetTop）,然后监听scroll事件，将事件的y值与每一项的offsetTop对比来联动左侧</p><p><img src="https://i.loli.net/2020/12/10/mlWV2MLGyYQz5p3.png" alt=""></p><p>对于左侧： 点击的哪一个直接将右侧的dom元素的实例上滑-offsetTop</p><p><strong>遇到的坑</strong></p><p>使用BScroll的时候，发现滑动不了： </p><p><img src="https://i.loli.net/2020/12/10/nWkuCpr9tq7ABTV.png" alt=""></p><h3 id="加入购物车效果实现"><a href="#加入购物车效果实现" class="headerlink" title="加入购物车效果实现"></a>加入购物车效果实现</h3><p>当点击＋的时候，需要实现购物车跳入的动画，通过 <a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">vue 过渡实现</a></p><p>补充：</p><ol><li>getBoundingClientRect()是DOM元素到浏览器的可视距离</li></ol><p><img src="https://i.loli.net/2020/12/10/BGOgPj6Z5YqDoks.png" alt=""></p><ol start="2"><li>通过监听 transitionend、animationend进行相应状态变化</li></ol><p>努力哦，少年！！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动画效果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-React bilibili</title>
      <link href="/2020/11/23/xiang-mu-xue-xi-react-bilibili/"/>
      <url>/2020/11/23/xiang-mu-xue-xi-react-bilibili/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS-flex布局</title>
      <link href="/2020/11/10/css-flex-bu-ju/"/>
      <url>/2020/11/10/css-flex-bu-ju/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-Vue</title>
      <link href="/2020/11/02/xiang-mu-xue-xi-vue/"/>
      <url>/2020/11/02/xiang-mu-xue-xi-vue/</url>
      
        <content type="html"><![CDATA[<ol><li><p>ul li可以相互包含<img src="%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Vue/Snipaste_2020-11-02_15-52-52.png" alt=""></p></li><li><p>组件</p><p>名字：例如组件的引入名字是： MycomponentName，在模板中: <my-component-name></my-component-name></p><p><img src="%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Vue/Snipaste_2020-11-02_15-54-45.png" alt=""></p><p>slot：对于一个通用的组件，但在每个对其引用的组件其表现形式有所不同，可以使用slot</p><p>​                    <img src="%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Vue/Snipaste_2020-11-02_15-55-41.png" alt=""></p><p>传参：<img src="%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Vue/Snipaste_2020-11-02_15-58-33.png" alt=""></p><p>动态组件：</p><p>​    使用<keep-alive></keep-alive>缓存被创建的组件，组件要有自己的名字。</p></li><li><p>插件</p><ul><li>Swiper：滑动</li><li>better-scroll：滚动</li></ul></li><li><p>代码书写风格</p><p><img src="%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Vue/Snipaste_2020-11-03_10-22-10.png" alt=""></p></li><li><p>用户体验</p><ul><li><p>数据没加载出来的过渡效果</p><p>使用transition封装</p></li></ul></li></ol><p><img src="https://i.loli.net/2020/11/05/fn1UlzWpjtboxV3.png" alt=""></p><h1 id="我的不足"><a href="#我的不足" class="headerlink" title="我的不足"></a>我的不足</h1><ul><li>路由的使用（路由与组件解耦，语法）</li><li>Vue过渡效果 （<a href="https://cn.vuejs.org/v2/guide/transitions.html）" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/transitions.html）</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端-基础</title>
      <link href="/2020/10/29/yi-dong-duan-ji-chu/"/>
      <url>/2020/10/29/yi-dong-duan-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="移动端-基础"><a href="#移动端-基础" class="headerlink" title="移动端-基础"></a>移动端-基础</h1><h2 id="开发现状"><a href="#开发现状" class="headerlink" title="开发现状"></a>开发现状</h2><ul><li>浏览器：兼容主流浏览器，处理webkit内核浏览器即可</li><li>屏幕：碎片化严重，开发者无需关注这些分辨率，常用单位为px</li></ul><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口（viewport）就是浏览器显示页面内容的屏幕区域。视口可分为布局视口、视觉视口和理想视口。</p><h3 id="布局视口（layout-viewport）"><a href="#布局视口（layout-viewport）" class="headerlink" title="布局视口（layout viewport）"></a>布局视口（layout viewport）</h3><ul><li>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上的显示问题。</li><li>IOS、Android基本都将这个视口分辨率设置为980px，所以PC上的页面在手机上可以显示，但元素比较小，默认可以通过手动缩放。</li></ul><h3 id="视觉视口（visual-viewport）"><a href="#视觉视口（visual-viewport）" class="headerlink" title="视觉视口（visual viewport）"></a>视觉视口（visual viewport）</h3><ul><li>指用户正在看到的网站区域。</li><li>可以通过缩放去操作视觉视口，但不会影响视觉视口。</li></ul><p><img src="Snipaste_2020-10-29_22-23-46.png" alt=""></p><h3 id="理想视口（ideal-viewport）"><a href="#理想视口（ideal-viewport）" class="headerlink" title="理想视口（ideal viewport）"></a>理想视口（ideal viewport）</h3><ul><li>页面自适应屏幕宽度</li><li>需要手动添加meta视口标签</li></ul><pre><code>//mate视口标签 单标签&lt;meta name="viewport" content="width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; </code></pre><h2 id="物理像素与物理像素比"><a href="#物理像素与物理像素比" class="headerlink" title="物理像素与物理像素比"></a>物理像素与物理像素比</h2><ul><li>物理像素指的就是屏幕显示的最小颗粒，是物理真实存在的</li><li>开发时候的1px并不一定等于1个物理像素</li><li>PC端，1px等于一个物理像素，但移动端不经相同</li><li>一个px能显示的物理像素点的个数，称为物理像素比</li></ul><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>媒体查询(Media Query)</p><ul><li>可以针对不同媒体类型定义不同样式</li><li>针对不同屏幕尺寸设置不同样式</li><li>屏幕大小改变会重新渲染页面</li></ul><pre><code>//语法@media mediatype and|not|only (media feature){    CSS-Code}mediatype: 将不同的终端划分为不同类型，称为媒体类型    all: 所有类型    pring: 用于打印机和打印预览    scree: 用于屏幕and|not|only: 关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件media feature: 媒体特性    width: 定义输出设备中可见宽度    min-width: 定义输出设备中页面最小区域宽度    max-width: 定义输出设备中页面最大区域宽度</code></pre><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem(root em)是一个相对单位，类似于em，em是父元素字体大小，不同的是rem是基准是相对于html元素的字体大小。设置根元素(html)的字体大小font-size=12px,非根元素设置width:2rem，换算成px就是24px</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>Less(Leaner Style Sheets)是css扩展语言，也称为css预处理器，在css的基础上引入了变量、Mixin(混入)、运算以及函数等功能。常见的CSS预处理器有：Sass、Less、Stylus</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-3D转换</title>
      <link href="/2020/10/21/css-3d-zhuan-huan/"/>
      <url>/2020/10/21/css-3d-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-3D转换"><a href="#CSS-3D转换" class="headerlink" title="CSS-3D转换"></a>CSS-3D转换</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>近大远小，可以被遮挡</p><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><p>x轴：水平向右，向右为正值，向左为负值</p><p>y轴：垂直向下，向下为正值，向上为负值</p><p>z轴：垂直屏幕，屏幕向外为正，屏幕向内为负</p><h2 id="3D移动-translate3d"><a href="#3D移动-translate3d" class="headerlink" title="3D移动 translate3d"></a>3D移动 translate3d</h2><blockquote><p>3D移动在2D移动的基础上多了一个Z轴</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>//分开写transform: translateX(100px)transform: translateY(100px)transform: translateZ(1oopx)// translateZ一般用px作为单位//合写transform: translate3d(x,y,z)//x,y,z不能省略</code></pre><p><img src="1.gif" alt=""></p><p>除了位置变化外，其他并没有什么变化，是因为我们没有加透视，就像看3D电影没戴3D眼镜一样</p><h2 id="透视-perspective"><a href="#透视-perspective" class="headerlink" title="透视 perspective"></a>透视 perspective</h2><ul><li><p>在2d平面内产生近大远小的视觉立体，但效果实在二维上呈现的，可以想象成3d物体投影在2d平面内</p></li><li><p>透视也成为视距：眼镜到屏幕的距离</p></li><li><p>透视的单位是像素、</p></li><li><p>透视写在被观察盒子的父盒子上面</p></li></ul><p><img src="2.gif" alt=""></p><p>加上透视后，可以观察到盒子在变大</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3D转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-动画</title>
      <link href="/2020/10/15/css-dong-hua/"/>
      <url>/2020/10/15/css-dong-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS-动画"></a>CSS-动画</h1><h2 id="动画的基本使用"><a href="#动画的基本使用" class="headerlink" title="动画的基本使用"></a>动画的基本使用</h2><ol><li>定义动画</li></ol><pre><code>//keyframes定义动画@keyframes 动画名称{    0%{        width:100px;    }    100%{         width:50px;    }}0% 是动画的开始，可以使用from代替100% 是动画的结束，可以使用to代替0% 100% 代表的是一个动画序列</code></pre><ol start="2"><li>调用动画</li></ol><pre><code>div{    width: 100px;    hieght: 50px;    background: pink;    animation-name: 动画名称;    animation-duration: 动画持续时间;}</code></pre><h3 id="动画序列"><a href="#动画序列" class="headerlink" title="动画序列"></a>动画序列</h3><ul><li>可以有多个动画序列</li><li>里面的百分数必须是整数</li><li>百分比是总时间的百分比</li></ul><pre><code>@keyframes 动画名称{    0%{    }    20%{    }    30%{    }    .....    100%{    }}</code></pre><h2 id="动画的常见属性"><a href="#动画的常见属性" class="headerlink" title="动画的常见属性"></a>动画的常见属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@keyframes</td><td>规定动画</td></tr><tr><td>animation</td><td>所有动画属性的简写属性，除animation-play-state</td></tr><tr><td>animation-name</td><td>规定@keyframes动画的名称（必须）</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的时间（秒/毫秒，必须），默认是0</td></tr><tr><td>animation-time-function</td><td>规定动画的运动曲线，默认是’ease’</td></tr><tr><td>animation-delay</td><td>规定动画何时开始，默认是0</td></tr><tr><td>animation-interation-count</td><td>规定动画播放的次数，默认是1，infinite：无限循环</td></tr><tr><td>animation-direction</td><td>规定动画是否在下周期逆向播放，默认是’normal’，’alternate’：逆向播放</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是’running’，还有’pause’</td></tr><tr><td>animation-fill-mode</td><td>规定动画结束后的状态，forwards：保持最后的状态，backwards：回到初始状态</td></tr></tbody></table><h2 id="动画属性简写"><a href="#动画属性简写" class="headerlink" title="动画属性简写"></a>动画属性简写</h2><pre><code>animation: 动画名称 持续时间 运动曲线 何时开始(动画延时) 播放次数 是否反方向 动画起始或结束后的状态</code></pre><h2 id="速度曲线"><a href="#速度曲线" class="headerlink" title="速度曲线"></a>速度曲线</h2><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>linear</td><td>匀速</td></tr><tr><td>ease</td><td>默认。动画以低俗开始，然后加速，在结束前变慢</td></tr><tr><td>ease-in</td><td>动画以低速开始</td></tr><tr><td>ease-out</td><td>动画以低速结束</td></tr><tr><td>ease-in-out</td><td>动画以低速开始和结束</td></tr><tr><td>steps()</td><td>指定了时间函数中的间隔数量（步长）</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-2D转换</title>
      <link href="/2020/10/12/css-2d-zhuan-huan/"/>
      <url>/2020/10/12/css-2d-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-2D转换"><a href="#CSS-2D转换" class="headerlink" title="CSS-2D转换"></a>CSS-2D转换</h1><p>transform(转换)可以实现元素的位移、旋转、缩放等效果，2D在二维坐标系中进行转换。</p><h2 id="translate（移动）"><a href="#translate（移动）" class="headerlink" title="translate（移动）"></a>translate（移动）</h2><blockquote><p>改变元素在页面中的位置，类似于定位</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>transform: translate(x,y);transform: translateX(n);transform: translateY(n);</code></pre><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li>translate最大优点是：不会影响其他元素的位置，但可以覆盖到其他元素上面</li><li>translate中的百分数是相对于自身元素的translate:(50%,50%)，相对自身长宽移动50%</li><li>对行内标签没有效果</li></ul><p><img src="1.gif" alt=""></p><h2 id="rotate-（旋转）"><a href="#rotate-（旋转）" class="headerlink" title="rotate （旋转）"></a>rotate （旋转）</h2><blockquote><p>让元素在2d平面内顺时针或逆时针旋转</p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>transform: rotate(度数)// 90deg</code></pre><h3 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h3><ul><li>度数为正顺时针旋转，度数为负逆时针旋转</li><li>默认旋转中心为元素的中心点</li></ul><h2 id="scale（缩放）"><a href="#scale（缩放）" class="headerlink" title="scale（缩放）"></a>scale（缩放）</h2><blockquote><p>放大或者缩小盒子</p></blockquote><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre><code>transform: scale(x,y);transform: scale(x);//相当于 scale(x,x)</code></pre><h2 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h2><ul><li>x y之间用,隔开</li><li>x y都是数字，代表放大倍数</li><li>不会影响其他盒子</li></ul><p>对比，粉色的盒子使用了<code>scale</code>，红色的盒子使用的是改变宽高，会影响其他的盒子。</p><p><img src="2.gif" alt=""></p><h2 id="2D转换中心点"><a href="#2D转换中心点" class="headerlink" title="2D转换中心点"></a>2D转换中心点</h2><blockquote><p>设置元素转换的中心点</p></blockquote><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre><code>transform-origin: x y;</code></pre><h3 id="重点-3"><a href="#重点-3" class="headerlink" title="重点"></a>重点</h3><ul><li>x y之间用空格隔开</li><li>默认的中心点是元素的中心点 transform-origin: 50% 50%;</li><li>x y 可以是像素点 或 方位名词（top left right bottom cnnter）</li></ul><pre><code> .rotate{            width: 100px;            height: 100px;            transform-origin:left bottom ;            margin: 100px auto;            background: pink;            transition: all 1s;        }.rotate:hover{        transform: rotate(90deg);        }</code></pre><p><img src="3.gif" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2D转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue Router</title>
      <link href="/2020/09/30/vue-router/"/>
      <url>/2020/09/30/vue-router/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-Router"><a href="#vue-Router" class="headerlink" title="vue Router"></a>vue Router</h1><p><a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html" target="_blank" rel="noopener">Vue Router</a></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>注入路由后，可以通过<code>this.$router</code>访问路由器，<code>this.$route</code>访问当前路由</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><h3 id="匹配特定路径"><a href="#匹配特定路径" class="headerlink" title="匹配特定路径"></a>匹配特定路径</h3><pre><code>routers:[psth:'/user/:id',component: User]</code></pre><p><code>/user/A</code>、<code>/user/B</code>都将匹配到相同的路由</p><p>动态路径参数使用<code>:</code>标记，可以通过<code>this.$route.params</code>，例如访问上面的<code>id</code>：<code>this.$route.params.id</code></p><p>从<code>/user/A</code>转到<code>/user/B</code>的时候，组件将被复用，生命周期将不会被调用，如果想根据路由参数进行响应的话：</p><ol><li><p>监测<code>$route</code>对象</p><pre><code>watch:{    $route(to,from){        //do something    }}</code></pre></li></ol><ol start="2"><li>使用路由守卫</li></ol><pre><code>beforeRouteUpdate(to,from,next){    //do something}</code></pre><h3 id="匹配任意路径（捕获404）"><a href="#匹配任意路径（捕获404）" class="headerlink" title="匹配任意路径（捕获404）"></a>匹配任意路径（捕获404）</h3><p>使用通配符<code>*</code>，当使用通配符的时候，<code>$route.params</code>会自动添加一个名为<code>pathMatch</code>的参数，包含通过通配符被匹配的部分</p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>同一个路径可以匹配多个路由，匹配的优先级是：谁先匹配，谁的优先级更高</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code>是最顶层的出口，渲染最高级路由匹配的组件，被渲染的组件也可以包含<code>&lt;router-view&gt;&lt;/router-view&gt;</code>，需要配置<code>children</code>配置：</p><pre><code>routers:[psth:'/user/:id',component: User,                    children:[{                        path:'', component:                     },                    .....]]</code></pre><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>可以通过一个名称来标识一个路由</p><pre><code>const router = new VueRouter({  routes: [    {      path: '/user/:userId',      name: 'user',      component: User    }  ]}</code></pre><pre><code>//声明式&lt;router-link :to="{ name: 'user', params: { userId: 123 }}"&gt;User&lt;/router-link&gt;//编程式router.push({ name: 'user', params: { userId: 123 }})</code></pre><h2 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h2><pre><code>router指代this.$router</code></pre><h3 id="router-push-location-onComplete-onAbort"><a href="#router-push-location-onComplete-onAbort" class="headerlink" title="router.push(location, onComplete?, onAbort?)"></a>router.push(<code>location, onComplete?, onAbort?</code>)</h3><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><router-link :to="..."></router-link></td><td>router.push(…)</td></tr></tbody></table><p>参数可以是字符串路径或描述地址的对象</p><pre><code>//字符串router.push('home')//对象router.push({path:'home'})//命名的路由router.push({name:'user',params:{userId:'123'}})//带查询参数router.push({path:'register',query:{plan:'private'}})</code></pre><p>如果提供了<code>path</code>，<code>params</code>会被忽略掉</p><pre><code>// 这里的 params 不生效router.push({ path: '/user', params: { userId }}) // -&gt; /user</code></pre><p>同样的规则也适用于<code>router-link</code>的<code>to</code>属性</p><h3 id="router-repace-location-onComplete-onAbort"><a href="#router-repace-location-onComplete-onAbort" class="headerlink" title="router.repace(location, onComplete?, onAbort?)"></a>router.repace(<code>location, onComplete?, onAbort?</code>)</h3><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><router-link :to="..." replace=""></router-link></td><td>Router.replace(…)</td></tr></tbody></table><p>不会向history里面添加记录</p><h3 id="onComplete-和-onAbort"><a href="#onComplete-和-onAbort" class="headerlink" title="onComplete 和 onAbort"></a>onComplete 和 onAbort</h3><p>导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用</p><h3 id="router-go-n"><a href="#router-go-n" class="headerlink" title="router.go(n)"></a>router.go(n)</h3><p>在history记录中前进或后退多少步，类似于window.history.go(n)</p><h2 id="对比history"><a href="#对比history" class="headerlink" title="对比history"></a>对比history</h2><table><thead><tr><th align="center">Vue router</th><th align="center">history</th></tr></thead><tbody><tr><td align="center">router.push(…)</td><td align="center">window.history.pushState(…)</td></tr><tr><td align="center">router.replace(…)</td><td align="center">window.history.repalceState(…)</td></tr><tr><td align="center">router.go(n)</td><td align="center">window.history.go(n)</td></tr></tbody></table><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>同级展示多个视图，可以在界面中拥有多个单独命名的视图，而不是一个出口，如果<code>router-view</code>没有设置名字，那么默认为<code>dafault</code></p><pre><code>&lt;router-view class="view one"&gt;&lt;/router-view&gt;&lt;router-view class="view two" name="a"&gt;&lt;/router-view&gt;&lt;router-view class="view three" name="b"&gt;&lt;/router-view&gt;const router = new VueRouter({  routes: [    {      path: '/',      components: {        default: Foo,        a: Bar,        b: Baz      }    }  ]})</code></pre><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><p>重定向通过<code>routes</code>来配置</p><pre><code>const router = new VueRouter({  routes: [    { path: '/a', redirect: '/b' }  ]})</code></pre><p><code>redirect</code>也可以是一个命名的路由，也可以是一个方法</p><pre><code>const router = new VueRouter({  routes: [    { path: '/a', redirect: { name: 'foo' }}  ]})const router = new VueRouter({  routes: [    { path: '/a', redirect: to =&gt; {      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    }}  ]})</code></pre><p>别名对应的配置如下：</p><pre><code>const router = new VueRouter({  routes: [    { path: '/a', component: A, alias: '/b' }  ]})</code></pre><h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><p>在组件中直接使用<code>$route</code>会使其与对应路由形成高度耦合，使用<code>props</code>将组件和路由解耦</p><pre><code>const User = {  props: ['id'],  template: '&lt;div&gt;User {{ id }}&lt;/div&gt;'}const router = new VueRouter({  routes: [    { path: '/user/:id', component: User, props: true },    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：    {      path: '/user/:id',      components: { default: User, sidebar: Sidebar },      props: { default: true, sidebar: false }    }  ]})</code></pre><p><a href="https://jsfiddle.net/posva/6du90epg/" target="_blank" rel="noopener">https://jsfiddle.net/posva/6du90epg/</a></p><h2 id="hash和history模式（针对单页应用SPA）"><a href="#hash和history模式（针对单页应用SPA）" class="headerlink" title="hash和history模式（针对单页应用SPA）"></a>hash和history模式（针对单页应用SPA）</h2><pre><code>前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。</code></pre><p>hash——即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。 比如这个 URL：<a href="http://www.abc.com/#/hello，hash" target="_blank" rel="noopener">http://www.abc.com/#/hello，hash</a> 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</p><p>已经有 hash 模式了，而且 hash 能兼容到IE8， history 只能兼容到 IE10，为什么还要搞个 history 呢？<br>首先，hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><blockquote><p>导航表示路由正在发生变化，查询参数的变化并不会触发进入/离开的导航守卫</p></blockquote><ul><li>全局前置守卫</li></ul><pre><code>const router = new VueRouter({ ... })router.beforeEach((to, from, next) =&gt; {  // ...})</code></pre><p>当一个导航触发的时，全局前置守卫按照创建顺序调用</p><p>next:Function:一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</p><p>​    <strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</p><p>​    <strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</p><p>​    <strong><code>next('/')</code> 或者 <code>next({ path: '/' })</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: 'home'</code> 之类的选项以及任何用在 <a href="https://router.vuejs.org/zh/api/#to" target="_blank" rel="noopener"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://router.vuejs.org/zh/api/#router-push" target="_blank" rel="noopener"><code>router.push</code></a> 中的选项。</p><p>​    <strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://router.vuejs.org/zh/api/#router-onerror" target="_blank" rel="noopener"><code>router.onError()</code></a> 注册过的回调。</p><ul><li>全局后置钩子</li></ul><pre><code>router.afterEach((to, from) =&gt; {  // ...})</code></pre><ul><li>路由独享守卫</li></ul><pre><code>const router = new VueRouter({  routes: [    {      path: '/foo',      component: Foo,      beforeEnter: (to, from, next) =&gt; {        // ...      }    }  ]})</code></pre><ul><li>组件内的守卫<ul><li>beforeRouterEnter</li><li>beforeRouterUpdate</li><li>beforeRouterLeaver</li></ul></li></ul><pre><code>const Foo = {  template: `...`,  beforeRouteEnter (to, from, next) {    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建  },  beforeRouteUpdate (to, from, next) {    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 可以访问组件实例 `this`  },  beforeRouteLeave (to, from, next) {    // 导航离开该组件的对应路由时调用    // 可以访问组件实例 `this`  }}</code></pre><p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p><p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><pre><code>beforeRouteEnter (to, from, next) {  next(vm =&gt; {    // 通过 `vm` 访问组件实例  })}</code></pre><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p><pre><code>beforeRouteLeave (to, from, next) {  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')  if (answer) {    next()  } else {    next(false)  }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue-Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-三角、自适应高</title>
      <link href="/2020/09/21/css-san-jiao-zi-gua-ying-gao/"/>
      <url>/2020/09/21/css-san-jiao-zi-gua-ying-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-三角、自适应高"><a href="#CSS-三角、自适应高" class="headerlink" title="CSS-三角、自适应高"></a>CSS-三角、自适应高</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-无限循环</title>
      <link href="/2020/09/17/css-wu-xian-xun-huan/"/>
      <url>/2020/09/17/css-wu-xian-xun-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-无限循环的奥义"><a href="#CSS-无限循环的奥义" class="headerlink" title="CSS-无限循环的奥义"></a>CSS-无限循环的奥义</h1><p>先上图：</p><p><img src="1.gif" alt=""></p><p>​    看起来是有点卡顿，但实际效果比gif图好那么一丢丢（不会出现上面的卡顿，在safari上面的效果如丝般润滑，上图是在chrome上的效果）。这是最近甲方爸爸需要实现的一个效果，作为一个前端小菜鸡，我顿时就蒙了，我还没做过这种动画效果，但是年轻人怕啥，上百度就完事。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>右边的动画效果分为三成，最上面的就是实际的数据展示，下面两层两个假的背景图需要实现不同速度的无限循环，显得<del>好看点</del>。盒子在移动的过程中需要做缩小的效果。</p><p><img src="Snipaste_2020-09-17_09-55-34.png" alt=""></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="先动起来"><a href="#先动起来" class="headerlink" title="先动起来"></a>先动起来</h3><p>使盒子或图片实现无限循环的效果，需要准备两份一模一样的dom，当第一个dom移动的时候第二个dom随着移动，第一个dom完成动画效果后，<strong>直接替换第二个dom</strong>，也就是所有的动画效果只是在第一个dom上作用。要实现实现动画效果就需要<code>animation</code>属性。</p><p>HTML结构</p><pre><code>&lt;div class="father"&gt;    &lt;div class="son1"&gt;&lt;/div&gt;    &lt;div class="son2"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>将需要动画css效果加到<code>father</code>上，它就会控制下面的<code>son1</code>、<code>son2</code>实现无限循环，<code>son1</code>、<code>son2</code>的结构是一模一样的，但是要给<code>son2</code>添加<code>left：-100%</code>是为了让<code>s1</code>、<code>s2</code>隔开，然后就是给<code>father</code>添加css效果。</p><pre><code> getScrollStyle(offsetHeight, speed = 20,type){        const uid = Math.random().toString(36).substr(2);        const style = document.createElement('style');        style.type = 'text/css';        if(type === scrollType.rb){            style.innerHTML = `@-webkit-keyframes rowup${uid} {              0% {                  -webkit-transform: translate3d(-1%, 0, 0);                  transform: translate3d(-1%, 0, 0);              }              100% {                  -webkit-transform: translate3d( 100%,0, 0);                  transform: translate3d(100%,0, 0);              }          }          @keyframes rowup${uid} {              0% {                  -webkit-transform: translate3d(-1%, 0, 0);                  transform: translate3d(-1%, 0, 0);              }              100% {                  -webkit-transform: translate3d(50%,0,  0);                  transform: translate3d(100%,0,  0);              }          }          .rowup-${uid}{              -webkit-animation: ${Math.floor(offsetHeight*1000 / speed)}ms rowup${uid} linear infinite normal;              animation: ${Math.floor(offsetHeight*1000 / speed)}ms rowup${uid} linear infinite normal;          }`          this.animationTime = Math.floor(offsetHeight*1000 / speed)          this.animationTime = (this.animationTime/1000).toFixed(3)        }else if(type === scrollType.vb){              style.innerHTML = `@-webkit-keyframes rowup${uid} {              0% {                  -webkit-transform: translate3d(-1%, 0, 0);                  transform: translate3d(-1%, 0, 0);                   opacity: 0;              }              100% {                  -webkit-transform: translate3d( 100%,0, 0);                  transform: translate3d(100%,0, 0);                   opacity: 1;              }          }          @keyframes rowup${uid} {              0% {                  -webkit-transform: translate3d(-1%, 0, 0);                  transform: translate3d(-1%, 0, 0);                   opacity: .4;              }              90%{                 opacity: .8;              }              100% {                  -webkit-transform: translate3d(100%,0,  0);                  transform: translate3d(100%,0,  0);                   opacity: .4;              }          }          .rowup-${uid}{              -webkit-animation: ${Math.floor(offsetHeight*1000 / speed)}ms rowup${uid} linear infinite normal;              animation: ${Math.floor(offsetHeight*1000 / speed)}ms rowup${uid} linear infinite normal;          }`        }else if(type === scrollType.bi){              style.innerHTML = `@-webkit-keyframes rowup${uid} {              0% {                  -webkit-transform: translate3d(-1%, 0, 0);                  transform: translate3d(-1%, 0, 0);              }              100% {                  -webkit-transform: translate3d( 100%,0, 0);                  transform: translate3d(100%,0, 0);              }          }          @keyframes rowup${uid} {              0% {                  -webkit-transform: translate3d(-1%, 0, 0);                  transform: translate3d(-1%, 0, 0);              }              100% {                  -webkit-transform: translate3d(100%,0,  0);                  transform: translate3d(100%,0,  0);              }          }          .rowup-${uid}{              -webkit-animation: ${Math.floor(offsetHeight*1000 / speed)}ms rowup${uid} linear infinite normal;              animation: ${Math.floor(offsetHeight*1000 / speed)}ms rowup${uid} linear infinite normal;          }`        }       document.getElementsByTagName('head')[0].appendChild(style);       return `rowup-${uid}`;    },//记得给father添加这个.father{    overflow: hidden;}</code></pre><p>其中<strong>offsetHeight</strong>是<code>father</code>的，<strong>type</strong>是根据不同效果层返回不同的动画效果，将返回的css添加到<code>father</code>上就可以实现循环滚动。</p><h3 id="缩小实现"><a href="#缩小实现" class="headerlink" title="缩小实现"></a>缩小实现</h3><p>使用<code>keyframes</code>（上一个效果已经用了）</p><pre><code> @keyframes firstScaleDraw{           0%{                 transform: scale(1);             }            100%{              top: 36%;              transform: scale(0);             }  }//将关键帧添加到需要添加的dom上 .s1 .market_size,  .s1  .market_share,  .s1  .patent_number, .s1 .difficulty, .s1 .market_maturity,  .s1 .financing_scale, .s1 .ave_invt_size, .s1 .conversion_rate{   -webkit-animation-name: firstScaleDraw; /*关键帧名称*/   -webkit-animation-timing-function: ease-in-out; /*动画的速度曲线*/   -webkit-animation-iteration-count: infinite;  /*动画播放的次数*/}//还没添加动画时间</code></pre><h4 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h4><p>上面的动画效果还没有添加时间，我本来是给它单独添加时间的，但是注意到我们已经实现了一个动画效果，如果两个动画效果时间不一致会造成以下效果。</p><p><img src="2.gif" alt=""></p><p>所以你需要这样：</p><p><img src="Snipaste_2020-09-17_10-22-54.png" alt=""></p><p><img src="Snipaste_2020-09-17_10-22-59.png" alt=""></p><p>统一他们的动画时间。</p><h3 id="关于背景"><a href="#关于背景" class="headerlink" title="关于背景"></a>关于背景</h3><p>如果你用两张一模一样的图片去循环会造成背景太过于单调，如果使用不同的图片，在两个dom进行切换的时候会造成卡顿的效果，体验不要，这时候就需要美工的帮助了🤣，切一个长图出来，这里也需要注意一点就是背景图片的效果一定要设置的比较宽，不要使用<code>width:100%</code>，一定要比<code>100%</code>宽，因为你的图是一个长图。</p><h2 id="想暂停的话"><a href="#想暂停的话" class="headerlink" title="想暂停的话"></a>想暂停的话</h2><p>老爹说过要用魔法对抗魔法，用css对抗css。</p><p>当鼠标悬停的时候，需要停止动画效果，我最开始的时候使用js来控制的，监听hover事件，但效果一言难尽。最后发现只需要添加一个属性就好。</p><pre><code>animation-play-state:paused;</code></pre><p>要控制多个动画效果的话，还是监听dom的hover事件，控制变量，动态给需要的dom添加上面的属性。</p><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><h3 id="跳帧"><a href="#跳帧" class="headerlink" title="跳帧"></a>跳帧</h3><p>背景图片在移动的过程中，其实有透明度的变化，本来设置从0% - 100%直接变化，但是注意到第二个dom其实是没有动画效果的，就会造成跳帧的不好体验，所以0%处不能设置成 <code>opacity:0</code>，需要自己慢慢调试设置对应的值，我设置的值为<code>opacity:0.4</code>，还有就是0%和100%的效果需要保持一致。不然也会造成跳帧。</p><p><img src="Snipaste_2020-09-17_10-50-00.png" alt=""></p><h2 id="想要不同方向的移动"><a href="#想要不同方向的移动" class="headerlink" title="想要不同方向的移动"></a>想要不同方向的移动</h2><p>设置这个属性就好</p><pre><code>translate3d(100%,0,  0);</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.xiabingbao.com/css3/2017/07/03/css3-infinite-scroll.html" target="_blank" rel="noopener">1</a></p><p><a href="https://segmentfault.com/a/1190000021821797" target="_blank" rel="noopener">2</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画效果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome-12px字体大小限制</title>
      <link href="/2020/09/08/chrome-12px-zi-ti-da-xiao-xian-zhi/"/>
      <url>/2020/09/08/chrome-12px-zi-ti-da-xiao-xian-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Chrome-12px字体限制"><a href="#Chrome-12px字体限制" class="headerlink" title="Chrome-12px字体限制"></a>Chrome-12px字体限制</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常填坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-用户体验优化及小技巧</title>
      <link href="/2020/08/23/css-yong-hu-ti-yan-you-hua-ji-xiao-ji-qiao/"/>
      <url>/2020/08/23/css-yong-hu-ti-yan-you-hua-ji-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-用户体验优化及小技巧"><a href="#CSS-用户体验优化及小技巧" class="headerlink" title="CSS-用户体验优化及小技巧"></a>CSS-用户体验优化及小技巧</h1><h2 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式"></a>鼠标样式</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>default</td><td>默认样式</td></tr><tr><td>text</td><td>文本样式</td></tr><tr><td>pointer</td><td>小手</td></tr><tr><td>no-allowed</td><td>禁止🚫样式</td></tr></tbody></table><h2 id="图片底部空白缝隙解决方案"><a href="#图片底部空白缝隙解决方案" class="headerlink" title="图片底部空白缝隙解决方案"></a>图片底部空白缝隙解决方案</h2><h2 id="文字溢出处理"><a href="#文字溢出处理" class="headerlink" title="文字溢出处理"></a>文字溢出处理</h2><h2 id="取消表单轮廓和文本拖拽域"><a href="#取消表单轮廓和文本拖拽域" class="headerlink" title="取消表单轮廓和文本拖拽域"></a>取消表单轮廓和文本拖拽域</h2><h2 id="行内元素巧妙运用"><a href="#行内元素巧妙运用" class="headerlink" title="行内元素巧妙运用"></a>行内元素巧妙运用</h2><h2 id="文字与图片垂直居中"><a href="#文字与图片垂直居中" class="headerlink" title="文字与图片垂直居中"></a>文字与图片垂直居中</h2><h2 id="margin负值运用"><a href="#margin负值运用" class="headerlink" title="margin负值运用"></a>margin负值运用</h2><h2 id="文字围绕浮动元素巧妙运用"><a href="#文字围绕浮动元素巧妙运用" class="headerlink" title="文字围绕浮动元素巧妙运用"></a>文字围绕浮动元素巧妙运用</h2><h2 id="三角形及其运用"><a href="#三角形及其运用" class="headerlink" title="三角形及其运用"></a>三角形及其运用</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-精灵图</title>
      <link href="/2020/08/20/css-jing-ling-tu/"/>
      <url>/2020/08/20/css-jing-ling-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-精灵图🧚‍♀️"><a href="#CSS-精灵图🧚‍♀️" class="headerlink" title="CSS-精灵图🧚‍♀️"></a>CSS-精灵图🧚‍♀️</h1><h2 id="什么是精灵图"><a href="#什么是精灵图" class="headerlink" title="什么是精灵图"></a>什么是精灵图</h2><p>CSS Sprites通常被称为css精灵图，在国内也被意译为css图片整合和css贴图定位，也有人称他为雪碧图。就是将导航的背景图，按钮的背景图等有规则的合并成一张背景图，即多张图合并为一张整图，然后再利用background-position进行背景图定位的一种技术。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>精灵图主要目的是为了减小服务器开销，本来需要请求几次的图片，只需要请求一次就可以了</p><h2 id="适用的场景"><a href="#适用的场景" class="headerlink" title="适用的场景"></a>适用的场景</h2><p>适用于小图标、并不需要经常更新的图片</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p><img src="1.gif" alt=""></p><p><a href="https://github.com/muyeyong/HTML-CSS-/tree/master/%E7%B2%BE%E7%81%B5%E5%9B%BE">源码</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 精灵图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码优化-充分利用</title>
      <link href="/2020/08/17/dai-ma-you-hua-chong-fen-li-yong/"/>
      <url>/2020/08/17/dai-ma-you-hua-chong-fen-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="代码优化-充分利用"><a href="#代码优化-充分利用" class="headerlink" title="代码优化-充分利用"></a>代码优化-充分利用</h1><p>​                                                                                                   No picture, say jiba</p><p><img src="1f5a00fd-cc66-468d-82ed-1e35fe2996d4.png" alt=""></p><p>首先我们先上图：</p><p><img src="Snipaste_2020-08-17_18-08-44.png" alt=""></p><p>​                                                                                                                        图一</p><p><img src="Snipaste_2020-08-17_18-09-51.png" alt=""></p><p>​                                                                                                                    图二</p><p>有没有发现这两张图的不一样的地方？图一地图颜色比图二的地图颜色更加丰富多彩，地图上的颜色是根据每个地区的数据渲染出来的，有一种基本色和五种根据数据变化的可选颜色，图二是我第一次写出来的效果，图二是修改完之后的效果，<del>图二的效果也不是不能用</del>，但是想到：</p><ul><li>颜色没有充分利用</li><li>数据相差比较大的地区也使用相同的颜色，用户体验不好</li></ul><p>于是我开始了代码优化，在改到最终版本之前，有两个版本。</p><p>版本一： 直接划分一个固定的区间，每个区间指定需要渲染的颜色，然后根据传入的数值跟固定区间的数值比较返回颜色值</p><p><img src="Snipaste_2020-08-17_18-22-46.png" alt=""></p><p>这无疑是一个简单高效(代码可以写的快)的做法，但也可以肯定这不是一个好的做法。</p><p>版本二：这是我改的版本(<del>为了快速迭代</del>)，把区间变成了一个动态的，虽然好了那么一丢丢，但效果不尽人意</p><p><img src="Snipaste_2020-08-17_18-28-11.png" alt=""></p><p>这两个版本遇到的问题：</p><ul><li>数据极端分布(就像我跟马云平均一下也是个亿万富翁一样)，颜色不能充分利用</li><li>数据过于集中分布，颜色不能充分利用</li></ul><p>于是我就想怎么样才能充分利用，这就要分情况讨论了</p><ol><li>当需要渲染的地区没有超过我的颜色总数时，直接将颜色分配下去</li><li>当需要渲染的地区超过了我的颜色总数时，需要多个地区共用一个颜色</li></ol><p>第一中情况比较简单，主要是第二种情况，需要确定要分几个区间，以及每个区间的大小</p><p>我的想法是先计算出可以分的的区间的最大值，然后从<code>1</code>枚举到可分区间的最大值，并计算区间的大小，就可以获得平均区间大小下的所有将颜色利用完的可能性，然后确定最优解，只有将数据大小相近的分配到一个区间才比较合适，所以我制定最优解是：根据每种可能性内区间最大值和最小值的差的平局值最小的取为最优。</p><ul><li><p>确定可分区间的最大值(最多可以分几个区间)</p><p><code>let maxBlock</code> = 传入数值的总数(去过重)/可选颜色的总数向上取整</p></li><li><p>计算区间大小</p><p><code>let blockSize</code> = (传入数值的总数(去过重) - 可选颜色的总数 + 当前区间的数量) / 当前区间数量</p></li><li><p>算出每种情况下的差值的平均值</p></li></ul><p><img src="Snipaste_2020-08-17_20-28-34.png" alt=""></p><p>代码实现：</p><pre><code>  let colorMap = []         let countArr = mapAgg.map(item=&gt; parseInt(item.count))          countArr =  Array.from(new Set(countArr)).sort((x,y)=&gt; x-y)          let countLen = countArr.length, colorLen = colors.length          if(countLen &lt;= colorLen){            while(countLen&gt;-1){              countLen--;              colorMap[countArr[countLen]] = colors[--colorLen]            }          }else{            let maxBlock = Math.ceil(countLen/colorLen)            let blockDiff = [], blockDiffDetail= []            for(let blockCount= 1;blockCount&lt;= maxBlock;blockCount++){              let blockSize = (countLen-colorLen+blockCount)/blockCount              if(blockSize&lt;=0) continue              let start= 0, end= start+blockSize              let localOptimum = []              while(end&lt;countLen){                localOptimum.push({start: start,end:end-1,value:countArr[end-1]-countArr[start]})                start++                end = start+blockSize              }              localOptimum.sort((x,y)=&gt; x.value-y.value)              localOptimum = localOptimum.slice(0,blockSize)              blockDiff.push(localOptimum[0].value)              blockDiffDetail.push(localOptimum)            }            let minValue = Number.MAX_VALUE, minValueIndex            blockDiff.forEach((value, index)=&gt;{              if(value&lt;minValue){                minValue = value                minValueIndex = index              }            })            let perfectDiff = blockDiffDetail[minValueIndex]            perfectDiff.forEach((item,index)=&gt;{              let arg = index              for(let i=item.start;i&lt;=item.end;i++){                colorMap[i] = -index              }            })            while(countLen&gt;-1){                countLen--                if(colorMap[countArr[countLen]]&lt; 0){                  colorMap[countArr[countLen]] = colors[colorLen -1]                }else{                   colorMap[countArr[countLen]] = colors[--colorLen]                }            }          }</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实这样也不是特别好，区间大小分配是均匀的，还是太菜了，要多学算法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 充分利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码优化-刷新界面后怎么保存用户数据</title>
      <link href="/2020/08/13/dai-ma-you-hua-shua-xin-jie-mian-hou-zen-me-bao-cun-yong-hu-shu-ju/"/>
      <url>/2020/08/13/dai-ma-you-hua-shua-xin-jie-mian-hou-zen-me-bao-cun-yong-hu-shu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="代码优化-刷新界面后怎么保存用户数据"><a href="#代码优化-刷新界面后怎么保存用户数据" class="headerlink" title="代码优化-刷新界面后怎么保存用户数据"></a>代码优化-刷新界面后怎么保存用户数据</h1><p>先上一张图：</p><p><img src="1.gif" alt=""></p><p>是不是觉得看了个寂寞，感觉也没啥变化，是的，这是一个很不显眼的优化，在这个🌰中，每次刷新保持了用户选择的地区没有被初始化，保存了用户数据，最开始是想用vue的路由来做，但是效果不太好是(<del>是我太菜</del> ，使用query和params在刷新的时候会丢失赋值，强行使用<code>window.history</code>会引发地址混乱)，最后选择用<code>sessionStorage</code>实现，可以很简单的实现：刷新页面或刚进入页面的时候去取存储的值，没有的话赋默认值，每次当用户数据改变的时候将改变的值存储起来，over！！但是作为一个<del>优秀的前端工程师</del>，我肯定有更好的解决方案，首先分析一下上面的方法有哪些不好的地方：</p><ol><li>当用户数据改变的时候，就将数据存起来，是不好太浪费了？我们只需要存储最终的数据即可，<del>小孩子才看过程，成年人只要结果</del></li><li>获取和存储用户数据的时候都需要去写<code>sessionStorege.setItem(xxx)\.getItem(xxx)</code> 是不是觉得代码不够优雅?</li><li>啊吧啊吧。。。。。</li></ol><p>接下来就是展示真正的技术了</p><h2 id="使用sessionStorage"><a href="#使用sessionStorage" class="headerlink" title="使用sessionStorage"></a>使用sessionStorage</h2><p>为什么使用<code>sessionStorage</code> 不使用<code>localStorage</code>?</p><p>​    我当前的应用场景是保存用户的搜索🔍条件，并不需要永久的保存将数据存储。</p><p>我在写的项目前端使用的框架是Vue，我就利用了<code>Vuex + 浏览器事件监听 + VueRoute路由钩子函数</code>实现了需要的效果</p><p>首先明确我们需要存储的用户数据是选择的地区这个字段，在这里命名为<code>activeRegionName</code>，将它放到store里面，但是store里面的数据并不都要存储起来，我们还需要一个数组记录需要存储到store里面数据的名字，实现代码如下：</p><p><img src="Snipaste_2020-08-13_21-03-24.png" alt=""></p><p>使用<code>getter</code>将state暴露出去(最开始我以为直接使用…mapState()引入即可，但是不行，需要使用…mapGetters())，在<code>mutations</code>对外提供操作state里面数据的方法,代码如下：</p><pre><code> //工具方法 const storeLocalStore = (value)=&gt;{    sessionStorage.setItem(STORAGEKEY,JSON.stringify(value))}/////////////////////////// getters :{        activeRegionName: state =&gt; state.activeRegionName    }, mutations : {        setStoreData(state){            let updataData = {}            storeDataName.forEach(item =&gt;{                updataData[item] = state[item]            })            storeLocalStore(updataData)        },        getStoreData(state){            let storeData = JSON.parse(sessionStorage.getItem(STORAGEKEY))             if(!storeData) return             storeDataName.forEach(item=&gt;{                if(storeData[item]&amp;&amp; state.hasOwnProperty(item)){                    state[item] = storeData[item]                }            })        },        changeActiveRegionName(state,value){            state.activeRegionName = value        }    },    </code></pre><p>到现在为止我们可以将<code>activeRegionName</code>存储到<code>sessionStorege</code>里面去了，接下来需要完成的是监听刷新操作和url变化的操作</p><p>在<code>methods</code> 里面使用 <code>...mapMutations()</code>引入<code>mutations</code>里面的方法，在<code>computed</code>里面使用<code>...mapGetters()</code>引入state里面的数据。</p><p>在<code>mounted()</code>里面添加浏览器刷新的监听事件，<code>destroyed()</code>里删除监听事件，代码如下：</p><pre><code>mounted() {     this.registEventListener()  },destroyed(){     this.cancelEventListenner()  },registEventListener(){  window.addEventListener('beforeunload', e =&gt; this.beforeunloadFn(e))  },cancelEventListenner(){  window.removeEventListener('beforeunload', e =&gt; this.beforeunloadFn(e))  },beforeunloadFn(){  this.setStoreData()  },</code></pre><p>至此在刷新时保存用户数据我们已经实现了，但是这个需求里面还有一个操作是右上角有个跳转，也需要在这个操作的时候存储用户数据，然而这个操作并不会触发<code>beforeunload</code>这个时间，这个时候就可以使用<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">VueRouter</a>的钩子函数了，<code>beforeRouteLeave</code>直接放到跟<code>methods</code>同级即可，代码如下：</p><pre><code> beforeRouteLeave(to, from, next){     this.setStoreData()     next() },</code></pre><p>这样的话我们的需求就实现了</p><h2 id="使用URL存储"><a href="#使用URL存储" class="headerlink" title="使用URL存储"></a>使用URL存储</h2><p>还需要等我试验完在写。。。。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户数据保存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-元素的显示与隐藏</title>
      <link href="/2020/08/09/css-yuan-su-de-xian-shi-yu-yin-cang/"/>
      <url>/2020/08/09/css-yuan-su-de-xian-shi-yu-yin-cang/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-元素的显示与隐藏"><a href="#CSS-元素的显示与隐藏" class="headerlink" title="CSS-元素的显示与隐藏"></a>CSS-元素的显示与隐藏</h1><h2 id="dispaly"><a href="#dispaly" class="headerlink" title="dispaly"></a>dispaly</h2><ul><li>display：none; 隐藏对象</li><li>display：block；出了转换成块级元素外，同时还有显示元素的意思（inner-block是不是也可以？）</li></ul><p><strong>diaplay隐藏元素后，不再占有原来的位置</strong></p><p><img src="/Snipaste_2020-08-10_09-22-50.png" alt=""></p><p><img src="Snipaste_2020-08-10_09-27-43.png" alt="">)]()</p><h2 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h2><table><thead><tr><th>可选参数</th><th>说明</th></tr></thead><tbody><tr><td>inherit</td><td>继承上一个父元素的可见性</td></tr><tr><td>visible</td><td>对象可见</td></tr><tr><td>hidden</td><td>对象隐藏</td></tr><tr><td>collapse</td><td>主要用于隐藏表格的行或列</td></tr></tbody></table><p><strong>visibility隐藏元素后，继续占有原来的位置</strong></p><h3 id="默认为visible"><a href="#默认为visible" class="headerlink" title="默认为visible :"></a>默认为<code>visible</code> :</h3><p><img src="Snipaste_2020-08-10_09-31-02.png" alt=""></p><h3 id="使用hidden，继续保留原来的位置："><a href="#使用hidden，继续保留原来的位置：" class="headerlink" title="使用hidden，继续保留原来的位置："></a>使用<code>hidden</code>，继续保留原来的位置：</h3><p><img src="/Snipaste_2020-08-10_09-32-21.png" alt=""></p><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>对溢出的位置进行显示隐藏</p><table><thead><tr><th>可选参数</th><th>说明</th></tr></thead><tbody><tr><td>visible</td><td>不剪切内容也不添加滚动条</td></tr><tr><td>auto</td><td>在需要时剪切内容并添加滚动条</td></tr><tr><td>hidden</td><td>不显示超过对象尺寸的内容</td></tr><tr><td>scroll</td><td>总是显示滚动条</td></tr></tbody></table><h3 id="visible，即默认情况"><a href="#visible，即默认情况" class="headerlink" title="visible，即默认情况"></a><code>visible</code>，即默认情况</h3><p><img src="Snipaste_2020-08-10_09-38-07.png" alt=""></p><h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a><code>hidden</code></h3><p><img src="Snipaste_2020-08-10_09-40-51.png" alt=""></p><h3 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a><code>scroll</code></h3><p><img src="Snipaste_2020-08-10_09-48-21.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元素的显示与隐藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-异步请求</title>
      <link href="/2020/07/27/javascript-yi-bu-qing-qiu/"/>
      <url>/2020/07/27/javascript-yi-bu-qing-qiu/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-异步请求"><a href="#JavaScript-异步请求" class="headerlink" title="JavaScript-异步请求"></a>JavaScript-异步请求</h1><blockquote><p>最近在写项目中看到发请求中使用了<code>fetch</code>，以前用的<code>axios</code>于是想知道这两种技术有什么区别，就写了这篇文章，打算以理论+实践的方式试一下这两者的区别</p></blockquote><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><h3 id="fetch与ajax的区别"><a href="#fetch与ajax的区别" class="headerlink" title="fetch与ajax的区别"></a>fetch与ajax的区别</h3><ul><li>当响应状态码是404或500时，fetch会将Promise的状态变成resolve，但是resolve返回值的ok属性设置为false，只要当网络故障或请求被拒绝的时候才会标记成reject</li><li>fetch可以接受跨域cookies，也可以使用fetch建立跨域会话</li><li>fetch不会发送cookies，除非使用credentials初始化选项</li></ul><h3 id="带请求参数"><a href="#带请求参数" class="headerlink" title="带请求参数"></a>带请求参数</h3><h3 id="带凭证"><a href="#带凭证" class="headerlink" title="带凭证"></a>带凭证</h3><h3 id="上传JSON"><a href="#上传JSON" class="headerlink" title="上传JSON"></a>上传JSON</h3><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><h3 id="检测是否成功"><a href="#检测是否成功" class="headerlink" title="检测是否成功"></a>检测是否成功</h3><h3 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h3><h3 id="Header对象"><a href="#Header对象" class="headerlink" title="Header对象"></a>Header对象</h3><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><h3 id="Body对象"><a href="#Body对象" class="headerlink" title="Body对象"></a>Body对象</h3><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码优化-抖动节流</title>
      <link href="/2020/07/21/dai-ma-you-hua-dou-dong-jie-liu/"/>
      <url>/2020/07/21/dai-ma-you-hua-dou-dong-jie-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="代码优化-抖动节流"><a href="#代码优化-抖动节流" class="headerlink" title="代码优化-抖动节流"></a>代码优化-抖动节流</h1><p>​    最近在写项目的时候，发现一个搜索框居然没有使用抖动，作为一名<del>优秀</del>😜的前端开发工程师，我怎么能容忍这种事情发生，于是就自己写了<code>debounce</code>和<code>throttle</code> </p><h2 id="抖动-debounce"><a href="#抖动-debounce" class="headerlink" title="抖动(debounce)"></a>抖动(debounce)</h2><blockquote><p>使用场景:当用户使用搜索框的时候，如果搜索框每发生一次改变就发一次请求的话（这就是我在写的项目的现状😥）就会找出巨大的浪费，用户可能只是想停下来想一下搜索关键字，这个时候抖动就有了很大的作用，它的作用是当用户停止操作（输入）的时候，并不会立即发请求，而是等经过一段时间后再发请求</p></blockquote><p>体验一下酸爽</p><p><img src="1.gif" alt=""></p><p>分析一下，<code>debounce</code>需要实现的功能：</p><ul><li>指定时间后在执行需要的操作</li><li>每次操作(比如输入)都需要重新开始计时</li></ul><pre><code> function debounce (fn, delayTime) {        let timeOut        return function () {            let args = arguments            clearTimeout(timeOut)            timeOut = setTimeout(function () {                fn.apply(this, args)            }, delayTime)        }    }</code></pre><p>看一下实际使用效果</p><p><img src="2.gif" alt=""></p><p>实战才是硬道理，在项目中使用试试</p><p><img src="3.gif" alt=""></p><p>没有以前那么夸张了，当然这也是个半成品，下面的搜索结果框没有出现，哈哈哈。在实现的过程中也遇到了一下问题，在此记录下：</p><ul><li>项目中使用了 <a href="[https://dvajs.com/guide/introduce-class.html#dispatch-%E6%96%B9%E6%B3%95](https://dvajs.com/guide/introduce-class.html#dispatch-方法)">dva中的dispatch</a>去发送请求(dva类似于reducer，也是用于状态管理)，我开始是这样写的</li></ul><pre><code>  debounceSearch = debounce(dispatch({      type: 'car/comlist',      payload: {        level1Type: '半导体',      },    }), 1500)</code></pre><p>直接将<code>dispatch</code>传了进去，然后后面发请求就一直报<code>fn is undefined</code> ，稍微想了一下<code>dispatch</code>不是一个<code>function</code>，然后直接用一个函数去包裹它，在加上参数的传入😁</p><pre><code> debounceSearch = debounce((args) =&gt; dispatch({      type: 'car/comlist',      payload: {        level1Type: '半导体',        ...args      },    }), 1500)</code></pre><ul><li>项目用的前端框架是React，但没有使用Class，全部用React Hook（函数是一等公民😂），我对React Hook不是很熟悉，<code>debounceSearch</code>需要在DOM加载完之后就要生成，对于React的生命周期是<code>componentDidMount</code> ，其实在<code>componentWillMount</code>也是可以的，但这个生命周期要被废弃了，不推荐使用。在React Hook里面使用<code>useEffect</code>可以代替<code>componentDidMount</code> 和 <code>componentDidUpdate</code></li></ul><pre><code> debounceSearch = debounce((args) =&gt; dispatch({      type: 'car/comlist',      payload: {        level1Type: '半导体',        ...args      },    }), 1500)</code></pre><p>Bingo，<code>debounce</code>已经结束了</p><h2 id="throttle-节流"><a href="#throttle-节流" class="headerlink" title="throttle(节流)"></a>throttle(节流)</h2><blockquote><p>使用场景：在秒杀活动中，快到时间的时候就会一直点点点，希望可以抢到心怡的东西，如果每点一次就发一次请求的话，服务器肯定受不了，throttle这时候就展现它的用处了，它会按照一定的时间间隔发请求，这样就可以减轻服务器压力，另外的一个效果是你的点击不是每一次都有用</p></blockquote><p>分析一下<code>throttle</code>需要实现的功能:</p><ul><li>按照一定的时间间隔去处理特定动作</li></ul><p>上代码</p><pre><code> function throttle (fn, delayTime) {        let last, timeOut        return function () {            let args = arguments            let now = new Date()            if (last &amp;&amp; now - last &lt; delayTime) {                clearTimeout(timeOut)                timeOut = setTimeout(function () {                    last = now                    fn.apply(this, args)                }, delayTime)            } else {                last = now                fn.apply(this, args)            }        }    }</code></pre><p>实现效果：</p><p><img src="4.gif" alt=""></p><p>虽然我一直点点点，但它还是按照规定的时间间隔处理</p><p>所有的代码已经放到我的<a href="https://github.com/muyeyong/-algorithm-javascript/tree/master/%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/%E6%8A%96%E5%8A%A8%E8%8A%82%E6%B5%81">github</a> 上去了</p><h2 id="如果你不想写的话"><a href="#如果你不想写的话" class="headerlink" title="如果你不想写的话"></a>如果你不想写的话</h2><p><code>Lodash</code>里面都要实现：</p><p><a href="https://www.lodashjs.com/docs/lodash.debounce" target="_blank" rel="noopener">debounce</a> </p><p><a href="https://www.lodashjs.com/docs/lodash.throttle" target="_blank" rel="noopener">throttle</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抖动节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-初识</title>
      <link href="/2020/07/13/vue-chu-shi/"/>
      <url>/2020/07/13/vue-chu-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue初识"><a href="#Vue初识" class="headerlink" title="Vue初识"></a>Vue初识</h1><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p><img src="Vue-%E5%88%9D%E8%AF%86/Snipaste_2020-07-13_11-37-57.png" alt=""></p><p>这些标签名的含义？</p><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p><strong>引入component</strong></p><p>这些字段的含义？</p><p>name</p><p>components</p><p>data</p><p>mounted</p><p>methods</p><h3 id="style-样式"><a href="#style-样式" class="headerlink" title="style 样式"></a>style 样式</h3><hr><p><code>v-xxx</code> 指令： 使用<code>v-xxx = '***'</code> ,赋值是使用字符串</p><pre><code>v-bindv-ifv-for：遍历datav-on: 添加事件监听器v-model:实现表单输入和应用状态之间的双向绑定</code></pre><p><code>组件</code></p><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例</p><p>Vue.component(‘组件名’,{…}) //中括号里面是一个对象</p><p>//属性         说明<br>//template      渲染模板，是html<br>//props          外部传入参数，数组类型</p><pre><code>new Vue({...})//中括号里面放的是一个对象//属性     //说明//el       vue需要绑定的dom元素的 className/id//data       可渲染的数据</code></pre><hr><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><blockquote><p>指令的预期值是单个JavaScript表达式（v-for除外）。有一些指令可以接收’’参数’’，在指令名称之后以冒号表示</p></blockquote><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>将元素节点的attribute和Vue实例的property保持一致，主要用于属性绑定。</p><p><img src="Vue-%E5%88%9D%E8%AF%86/Snipaste_2020-07-13_20-17-09.png" alt=""></p><p>span有title标签？ 悬停效果是怎么实现的？</p><h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]="url"&gt; ... &lt;/a&gt;</code></pre><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>控制dom元素的出现与消失</p><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>遍历待渲染的数据，尽量使用v-for提供的<code>key</code> attribute。组件上使用v-for,key是必须的，如果想要将v-for遍历的数据注入到组件里面，需要使用组件的props（用<code>v-bind</code>绑定注入）</p><pre><code>//可以使用in/of来遍历v-for = "item in/of items"//遍历数组时,可选第二个参数代表遍历的下标v-for = "(item,index) in/of array"//遍历对象时，可选三个参数（value，key/property，index）v-for = "(value,key,index) in obj"</code></pre><p>使用index作为<code>key</code> 时，在同一个class/function里，是不是存在渲染问题？</p><p><a href="https://cn.vuejs.org/v2/guide/list.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/list.html</a> vue-在组件上使用for中</p><pre><code>ul &gt; li is='组件名' ， 这样写的必要性？</code></pre><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>添加事件监听器，跟React的合成事件差不多？</p><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]="doSomething"&gt; ... &lt;/a&gt;</code></pre><p>如果需要访问原生的DOM事件，可以使用特殊变量<code>$event</code>把它传入方法</p><pre><code>&lt;button v-on:click="warn('Form cannot be submitted yet.', $event)"&gt;  Submit&lt;/button&gt;</code></pre><pre><code>methods: {  warn: function (message, event) {    // 现在我们可以访问原生事件对象    if (event) {      event.preventDefault()    }    alert(message)  }}</code></pre><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><blockquote><p>修饰符是由点开头的指令后缀来表示，修饰符可以串联使用</p></blockquote><p>方法只有纯粹的逻辑判断，不去处理DOM的细节</p><ul><li>.stop</li></ul><p>同event.stopPropagation()，阻止冒泡</p><ul><li>.prevent</li><li>.capture</li></ul><p>使用事件捕获模式，内部事件触发的事件先在父元素处理，然后交给内部元素处理</p><p>（对于捕获和冒泡的疑惑，会一直传递到顶端DOM？）</p><ul><li>.self</li><li>.once</li><li>.passive</li></ul><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><pre><code>&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter="submit"&gt;</code></pre><p>你可以直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values" target="_blank" rel="noopener"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p><p>Vue提供常见的key的别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>你还可以通过全局 <code>config.keyCodes</code> 对象<a href="https://cn.vuejs.org/v2/api/#keyCodes" target="_blank" rel="noopener">自定义按键修饰符别名</a>：</p><pre><code>// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112</code></pre><h4 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h4><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><blockquote><p>可以用在表单 <code>&lt;input&gt;</code>、<code>textarea</code>以及<code>select</code>元素上创建双向绑定，它会根据控件的类型自动选取正确的方法来更新元素。</p></blockquote><p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul><li>.lazy</li><li>.number</li><li>.trim</li></ul><h3 id="指令动态参数"><a href="#指令动态参数" class="headerlink" title="指令动态参数"></a>指令动态参数</h3><p>用方括号括起来的JavaScript表达式作为一个指令的参数</p><pre><code>&lt;a v-on:[eventName]="doSomething"&gt; ... &lt;/a&gt;</code></pre><h2 id="指令的搭配使用"><a href="#指令的搭配使用" class="headerlink" title="指令的搭配使用"></a>指令的搭配使用</h2><h3 id="v-if-和-v-for"><a href="#v-if-和-v-for" class="headerlink" title="v-if 和 v-for"></a><code>v-if</code> 和 <code>v-for</code></h3><p>不推荐在同一元素上使用 v-if 和 v-for。当</p><h2 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h2><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例</p><pre><code>//注册组件Vue.component('组件名',{...})</code></pre><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="创建vue实例"><a href="#创建vue实例" class="headerlink" title="创建vue实例"></a>创建vue实例</h3><pre><code>var vm = new Vue({    选项对象})</code></pre><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p>当Vue实例被创建时，<code>data</code>对象中的property加入到Vue的响应式布局中去，property发生变化，视图也会产生相应。（Vue实例可以通过<code>Vue实例.property访问data对象中的property</code>）但对于在Vue实例创建后加入的property不会加入到响应式布局里面去。</p><p><strong>Object.freeze(obj)会阻止obj里面的property的修改</strong></p><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>生命周期钩子的this上下文指向调用它的Vue的实例（不要使用箭头函数）</p><p><img src="Vue-%E5%88%9D%E8%AF%86/2462c823-95ab-4b11-906e-4cf87f6fcd6b.png" alt=""></p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><blockquote><p>常见使用mustache语法（双大括号）</p></blockquote><pre><code>&lt;span&gt;Message: {{ msg }}&lt;/span&gt;</code></pre><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><blockquote><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 <a href="https://cn.vuejs.org/v2/api/#v-html" target="_blank" rel="noopener"><code>v-html</code></a></p></blockquote><h3 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h3><blockquote><p>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 <a href="https://cn.vuejs.org/v2/api/#v-bind" target="_blank" rel="noopener"><code>v-bind</code> 指令</a></p></blockquote><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><blockquote> {{表达式}} ，只能包含单个表达式，不能使用语句和控制流</blockquote><h2 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h2><blockquote><p>computed 可以使用缓存进行返回，方法的每次都需要重新计算</p></blockquote><p>侦听属性（watch） 和 可计算属性的选择？</p><p>​    watch ：当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p><h2 id="状态和维护"><a href="#状态和维护" class="headerlink" title="状态和维护"></a>状态和维护</h2><p>对于被侦听的数组，Vue对一下这些方法进行了包裹：</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice</li><li>sort()</li><li>reverse()</li></ul><p>这些方法都改变了原数组。对于返回新数组的方法，例如 filter()\concat()，可以使用返回的新数组进行替换。</p><h2 id="渲染多个元素内容"><a href="#渲染多个元素内容" class="headerlink" title="渲染多个元素内容"></a>渲染多个元素内容</h2><p>可以使用<code>template</code>将需要渲染的元素包裹起来。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h3><p>data是函数的话，可以让每一个组件实例维护一份返回对象的拷贝</p><h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><blockquote><p>React里面是通过回掉函数完成的</p></blockquote><p>父组件通过props向子组件传入一个函数（v-on监听），子组件通过调用内建的<code>$emit</code>方法并传入事件名称来触发一个事件，<code>$emit</code>方法可以向上传递（抛出值），<code>$emit(props name,抛出参数1,抛出参数2,...)</code>，父组件可以使用<code>$event</code>访问，如果处理函数是一个方法，抛出的参数就以形参的形式传入</p><h2 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h2><ul><li>全局注册</li><li>局部组册</li></ul><p>基础组件全局组册： <a href="https://cn.vuejs.org/v2/guide/components-registration.html（需要练习）" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components-registration.html（需要练习）</a></p><h3 id="插槽分发事件"><a href="#插槽分发事件" class="headerlink" title="插槽分发事件"></a>插槽分发事件</h3><p><code>&lt;slot&gt;&lt;/slot&gt;</code></p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><pre><code>&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt; &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;</code></pre><p>​    <code>is</code>也可以用来绑定dom元素</p><h3 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h3><p>​    使用全小写，单词之间使用短横线(-)隔开: <code>my-first-component</code></p><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><h4 id="Prop类型"><a href="#Prop类型" class="headerlink" title="Prop类型"></a>Prop类型</h4><pre><code>props: {  title: String,  likes: Number,  isPublished: Boolean,  commentIds: Array,  author: Object,  callback: Function,  contactsPromise: Promise // or any other constructor}</code></pre><pre><code>Vue.component('my-component', {  props: {    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)    propA: Number,    // 多个可能的类型    propB: [String, Number],    // 必填的字符串    propC: {      type: String,      required: true    },    // 带有默认值的数字    propD: {      type: Number,      default: 100    },    // 带有默认值的对象    propE: {      type: Object,      // 对象或数组默认值必须从一个工厂函数获取      default: function () {        return { message: 'hello' }      }    },    // 自定义验证函数    propF: {      validator: function (value) {        // 这个值必须匹配下列字符串中的一个        return ['success', 'warning', 'danger'].indexOf(value) !== -1      }    }  }})</code></pre><p>prop会在一个组件创建之前就进行验证，实例中的property（data，computed等）在<code>default</code>和 <code>validator</code>函数中是不可用的</p><p>type类型：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><p>也可以是自定义的构造函数</p><h4 id="传递动态的值"><a href="#传递动态的值" class="headerlink" title="传递动态的值"></a>传递动态的值</h4><p>通过v-bin传递动态值</p><pre><code>&lt;blog-post v-bind:title="post.title"&gt;&lt;/blog-post&gt;</code></pre><p>v-bind即使绑定的是一个动态的值，也是为了告诉vue这是一个JavaScript表达式，而不是字符串</p><p>v-bind可以带参数： <code>v-bind:name = "person.name"</code> 也可以不带参数，<code>v-bind="person"</code> 传入整个对象</p><h4 id="禁用Attribute继承（不是很懂）"><a href="#禁用Attribute继承（不是很懂）" class="headerlink" title="禁用Attribute继承（不是很懂）"></a>禁用Attribute继承（不是很懂）</h4><p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h4><p><code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p><p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名（不是说方法名）</strong>。</p><h4 id="自定义组件的v-model-不是很懂"><a href="#自定义组件的v-model-不是很懂" class="headerlink" title="自定义组件的v-model(不是很懂)"></a>自定义组件的<code>v-model</code>(不是很懂)</h4><h4 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h4><ol><li>可以使用<code>v-on</code>的<code>.native</code> 修饰符，但对于组件的子元素不能生效（比如想要使用原生的onFocus，但是监听的元素不是父组件，这时onFocur不会生效）</li><li>使用 <code>$listeners</code> property，它是一个对象，里面包含了作用在这个组件上的所有监听器。</li></ol><h4 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h4><pre><code>&lt;text-document  v-bind:title="doc.title"  v-on:update:title="doc.title = $event"&gt;&lt;/text-document&gt;</code></pre><p>可替代为</p><pre><code>&lt;text-document v-bind:title.sync="doc.title"&gt;&lt;/text-document&gt;</code></pre><p>不能用在表达式上</p><h3 id="访问子组件或子元素"><a href="#访问子组件或子元素" class="headerlink" title="访问子组件或子元素"></a>访问子组件或子元素</h3><p>通过<code>ref</code>这个attribute为子组件赋予一个ID的引用，<code>ref</code>跟<code>v-for</code>一起使用的时候，得到的<code>ref</code>将会是一个包含了对应数据源这些子组件的数组，<code>$ref</code>只会在组件渲染完成之后生效，并且他不是响应式的。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><code>provide</code>：允许将指定的数据/方法提供给后代</p><pre><code>provide: function () {  return {    getMap: this.getMap  }}</code></pre><p><code>inject</code>：子组件接收想要添加在实例上的property</p><pre><code>inject: ['getMap']</code></pre><h3 id="组件间的循环引用"><a href="#组件间的循环引用" class="headerlink" title="组件间的循环引用"></a>组件间的循环引用</h3><p>两个组件间的相互引用（互为对方的后代和祖先），如果是在全局注册的时候没有问题，如果你使用一个<em>模块系统</em>依赖/导入组件，就会遇到问题，解决的思路是将首次为儿子的组件，晚点加载，使用</p><p><code>beforeCreate</code>或者<code>webpack</code>的异步<code>import</code></p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：</p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><h3 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h3><p><code>transition</code>包裹组件，指定过渡样式</p><ul><li>条件渲染 (使用 <code>v-if</code>)</li><li>条件展示 (使用 <code>v-show</code>)</li><li>动态组件</li><li>组件根节点</li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>给你个dom创建一个vue的实例，这个dom</li><li>v-bind v-model有啥区别</li></ul><blockquote><pre><code>&lt;input v-model="searchText"&gt;</code></pre><p>等价于：</p><pre><code>&lt;input  v-bind:value="searchText"  v-on:input="searchText = $event.target.value"&gt;</code></pre></blockquote><p>也就是说，v-model === v-on + v-bind</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue-初识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-教程练习</title>
      <link href="/2020/07/09/react-jiao-cheng-lian-xi/"/>
      <url>/2020/07/09/react-jiao-cheng-lian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="React-教程练习"><a href="#React-教程练习" class="headerlink" title="React-教程练习"></a>React-教程练习</h1><h2 id="需要实现的目标"><a href="#需要实现的目标" class="headerlink" title="需要实现的目标"></a>需要实现的目标</h2><ol><li>react官方上的知识练习</li><li>mock的练习</li><li>react-router 练习</li><li>Eslint代码规范</li><li>Mobox redux 状态管理练习</li></ol><hr><p>2020/07/02</p><p>支持TS</p><blockquote><p>yarn add @types/react</p><p>yarn add @types/react-dom</p></blockquote><p>使用Mobox</p><blockquote><p>npm install mobx –save</p><p>npm install mobx-react –save</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-大纲</title>
      <link href="/2020/07/09/react-da-gang/"/>
      <url>/2020/07/09/react-da-gang/</url>
      
        <content type="html"><![CDATA[<h2 id="setState是不是异步"><a href="#setState是不是异步" class="headerlink" title="setState是不是异步"></a>setState是不是异步</h2><blockquote><p>有时表现异步有时表现同步</p></blockquote><p>合成事件和钩子函数中是异步，原生事件和<code>setTimeout</code>中是同步</p><p> 合成事件？ 原生事件？</p><p>如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</p><p> SyntheticEvent ： 跨浏览器原生事件包装器</p><p> 在事件回调被调用后，<code>SyntheticEvent</code> 对象将被重用并且所有属性都将被取消</p><p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。</p><p><img src="1.png" alt=""></p><p>target 和 currentTarget 的区别 ？</p><p>浏览器事件过程： 捕获 - 目标 - 冒泡 ？</p><h2 id="React中获取DOM节点"><a href="#React中获取DOM节点" class="headerlink" title="React中获取DOM节点"></a>React中获取DOM节点</h2><ul><li>ReactDom.findDOMNode(component)（React组件的引用）</li></ul><pre><code>//引入import ReactDOM from 'react-dom'//使用componentDidMount(){    const dom = ReactDOM.findDOMNode(this);    // this为当前组件的实例}render() {}</code></pre><ul><li>refs用于React组件内子组件的引用</li></ul><pre><code>// ref方法&lt;div ref={ref=&gt; this.div = ref} /&gt;    //通过this.div获取//refs方法&lt;div ref='div' /&gt;    //通过this.refs.div获取//React.creatRef()this.div = React.createRef() //constructor&lt;div ref={this.div} /&gt; //render  通过this.div获取</code></pre><h2 id="组件-逻辑的复用"><a href="#组件-逻辑的复用" class="headerlink" title="组件/逻辑的复用"></a>组件/逻辑的复用</h2><ul><li><p>高阶组件（不是特别清晰了）</p><p>属性代理</p><p>反向继承</p></li></ul><p>组件将props转换成UI，高阶组件将组件转换成另一个组件</p><ul><li>渲染属性（Render Props）/ 容器组件</li><li>react-hooks</li></ul><h2 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h2><ul><li>Store</li><li>State</li><li>Action</li><li>Reducer</li><li>dispatch</li></ul><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><ul><li>Provider</li><li>connect</li></ul><h2 id="redux-和-mobx的区别"><a href="#redux-和-mobx的区别" class="headerlink" title="redux 和 mobx的区别"></a>redux 和 mobx的区别</h2><p><strong>两者对比:</strong></p><ul><li>redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中</li><li>redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作</li><li>redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改</li><li>mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li><li>mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li></ul><p><strong>场景辨析:</strong></p><p>基于以上区别,我们可以简单得分析一下两者的不同使用场景.</p><p>mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.</p><p>redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.</p><p>mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.</p><p>当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来用.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大纲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-Promise</title>
      <link href="/2020/06/16/javascript-promise/"/>
      <url>/2020/06/16/javascript-promise/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>promise.resove()–&gt; 产生一个promise对象</p><p>resolve()、reject()并不停止Promise，可使用<code>return resolve(...) 或 return reject(...)</code></p><p>建议不要再<code>then()</code>方法里面定义Reject的回调函数，使用catch()</p><p>catch()返回的也是一个Promise对象，可以在之后使用<code>then()</code></p><p>finally()的回调不接受任何参数，不依赖于Promise的执行结果，finally()相当于then的特例</p><p>all()接受一个数组或者具有Interator接口且成员是Promise的实例（如果不是Promise的实例，会调用Promise.resolve()方法，将参数转为Promise参数）的参数，当参数的所有状态变成resolve，Promise.all()的状态才变成resolve，返回值是每个成员返回的resolve()。当有一个参数的状态变成reject，Promise.all()就会变成reject，返回值是第一个被reject的实例的返回值。对于异常的捕捉如果成员有catch方法据不会传递到Promise.all().catch()。</p><p>rece()跟all()差不多，但是只要有一个状态发生变化，rece()的状态就会发生变化。</p><hr><p>Promise.prototype.then()</p><p>Promise.prototype.catch()</p><p>Promise.prototype.finally()</p><p>Promise.prototype.all()</p><p>Promise.prototype.race()</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-发布订阅模式</title>
      <link href="/2020/06/16/she-ji-mo-shi-fa-bu-ding-yue-mo-shi/"/>
      <url>/2020/06/16/she-ji-mo-shi-fa-bu-ding-yue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-发布订阅模式"><a href="#设计模式-发布订阅模式" class="headerlink" title="设计模式-发布订阅模式"></a>设计模式-发布订阅模式</h1><p>emit：发布</p><p>on：订阅 先订阅再发布，改变顺序使用</p><p>埋点？</p><p>过度使用？</p><h2 id="什么是发布订阅模式"><a href="#什么是发布订阅模式" class="headerlink" title="什么是发布订阅模式"></a>什么是发布订阅模式</h2><p> 家有喜事，当然要大家一起庆祝，<del>顺便收份子钱</del>，于是我打开了通讯录，向亲朋好友发布这个好消息。讲完了吗？ 是的，哈哈哈，这就是发布订阅模式，我发布一个消息，订阅这个消息的人收到了通知。</p><h2 id="写一个简单的发布订阅事件"><a href="#写一个简单的发布订阅事件" class="headerlink" title="写一个简单的发布订阅事件"></a>写一个简单的发布订阅事件</h2><p>js</p><pre class=" language-js"><code class="language-js">yourMessage <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>yourMessage<span class="token punctuation">.</span>messageList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>yourMessage<span class="token punctuation">.</span>on <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    yourMessage<span class="token punctuation">.</span>messageList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>yourMessage<span class="token punctuation">.</span>emit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> yourMessage<span class="token punctuation">.</span>messageList<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用call 和 使用 bind 不一样</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>yourMessage<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log(Object.prototype.toString.call(name1))</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`欢迎, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>yourMessage<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'哈哈哈'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>yourMessage<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'花大姐'</span><span class="token punctuation">,</span> <span class="token string">'马达话'</span><span class="token punctuation">)</span>yourMessage<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'勤大妈'</span><span class="token punctuation">)</span></code></pre><p>输出结果：</p><p><img src="Snipaste_2020-06-22_19-30-43.png" alt="img"></p><p>额外插播一点： 上面的代码里面说到，使用 <code>call</code> 和 使用 <code>apply</code>是不一样的，上面的运行结果是使用<code>apply</code>的运行结果，我们看一下使用<code>call</code>的运行结果：</p><p><img src="Snipaste_2020-06-22_19-34-43.png" alt="img"></p><p>对于结果不一样，我说下自己的见解，<code>apply</code> 和 <code>call</code> 接收参数的形式不一样，<code>apply</code>以数组的形式接收参数，<code>call</code>接收的是一系列参数，<code>arguments</code>是类数组类型，用<code>call</code>去接收会把整个类数组传过去，用<code>apply</code>接收传给<code>function</code>，<code>function</code>接收的时候可以以解构的方式去赋值给形参。</p><p>这个栗子中，只要订阅就会把所有消息发布一次，但是有时候订阅者并不想听到你所有的消息，这时候就需要改进一下。</p><h2 id="改进一下上面的栗子"><a href="#改进一下上面的栗子" class="headerlink" title="改进一下上面的栗子"></a>改进一下上面的栗子</h2><p>js</p><pre class=" language-js"><code class="language-js">yourMessage <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>yourMessage<span class="token punctuation">.</span>messageList <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>yourMessage<span class="token punctuation">.</span>on <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>messageList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>messageList<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>messageList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>yourMessage<span class="token punctuation">.</span>emit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> key <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>messageList<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>messageList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>messageList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>yourMessage<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'欢迎'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`欢迎, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>yourMessage<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'哈哈'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`哈哈，</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>yourMessage<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'欢迎'</span><span class="token punctuation">,</span> <span class="token string">'马达话'</span><span class="token punctuation">)</span>yourMessage<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'哈哈'</span><span class="token punctuation">,</span> <span class="token string">'勤大妈'</span><span class="token punctuation">)</span></code></pre><p><img src="Snipaste_2020-06-22_20-36-31.png" alt="img"></p><h2 id="再改进一下栗子"><a href="#再改进一下栗子" class="headerlink" title="再改进一下栗子"></a>再改进一下栗子</h2><p>新增取消订阅和一次订阅</p><p>js</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> eventEmitter <span class="token operator">=</span> <span class="token punctuation">{</span>    list<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//订阅</span>    <span class="token function">on</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//发布</span>    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> key <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//一次订阅</span>    <span class="token function">once</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> on <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//一次性订阅只需要把传入的订阅事件包装一下</span>            fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//取消订阅</span>    <span class="token function">off</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fn <span class="token operator">===</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'One '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Two '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">}</span>eventEmitter<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">,</span> fn1<span class="token punctuation">)</span><span class="token punctuation">;</span>eventEmitter<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">,</span> <span class="token string">'哈哈哈'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//eventEmitter.off('listen', fn1);</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">,</span> <span class="token string">'哈哈哈'</span><span class="token punctuation">)</span></code></pre><h2 id="关于发布订阅事件的顺序"><a href="#关于发布订阅事件的顺序" class="headerlink" title="关于发布订阅事件的顺序"></a>关于发布订阅事件的顺序</h2><p>前面实现的发布订阅都需要先订阅再发布，才可以收到消息，这次我们来实现一个可以支持先发布再订阅的发布订阅，也就是可以支持历史信息的订阅。</p><p>js</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//改变发布订阅顺序</span><span class="token keyword">let</span> eventEmitter <span class="token operator">=</span> <span class="token punctuation">{</span>  list<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  cached<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//订阅</span>  <span class="token function">on</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//防止多次订阅</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cached<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> content<span class="token punctuation">;</span> content <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cached<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//发布</span>  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> key <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>cached<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cached<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cached<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//一次订阅</span>  <span class="token function">once</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> on <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//取消订阅</span>  <span class="token function">off</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>fn <span class="token operator">===</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'One '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Two '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">}</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">,</span> <span class="token string">'哈哈哈'</span><span class="token punctuation">)</span>eventEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">,</span> fn1<span class="token punctuation">)</span><span class="token punctuation">;</span>eventEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//eventEmitter.off('listen', fn1);</span><span class="token comment" spellcheck="true">//eventEmitter.emit('listen', '哈哈哈')</span></code></pre><p>运行结果：</p><p><img src="Snipaste_2020-06-23_20-41-09.png" alt="img"></p><h2 id="其实还有优化的空间。。。。。。"><a href="#其实还有优化的空间。。。。。。" class="headerlink" title="其实还有优化的空间。。。。。。"></a>其实还有优化的空间。。。。。。</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发布订阅模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-宏任务、微任务 和 EventLoop</title>
      <link href="/2020/06/16/javascript-hong-ren-wu-wei-ren-wu-he-event-loop/"/>
      <url>/2020/06/16/javascript-hong-ren-wu-wei-ren-wu-he-event-loop/</url>
      
        <content type="html"><![CDATA[<h1 id="宏任务、微任务-和-EventLoop"><a href="#宏任务、微任务-和-EventLoop" class="headerlink" title="宏任务、微任务 和 EventLoop"></a>宏任务、微任务 和 EventLoop</h1><h2 id="让我们来讲一个小故事"><a href="#让我们来讲一个小故事" class="headerlink" title="让我们来讲一个小故事"></a>让我们来讲一个小故事</h2><p> 6月份在火辣辣的长沙，走在热浪滔天的五一广场，口干舌燥，想来一杯冰凉凉的奶茶，但买奶茶的人特别多，作为一个文明人，我当然选择排队。前面有一个火辣辣的美眉，她点了一杯波霸珍珠奶茶，然后到取餐区等奶茶制作完，但她突然想加一点料，就跟店员说，加一份芋圆，店员为了响应她的要求，不得不延迟对后面排队人的服务，这时美眉又说加一份葡萄干，服务员又进行响应，延迟+2，经过若干这样的交流（延迟+n），美眉回到了取餐区了。<del>我突然感慨，奶茶真好看</del>。</p><p> 在这个故事中，假设奶茶店只有两名员工，一名制作奶茶，一名接待客户。对于接待客户的那名员工来说，每个客户的点单过程可以看成是一个<code>同步任务</code>（可以想象成可以立马完成），但等待奶茶制作时间相对较多，客户需要到取餐区等待，可以将它看成一个<code>异步任务（宏任务）</code>。对于客户提出的其它要求，就像上面的加料，服务员不能说让她到后面去排队，而是满足她的要求，这些要求是在进行<code>异步任务（宏任务）</code>的时候加进去的，可以将它看成<code>微任务</code>，没有完成当前客户的 <code>微任务</code>之前，不会处理下一位客户的需求 ，而<code>微任务</code>会在<code>宏任务</code>之前执行，就像加料（<code>微任务</code>）会在整杯奶茶制作（<code>宏任务</code>）完之前完成。对于后面的每一个客户都会这样处理，就形成了<code>Event Loop</code>。</p><p> <strong>总结一下：</strong>当执行一段代码的时候，先执行同步代码块，当遇到<code>微任务</code>就把它放到<code>微任务队列</code>中去，当遇到<code>宏任务</code>就放到<code>宏任务队列</code>里面去，当同步代码块执行完毕后，就去检查<code>微任务队列</code>，执行完全部微任务，当微任务执行完后，就去检查<code>宏任务队列</code>，执行全部宏任务，这就是一轮<code>Event Loop</code>。</p><p> <strong>注意：</strong> 在执行<code>宏任务</code>的时候可以添加<code>微任务</code>，毕竟我也喜欢加料。</p><p><img src="cde525c2-e5e6-49fa-9387-a8d470677056.png" alt=""></p><p> <strong>插播一下其他人的理解：</strong></p><blockquote><p>一个掘金的老哥（ssssyoki）的文章摘要： 那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p></blockquote><h2 id="什么是宏任务"><a href="#什么是宏任务" class="headerlink" title="什么是宏任务"></a>什么是宏任务</h2><p> macrotask，也叫 tasks，主要的工作如下</p><ul><li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li><li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li><li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收</li></ul><p>一些异步任务的回调会以此进入 <code>macrotask queue(宏任务队列)</code>，等等后续被调用，这些异步函数包括：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate (Node)</li><li>requestAnimationFrame (浏览器)</li><li>I/O</li><li>UI rendering (浏览器)</li></ul><h2 id="什么是微任务"><a href="#什么是微任务" class="headerlink" title="什么是微任务"></a>什么是微任务</h2><p> microtask，也叫 jobs，主要的工作如下</p><ul><li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li><li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li><li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li></ul><p>另一些异步回调会进入 <code>microtask queue(微任务队列)</code> ，等待后续被调用，这些异步函数包括：</p><ul><li>process.nextTick (Node)</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul><blockquote><p>这里有一点需要注意的：<code>Promise.then()</code> 与 <code>new Promise(() =&gt; {}).then()</code> 是不同的，前面的是一个微任务，后面的 <code>new Promise()</code> 这一部分是一个构造函数，这是一个同步任务，后面的 <code>.then()</code> 才是一个微任务，这一点是非常重要的。</p></blockquote><h2 id="什么是Event-Loop"><a href="#什么是Event-Loop" class="headerlink" title="什么是Event Loop"></a>什么是Event Loop</h2><p>Event Loop 是一个数据结构，用于等待和发送消息和事件，在不同的地方有不同的实现。</p><h2 id="来上代码"><a href="#来上代码" class="headerlink" title="来上代码"></a>来上代码</h2><h3 id="在浏览器中的表现"><a href="#在浏览器中的表现" class="headerlink" title="在浏览器中的表现"></a>在浏览器中的表现</h3><ul><li><p>示例一</p><pre><code>setTimeout( () =&gt; console.log(4))new Promise(resolve =&gt; {  resolve()  console.log(1)}).then( () =&gt; {  console.log(3)})Promise.resolve(5).then(() =&gt; console.log(5))console.log(2)</code></pre><p> 我们直接在浏览器里面运行这段代码：</p><p><img src="Snipaste_2020-06-17_11-47-04.png" alt=""></p><p>分析一下代码的运行：</p><p>第一轮<code>event loop</code>，整体代码（script）作为一个宏任务</p><p> <strong>执行同步代码，注册宏任务、微任务</strong></p><p> <code>setTimeout</code> 是异步代码，注册宏任务，放入宏任务队列</p><p> <code>new promise(...)</code>构造函数是同步代码，输出 1，<code>.then()</code>，注册微任务，放入微任务队列</p><p> <code>Promise.resolve().then(...)</code>，注册微任务，放入微任务队列</p><p> <code>console.log()</code>同步代码输出 2</p><p> <strong>执行微任务</strong></p><p> 执行<code>new Promise().then(...)</code>的微任务，输出 3</p><p> 执行<code>Promise.resolve().then(...)</code>的微任务，输出 5</p><p> 微任务全部执行完成，第一轮 <code>event loop</code>完成</p><p>第二轮<code>event loop</code>，取出宏任务队列的宏任务</p><p> 执行<code>setTimeout(...)</code>，输出 4</p></li><li><p>示例二</p><p>在线示例：<a href="https://codesandbox.io/s/interesting-tesla-w1xtr?file=/index.js" target="_blank" rel="noopener">https://codesandbox.io/s/interesting-tesla-w1xtr?file=/index.js</a></p><pre><code>//index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;script src="./index.js"&gt;&lt;/script&gt;  &lt;style&gt;    #outer {      padding: 20px;      background: pink;    }    #inner {      width: 200px;      height: 200px;      line-height: 200px;      text-align: center;      background: skyblue;    }  &lt;/style&gt;  &lt;title&gt;宏任务、微任务&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id="outer"&gt;    &lt;div id="inner"&gt;爱我你就点点我&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>//index.jswindow.onload = function () {  const $inner = document.getElementById('inner')  const $outer = document.getElementById('outer')  function handler() {    console.log('click') // 直接输出    Promise.resolve().then(_ =&gt; console.log('promise')) // 注册微任务    setTimeout(_ =&gt; console.log('timeout')) // 注册宏任务   //页面重绘之前做的操作    requestAnimationFrame(_ =&gt; console.log('animationFrame')) // 注册宏任务    $outer.setAttribute('data-random', Math.random()) // DOM属性修改，触发微任务  }  new MutationObserver(_ =&gt; {  //监听DOM树进行的更改    console.log('observer')  }).observe($outer, {    attributes: true  })  $inner.addEventListener('click', handler)  $outer.addEventListener('click', handler)}</code></pre><p><img src="1.gif" alt=""></p><p>浏览器输出：</p><p><img src="Snipaste_2020-06-17_19-57-17.png" alt=""></p><p>分析一下结果：</p><p> <code>click</code> -&gt;<code>promise</code>-&gt;<code>observer</code> 两次同样的输出是因为事件冒泡</p></li></ul><h3 id="在node中的表现"><a href="#在node中的表现" class="headerlink" title="在node中的表现"></a>在node中的表现</h3><p> <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">Node</a> 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现。</p><p> <strong>libuv引擎中事件循环的六个阶段</strong></p><p><img src="Snipaste_2020-06-19_20-45-56.png" alt="img"></p><h4 id="setImmediate-和-setTimeout"><a href="#setImmediate-和-setTimeout" class="headerlink" title="setImmediate 和 setTimeout"></a>setImmediate 和 setTimeout</h4><p> <code>setTimeout</code>的回调函数在check阶段执行，<code>setTimeout</code>的回调函数执行的条件是<code>poll</code>阶段是空闲，且达到设定时间在<code>timer</code>阶段执行。这两个函数的执行，先后顺序不一样。</p><p>javascript</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> timeout <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span> immediate <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 但如果在<code>i/o</code>操作中执行，一定是<code>setImmediate</code>先执行，是因为<code>poll</code>阶段执行的是<code>i/o</code>操作，接下来就是<code>check</code>阶段。</p><p>javascript</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><img src="Snipaste_2020-06-19_20-54-29.png" alt="img"></p><h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h4><p> 这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p><ul><li><p>栗子一</p><pre><code>let bar;function someAsyncApiCall(callback) { callback(); }someAsyncApiCall(() =&gt; {  console.log('bar', bar); // undefined});bar = 1;</code></pre><p>js</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> bar<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">someAsyncApiCall</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">someAsyncApiCall</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>第一个代码会输出，<code>undifined</code>，第二个代码会输出<code>1</code>，是因为 <code>process.nextTic</code>会等待当前操作完之后在执行，也就是等到第二个代码中的赋值操作完成之后在执行回调函数。</p></li><li><p>栗子二</p><pre><code>setTimeout(() =&gt; { console.log('timer1') Promise.resolve().then(function() {   console.log('promise1') })}, 0)process.nextTick(() =&gt; { console.log('nextTick') process.nextTick(() =&gt; {   console.log('nextTick')   process.nextTick(() =&gt; {     console.log('nextTick')     process.nextTick(() =&gt; {       console.log('nextTick')     })   }) })})// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</code></pre><p>跟第一个栗子有点点区别，在第一个栗子中，都是同步代码块，而第二个栗子中<code>setTimeout</code>中的回调是异步的，它会由于<code>settimeout</code>的回调执行。</p></li></ul><h4 id="关于node-与-浏览器的Event-Loop的区别"><a href="#关于node-与-浏览器的Event-Loop的区别" class="headerlink" title="关于node 与 浏览器的Event Loop的区别"></a>关于node 与 浏览器的Event Loop的区别</h4><p> 最新的node版本，在运行结果上跟浏览器运行结果是一样的，网上说这两者之间运行存在差异，是因为node版本的问题，更新一下就好了，实测。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经验-computed和do-while的使用</title>
      <link href="/2020/06/08/jing-yan-computed-he-do-while-de-shi-yong/"/>
      <url>/2020/06/08/jing-yan-computed-he-do-while-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="computed和do-while的使用"><a href="#computed和do-while的使用" class="headerlink" title="computed和do-while的使用"></a>computed和do-while的使用</h1><p>​    这几天一直在改上次live上出的bug（在此表扬下写bug小能手），今天在测试的时候又遇到了一点问题，在此记录一下。</p><h2 id="computed的使用"><a href="#computed的使用" class="headerlink" title="computed的使用"></a>computed的使用</h2><p>​    我们现在用的前端框架是<code>KO</code>（KnockOut，老项目在使用，新项目使用的是React），我要吐槽一下<code>ko</code>(上古框架)，使用<code>ko</code>需要先绑定，当前端页面特别复杂的时候，什么<code>parent</code>、<code>root</code>这些层级结构，让你傻傻分不清，例如下面这个：</p><p><img src="Snipaste_2020-06-08_19-49-36.png" alt=""></p><p>​    parent根本就没有一点语义话的感觉，回到正题。</p><p>​    <code>React</code>里面有可计算属性<code>computed</code>，<code>ko</code>里面也有，通过其它的值去计算当前需要的值。</p><p>​    先介绍一下背景：</p><p><img src="Snipaste_2020-06-10_10-04-24.png" alt=""></p><p><img src="Snipaste_2020-06-10_10-01-11.png" alt=""></p><p>具体的关系如下图：</p><p><img src="Snipaste_2020-06-10_10-13-17.png" alt=""></p><p>现在看起来一切还正常，但是当你选了这个人又不想给他发消息的话，可以将他从发送列表中删除，例如下面这样。</p><p><img src="1.gif" alt=""></p><p>回到代码上的逻辑，最初的写法是：</p><ol><li>先判断当前删除的pill是不是默认的user。</li><li>再判断pill是不是整个大的tab,例如上面的Operation Manager，是的话删除当前tab下所有存在发送列表里面的user。</li><li>最后删除剩下的pill。</li></ol><p>第二步删除里面的用的是<code>do-while</code>，进行操作的。</p><p><img src="Snipaste_2020-06-10_10-30-39.png" alt=""></p><p>但是他取出符合条件的user是随机取得，这里就会出现一个bug，还记得前面的可计算属性吗？<code>imChecked</code>，他会一直遍历整个user列表去执行指定的逻辑。如果他取出的user一直是默认带上的user，发送列表不仅仅存在默认的user，当你从发送列表去除这个默认的user，但是可计算属性通过其它值又把默认的user加上去了，这个时候就有意思了，一个操作是不断的删除，一个操作是一直添加，生成一个完美闭环，然后又遇到<code>do-while</code>，导致一直循环，栈溢出，页面卡死。</p><p>为什么会出现这样的情况？</p><ul><li>考虑不在周全 + 测试也不严谨。</li><li>当使用这种可能会无限循环的语句，需要异常处理（try-catch or 使用标识符跳出 or 其它）。</li><li>从业务角度来说，我觉得设计也是有缺陷的，上面的动图，他突然就出现了默认带上的user（本来是要删除的），默认带上也应该是用户第一次操作带上，而不是每次操作带上。</li></ul><p>东西是好东西，但是注意使用场景。</p><p>我这个小菜鸟太难了。。。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computed 和 do-while的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态模块打包工具-webpack</title>
      <link href="/2020/06/01/jing-tai-mo-kuai-da-bao-gong-ju-webpack/"/>
      <url>/2020/06/01/jing-tai-mo-kuai-da-bao-gong-ju-webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><pre><code>npm  init –y //初始化npmnpm install –-save-dev webpack webpack-cli //安装webpack，webpack-cli是命令行运行//webpacknpm install –-save-dev lodash</code></pre><p>Webpack打包资源的管理：</p><p> （1）：打包入口，对不同资源的打包</p><p> （2）：打包输出，bundle、chunk的概念</p><p> （3）：开发</p><p> （3.1）：使用服务器</p><p> （3.2）：模块热替换</p><p> （3.3）：构建不同的环境</p><p> （3.4）：tree shaking</p><p>（3.5）：代码分离</p><p>（3.6）：懒加载</p><p>（3.7）：缓存</p><h2 id="四个核心概念："><a href="#四个核心概念：" class="headerlink" title="四个核心概念："></a>四个核心概念：</h2><p> 入口（entry）：</p><p> 指示 webpack 应该使用哪个模块，来作为构建其内部<em>依赖图</em>的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的</p><p> Entry接受三种形式的值：字符串、数组和对象</p><p>对象entry：</p><p><img src="1.png" alt="img"></p><p>对象中的每一对属性，都代表一个入口文件。</p><p> Key可以是字符串，对应output.filename配置中的[name],也可以是路径字符串，webpack会自动生成路径目录，并将路径的最后一个作为[name]。</p><p> value如果是字符串，而且必须是合理的noderequire函数参数字符串。比如<strong>文件路径</strong>：’./app.js’(require(‘./app.js’))；比如<strong>安装的npm模块</strong>：’lodash’(require(‘lodash’))。</p><p> value如果是数组，则数组中元素需要是上面描述的合理字符串值。数组中的文件一般是没有相互依赖关系的，但是又处于某些原因需要将它们打包在一起。</p><p> 对于多入口，会建立彼此完全分离、互相独立的依赖图。</p><p>字符串entry：</p><p><img src="2.png" alt="img"></p><p>数组entry：</p><p><img src="3.png" alt="img"></p><p>字符串/字符串数组：</p><p>如果传入一个字符串或字符串数组，chunk 会被命名为 <code>main</code></p><p>出口（output）：</p><p> Output属性告诉webpack在哪里输出它所创建的bundles，以及如何命名这些文件，默认值为./dist。</p><p> 可以存在多个入口，但只指定一个输出配置。</p><p> output.path只是指示输出的目录，对应一个<strong>绝对路径</strong></p><p><strong>明确chunk、bundle和module的概念</strong></p><p> <strong>Webpack把每一个文件看成一个module，对入口module进行递归式打包，chunk是webpack的打包过程，是一堆module的集合，bundle是最终输出的打包文件。Chunk是过程量，bundle是结果量。</strong></p><p><strong>设定</strong> <strong>HtmlWebpackPlugin</strong></p><pre><code>npm install --save-dev html-webpack-plugin</code></pre><h2 id="清理-dist-文件夹"><a href="#清理-dist-文件夹" class="headerlink" title="清理 /dist 文件夹"></a>清理 /dist 文件夹</h2><blockquote><p>npm install clean-webpack-plugin –save-dev</p></blockquote><p><strong>注：在</strong>webpack-dev-server上运行，clean-webpack-plugin会把dist文件夹里面的内容全部清除，但webpack（build）的时候只会删除为使用的。</p><p>尝试补坑：<a href="https://blog.csdn.net/qq_44698161/article/details/102903521（注意clean" target="_blank" rel="noopener">https://blog.csdn.net/qq_44698161/article/details/102903521（注意clean</a> 和 copy plugins使用的顺序）webpack打包顺序？</p><p> 或者根据不同的环境配置使用clean-webpack-plugin</p><p>Loader：</p><p> Loader让webpack能够去处理那些非javascript文件（webpack自生只能理解javascript）。Loader可以将所有类型的文件转换成webpack能够处理的有效模块，再利用webpack进行打包。</p><p>在 webpack 的配置中 <strong>loader</strong> 有两个目标：</p><ol><li>test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li><li>use 属性，表示进行转换时，应该使用哪个 loader。</li></ol><p>每个规则可以分为三部分 - 条件(condition)，结果(result)和嵌套规则(nested rule)</p><h3 id="Rule-条件"><a href="#Rule-条件" class="headerlink" title="Rule 条件"></a><strong>Rule</strong> <strong>条件</strong></h3><p> 条件有两种输入值：</p><ol><li>resource：请求文件的绝对路径。它已经根据 <a href="https://www.webpackjs.com/configuration/resolve" target="_blank" rel="noopener">resolve 规则</a>解析。</li><li>issuer: 被请求资源(requested the resource)的模块文件的绝对路径。是导入时的位置。</li></ol><p>例如: 从 app.js 导入 ‘./style.css’，resource 是 /path/to/style.css. issuer 是 /path/to/app.js。</p><p>在规则中，属性 <a href="https://www.webpackjs.com/configuration/module/#rule-test" target="_blank" rel="noopener">test</a>, <a href="https://www.webpackjs.com/configuration/module/#rule-include" target="_blank" rel="noopener">include</a>, <a href="https://www.webpackjs.com/configuration/module/#rule-exclude" target="_blank" rel="noopener">exclude</a> 和 <a href="https://www.webpackjs.com/configuration/module/#rule-resource" target="_blank" rel="noopener">resource</a> 对 resource 匹配，并且属性 <a href="https://www.webpackjs.com/configuration/module/#rule-issuer" target="_blank" rel="noopener">issuer</a>(这个选项可以用来将 loader 应用到一个特定模块或一组模块的依赖中) 对 issuer 匹配。</p><p>当使用多个条件时，所有条件都匹配</p><h3 id="Rule-结果"><a href="#Rule-结果" class="headerlink" title="Rule 结果"></a>Rule 结果</h3><p>规则结果只在规则条件匹配时使用。</p><p>规则有两种输入值：</p><p>1． 应用的 loader：应用在 resource 上的 loader 数组。</p><ol><li>Parser 选项：用于为模块创建解析器的选项对象。</li></ol><p>这些属性会影响 loader：<code>loader</code>, <code>options</code>, <code>use</code>。</p><h3 id="嵌套的-Rule"><a href="#嵌套的-Rule" class="headerlink" title="嵌套的 Rule"></a>嵌套的 Rule</h3><p>可以使用属性 <code>rules</code> 和 <code>oneOf</code> 指定嵌套规则。</p><p>这些规则用于在规则条件(rule condition)匹配时进行取值。</p><p><em>压缩和优化你的图像。查看</em> <em><a href="https://github.com/tcoopman/image-webpack-loader">image-webpack-loader</a></em> <em>和</em> <em><a href="https://www.webpackjs.com/loaders/url-loader" target="_blank" rel="noopener">url-loader</a>**，以了解更多关于如果增强加载处理图片功能。</em></p><p>插件（plugins）</p><p> 插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。</p><p> 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p><p><img src="4.png" alt="img"></p><p>模式：</p><p> 通过选择 <code>development</code> 或 <code>production</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用相应模式下的 webpack 内置的优化</p><h3 id="Devtool"><a href="#Devtool" class="headerlink" title="Devtool"></a>Devtool</h3><p>此选项控制是否生成，以及如何生成 source map。</p><p><img src="5.png" alt="img"></p><h3 id="解析（resolve）"><a href="#解析（resolve）" class="headerlink" title="解析（resolve）"></a>解析（resolve）</h3><pre><code>resolver 是一个库(library)，用于帮助找到模块的绝对路径。一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：import foo from 'path/to/module'// 或者require('path/to/module')resolve.alias</code></pre><p> 创建 <code>import</code> 或 <code>require</code> 的别名，来确保模块引入变得更简单，也可以在给定对象的键后的末尾添加 <code>$</code>，以表示精准匹配：</p><pre><code>alias: { xyz$: path.resolve(__dirname, 'path/to/file.js')}</code></pre><p>这将产生以下结果：</p><pre><code>import Test1 from 'xyz'; // 精确匹配，所以 path/to/file.js 被解析和导入import Test2 from 'xyz/file.js'; // 非精确匹配，触发普通解析</code></pre><h3 id="resolve-extensions："><a href="#resolve-extensions：" class="headerlink" title="resolve.extensions："></a>resolve.extensions：</h3><p>自动解析确定的扩展。默认值为：</p><pre><code>extensions: [".js", ".json"]</code></pre><p>能够使用户在引入模块时不带扩展：</p><pre><code>import File from '../path/to/file'</code></pre><h3 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a><code>resolve.modules</code></h3><p>告诉 webpack 解析模块时应该搜索的目录。</p><h3 id="开发中-Server-devServer"><a href="#开发中-Server-devServer" class="headerlink" title="开发中 Server(devServer)"></a>开发中 Server(devServer)</h3><pre><code>npm install --save-dev webpack-dev-server</code></pre><p>每次要编译代码时，手动运行 <code>npm run build</code> 就会变得很麻烦。webpack 中有几个不同的选项，可以帮助你在代码发生变化后自动编译代码。<code>webpack-dev-server</code> 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。</p><p>webpack-dev-server主要是启动了一个使用express的Http服务器。它的作用<strong>主要是用来伺服资源文件</strong>。此外这个Http服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会实时的编译，但是最后的编译的文件并没有输出到目标文件夹。</p><p><strong>你启动**</strong>webpack-dev-server<strong><em>\</em>后，你在目标文件夹中是看不到编译后的文件的**</strong>,<strong><em>\</em>实时编译后的文件都保存到了内存当中。</strong></p><p>webpack-dev-server支持2种自动刷新的方式：</p><p>1.Iframe mode</p><p>2.inline mode</p><pre><code>compress: true//启用gzip压缩contentBase: path.join(__dirname, "public")//告诉服务器从哪里提供内容                    hot: true//启用热替换                    lazy: true//dev-server只有在请求的时候才编译包publicPath: "/assets/"          </code></pre><p>HTML不会热更新。只有js，css这些被webpack管理的模块化东西才会热更新。</p><p><a href="https://github.com/gaearon/react-hot-loader">React Hot Loader</a>：实时调整 react 组件</p><p><strong>tree shaking</strong></p><p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的<a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure" target="_blank" rel="noopener">静态结构特性</a>，例如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">import</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener">export</a>。</p><p>在一个纯粹的 ESM 模块世界中，识别出哪些文件有副作用很简单。然而，我们的项目无法达到这种纯度，所以，此时有必要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”。</p><p>这种方式是通过 package.json 的 “sideEffects” 属性来实现的。</p><pre><code>{ "name": "your-project", "sideEffects": false}</code></pre><p>（实验失败，了解）</p><p><strong>生产环境配置</strong></p><p>配置不同环境的webpack</p><pre><code>npm install --save-dev webpack-merge</code></pre><p>使用 merge，修改npm scripts</p><p><strong>代码分离</strong></p><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p><p>有三种常用的代码分离方法：</p><p>· 入口起点：使用 <a href="https://www.webpackjs.com/configuration/entry-context" target="_blank" rel="noopener">entry</a> 配置手动地分离代码。</p><p>如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中。</p><p>这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。</p><p>· 防止重复：</p><p><a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">SplitChunks</a>插件(webpack 4.x以前使用CommonsChunkPlugin)允许我们将公共依赖项提取到现有的entry chunk或全新的代码块中。</p><p>· 动态导入(懒加载)：通过模块的内联函数调用来分离代码。</p><p>import()</p><p>import() 不同于 import，该方法为了动态加载模块而引入的新语法</p><p>import() 返回结果是 Promise</p><p><strong>缓存</strong></p><p>webpack 会生成一个可部署的 /dist 目录，然后把打包后的内容放置在此目录中。只要 /dist 目录中的内容部署到服务器上，客户端（通常是浏览器）就能够访问网站此服务器的网站及其资源。而最后一步获取资源是比较耗费时间的，这就是为什么浏览器使用一种名为 <a href="https://searchstorage.techtarget.com/definition/cache" target="_blank" rel="noopener">缓存</a> 的技术。可以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。</p><p> <strong>输出文件的文件名(Output Filenames)</strong></p><p> 通过使用 <code>output.filename</code> 进行<a href="https://www.webpackjs.com/configuration/output#output-filename" target="_blank" rel="noopener">文件名替换</a>，可以确保浏览器获取到修改后的文件。<code>[hash]</code> 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 <code>[chunkhash]</code> 替换。</p><hr><p>以上内容是以前练习使用webpack总结的，以后还会更新。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 静态模块打包工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化构建工具-Gulp</title>
      <link href="/2020/06/01/zi-dong-hua-gou-jian-gong-ju-gulp/"/>
      <url>/2020/06/01/zi-dong-hua-gou-jian-gong-ju-gulp/</url>
      
        <content type="html"><![CDATA[<h1 id="自动化构建工具-Gulp"><a href="#自动化构建工具-Gulp" class="headerlink" title="自动化构建工具-Gulp"></a>自动化构建工具-Gulp</h1><blockquote><p>在Javascript的开发过程中，经常会遇到一些重复性的任务，比如合并文件、压缩代码、检查语法错误、将Sass代码转成CSS代码等等。通常，我们需要使用不同的工具，来完成不同的任务，既重复劳动又非常耗时。grunt，gulp都是为了解决这个问题而发明的工具，可以帮助我们自动管理和运行各种任务，很多人认为，在操作上，它要比Grunt简单。</p></blockquote><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><blockquote><p>异步的 javascript 函数，可以接收一个回调函数作为参数</p></blockquote><h3 id="组合任务"><a href="#组合任务" class="headerlink" title="组合任务"></a>组合任务</h3><blockquote><p>series() 和 parallel()</p></blockquote><h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><blockquote><p>暴露 <code>src()</code> 和 <code>dest()</code> 方法处理计算机存放的文件</p></blockquote><p><code>sec()</code>: 接收glob参数，读取文件，产生流，产生的流因该从任务中返回并发出异步完成的信号</p><p><code>stream</code>: 提供的主要API <code>.pipe()</code> ，用于连接准换流 或 可写流</p><p><code>dest()</code>: 接收输出目录作为参数，并且产生一个Node流，通常作为终止流</p><h2 id="Glob"><a href="#Glob" class="headerlink" title="Glob"></a>Glob</h2><blockquote><p>glob 是由普通字符和/或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件。</p></blockquote><h3 id="字符串片段-与-分隔符"><a href="#字符串片段-与-分隔符" class="headerlink" title="字符串片段 与 分隔符"></a>字符串片段 与 分隔符</h3><p>字符串片段（segment）是指两个分隔符之间的所有字符组成的字符串。在 glob 中，分隔符永远是 <code>/</code> 字符 - 不区分操作系统 - 即便是在采用 <code>\\</code> 作为分隔符的 Windows 操作系统中。在 glob 中，<code>\\</code> 字符被保留作为转义符使用。</p><h3 id="特殊字符："><a href="#特殊字符：" class="headerlink" title="特殊字符： *"></a>特殊字符： *</h3><p>在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用。</p><p>下面这个 glob 能够匹配类似 <code>index.js</code> 的文件，但是不能匹配类似 <code>scripts/index.js</code> 或 <code>scripts/nested/index.js</code> 的文件。</p><pre class=" language-js"><code class="language-js"><span class="token string">'*.js'</span></code></pre><h3 id="特殊字符：-1"><a href="#特殊字符：-1" class="headerlink" title="特殊字符： **"></a>特殊字符： **</h3><p>在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用。请确保适当地限制带有两个星号的 glob 的使用，以避免匹配大量不必要的目录。</p><p>下面这个 glob 被适当地限制在 <code>scripts/</code> 目录下。它将匹配类似 <code>scripts/index.js</code>、<code>scripts/nested/index.js</code> 和 <code>scripts/nested/twice/index.js</code> 的文件。</p><pre class=" language-js"><code class="language-js"><span class="token string">'scripts/**/*.js'</span></code></pre><h3 id="特殊字符：-取反"><a href="#特殊字符：-取反" class="headerlink" title="特殊字符： !(取反)"></a>特殊字符： !(取反)</h3><p>由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 必须跟在一个非取反（non-negative）的 glob 后面。第一个 glob 匹配到一组匹配项，然后后面的取反 glob 删除这些匹配项中的一部分。如果取反 glob 只是由普通字符组成的字符串，则执行效率是最高的。</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p> node流 ？ 转换流？</p><h2 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h2><blockquote><p>gulp api 中的 <code>watch()</code> 方法利用文件系统的监控程序（file system watcher）将 <a href="https://www.gulpjs.com.cn/docs/getting-started/explaining-globs" target="_blank" rel="noopener">globs</a> 与 <a href="https://www.gulpjs.com.cn/docs/getting-started/creating-tasks" target="_blank" rel="noopener">任务（task）</a> 进行关联。它对匹配 glob 的文件进行监控，如果有文件被修改了就执行关联的任务（task）。如果被执行的任务（task）没有触发 <a href="https://www.gulpjs.com.cn/docs/getting-started/async-completion" target="_blank" rel="noopener">异步完成</a> 信号，它将永远不会再次运行了。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 自动化构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始-搭建React脚手架</title>
      <link href="/2020/05/29/cong-ling-kai-shi-da-jian-react-jiao-shou-jia/"/>
      <url>/2020/05/29/cong-ling-kai-shi-da-jian-react-jiao-shou-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始-React脚手架搭建"><a href="#从零开始-React脚手架搭建" class="headerlink" title="从零开始-React脚手架搭建"></a>从零开始-React脚手架搭建</h1><p>目标：</p><ul><li><p>识别<code>TSX</code>文件</p></li><li><p><code>tree shaking</code> 摇树优化 删除掉无用代码T</p></li><li><p>识别 <code>async / await</code>和 箭头函数</p></li><li><p><code>PWA</code>功能，热刷新，安装后立即接管浏览器 离线后仍让可以访问网站 还可以在手机上添加网站到桌面使用</p></li><li><p><code>preload</code> 预加载资源 <code>prefetch</code>按需请求资源</p></li><li><p><code>CSS</code>模块化，不怕命名冲突</p></li><li><p>小图片的<code>base64</code>处理</p></li><li><p>文件后缀省掉<code>jsx js json</code>等</p></li><li><p>实现React懒加载，按需加载 ， 代码分割 并且支持服务端渲染</p></li><li><p>支持<code>less sass stylus</code>等预处理</p></li><li><p><code>code spliting</code> 优化首屏加载时间 不让一个文件体积过大</p></li><li><p>加入<code>dns-prefetch</code>和<code>preload</code>预请求必要的资源，加快首屏渲染。</p></li><li><p>加入<code>prerender</code>，极大加快首屏渲染速度。</p></li><li><p>提取公共代码，打包成一个<code>chunk</code></p></li><li><p>每个<code>chunk</code>有对应的<code>chunkhash</code>,每个文件有对应的<code>contenthash</code>,方便浏览器区别缓存</p></li><li><p>图片压缩</p></li><li><p><code>CSS</code>压缩</p></li><li><p>增加<code>CSS</code>前缀 兼容各种浏览器</p></li><li><p>对于各种不同文件打包输出指定文件夹下</p></li><li><p>缓存<code>babel</code>的编译结果，加快编译速度</p></li><li><p>每个入口文件，对应一个<code>chunk</code>，打包出来后对应一个文件 也是<code>code spliting</code></p></li><li><p>删除<code>HTML</code>文件的注释等无用内容</p></li><li><p>每次编译删除旧的打包代码</p></li><li><p>将<code>CSS</code>文件单独抽取出来</p></li><li><p>让babel不仅缓存编译结果，还在第一次编译后开启多线程编译，极大加快构建速度</p></li><li><p>webpack监听文件自动增量编译</p></li></ul><p>源代码： <a href="https://github.com/muyeyong/webck-gulp-temp">https://github.com/muyeyong/webck-gulp-temp</a></p><p>疑问：</p><ol><li><p>package.json</p><ul><li>dependencies 和 devDependencies 区别</li></ul></li><li><p>npm 命令 和 npm 全局安装 和 本地安装的区别</p></li></ol><p>神经病报错：</p><p>​    npm i -g webpack webpack-cli</p><p><img src="Snipaste_2020-05-29_15-21-22.png" alt=""></p><p>提示我 webpack-cli，然而当我运行 <code>webpack --config ./build/webpack.base.js --mode=development</code> 的时候有报错 no found webpack-cli，不懂就上google，一顿操作猛如虎，代码运行就是error，嘤嘤嘤，最后我就把<code>C:\Users\admin\AppData\Roaming\npm</code> 这个路径下的这两个文件给删掉<img src="Snipaste_2020-05-29_15-25-14.png" alt=""></p><p>出现了新报错，真开心。。。。</p><p><img src="Snipaste_2020-05-29_15-26-29.png" alt=""></p><p>React 里面使用 TS</p><p>​    报错识别不了，react （参考文章） <a href="https://juejin.im/post/5bab4d59f265da0aec22629b" target="_blank" rel="noopener">https://juejin.im/post/5bab4d59f265da0aec22629b</a></p><p>​    <img src="Snipaste_2020-05-29_15-43-40.png" alt=""></p><p>Connot find module ‘typescript’</p><p><img src="Snipaste_2020-05-29_16-41-30.png" alt=""></p><p>虽然在全局安装了 <code>typescript</code> ，但是本地没有安装</p><p>files’ list in config file ‘tsconfig.json’ is empty</p><p><img src="Snipaste_2020-05-29_16-50-51.png" alt=""></p><p>​    解决： 没有配置 <code>tsconfig.json</code> 文件  <code>tsconfig.json</code> 文件的配置?</p><p>运行打包命令<code>webpack --config ./build/webpack.base.js --mode=development</code> 报错</p><p> <img src="Snipaste_2020-06-01_11-47-36.png" alt=""></p><p>解决： <img src="Snipaste_2020-06-01_11-48-09.png" alt=""></p><p>extensions 没有配置 .ts .tsx     resolve -&gt;extensions 的作用？？</p><p>nodejs 里面的流？</p><p>使用 <code>gulp</code> 作为项目工程化的流程管理工具</p><p>搭建开发服务器</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>​    不要管具体实现，关注业务，那跟插件有什么区别？</p><p>​    实现具体业务的中间件怎么实现？ </p><p>gulp dev : 对于使用 ts tsx </p><p>​    读取合并 所有 tsconfig</p><p>​    读取合并所有 webpackconfig</p><p>​    起服务器运行</p><hr><p>​    上面的这些是我遇到的一些问题和疑惑，还没彻底解决，<code>2020/06/02</code>  经过两天的时间写了一个基础（0.0.1）的版本<code>webpack + gulp</code> ，实现了</p><ul><li><p><code>webpack</code> 不同环境的配置（基础、测试和生产环境）</p></li><li><p><code>webpack</code> 对不同文件的处理</p></li><li><p><code>webpack</code> 监听文件变更自动增量编译 </p></li><li><p><code>gulp</code>作为流程管理</p></li><li><p>对TS的支持</p></li></ul><h2 id="安装NodeJs"><a href="#安装NodeJs" class="headerlink" title="安装NodeJs"></a>安装NodeJs</h2><p>​    nodejs下载： <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p>​    下载对应版本，windows安装完后会自动配好环境变量，命令行<code>node -v</code> 查看node版本，没有自动配环境变量需要手动配置。</p><p><img src="Snipaste_2020-06-02_17-56-19.png" alt=""></p><h2 id="npm项目初始化"><a href="#npm项目初始化" class="headerlink" title="npm项目初始化"></a>npm项目初始化</h2><p>新建文件夹，初始化项目</p><pre><code>mkdir webpack20200601 &amp;&amp; cd webpack20200601npm init -y</code></pre><p>初始化后会生成<code>package.json</code> 文件，下面是本次版本配置：</p><pre><code>{  "name": "webpack20200601",  "version": "1.0.0",  "description": "",  "main": "index.js",  "private": true,  "dependencies": {    "@babel/runtime": "^7.10.2",    "react": "^16.13.1",    "react-dom": "^16.13.1",    "ts-loader": "^7.0.5"  },  "devDependencies": {    "@types/node": "^14.0.6",    "@types/react": "^16.9.35",    "@types/react-dom": "^16.9.8",    "@types/webpack": "^4.41.16",    "@types/webpack-dev-server": "^3.11.0",    "babel-core": "^6.26.3",    "babel-eslint": "^10.1.0",    "babel-plugin-external-helpers": "^6.22.0",    "babel-plugin-import": "^1.13.0",    "babel-plugin-syntax-dynamic-import": "^6.18.0",    "babel-plugin-transform-class-properties": "^6.24.1",    "babel-plugin-transform-decorators-legacy": "^1.3.5",    "babel-plugin-transform-runtime": "^6.23.0",    "babel-preset-env": "^1.7.0",    "babel-preset-react": "^6.24.1",    "connect-history-api-fallback": "^1.6.0",    "copy-webpack-plugin": "^6.0.1",    "del": "^5.1.0",    "eslint": "^7.1.0",    "eslint-plugin-react": "^7.20.0",    "express": "^4.17.1",    "gulp": "^4.0.2",    "gulp-imagemin": "^7.1.0",    "gulp-sequence": "^1.0.0",    "gulp-uglify": "^3.0.2",    "gulp-util": "^3.0.8",    "html-webpack-plugin": "^4.3.0",    "http-proxy-middleware": "^1.0.4",    "less": "^3.11.2",    "opn": "^6.0.0",    "postcss": "^7.0.31",    "ts-node": "^8.10.2",    "typescript": "^3.9.3",    "webpack": "^4.43.0",    "webpack-bundle-analyzer": "^3.8.0",    "webpack-cli": "^3.3.11",    "webpack-dev-server": "^3.11.0",    "webpack-hot-middleware": "^2.25.0",    "webpack-merge": "^4.2.2"  },  "scripts": {    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",    "build": "webpack"  },  "keywords": [],  "author": "",  "license": "ISC"}</code></pre><p>使用 <code>npm i</code> 安装需要的依赖。</p><p>依赖都会安装在这个文件夹下面</p><p><img src="Snipaste_2020-06-03_17-37-26.png" alt=""></p><h2 id="webpack搭建自动开发环境"><a href="#webpack搭建自动开发环境" class="headerlink" title="webpack搭建自动开发环境"></a>webpack搭建自动开发环境</h2><p>webpack 官网 ： <a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">https://webpack.docschina.org/concepts/</a></p><h3 id="基础搭建"><a href="#基础搭建" class="headerlink" title="基础搭建"></a>基础搭建</h3><h3 id="使用开发服务器"><a href="#使用开发服务器" class="headerlink" title="使用开发服务器"></a>使用开发服务器</h3><h2 id="使用Gulp作为流程管理"><a href="#使用Gulp作为流程管理" class="headerlink" title="使用Gulp作为流程管理"></a>使用Gulp作为流程管理</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 从零开始 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React脚手架搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态管理-mobx</title>
      <link href="/2020/05/28/zhuang-tai-guan-li-mobx/"/>
      <url>/2020/05/28/zhuang-tai-guan-li-mobx/</url>
      
        <content type="html"><![CDATA[<h1 id="状态管理-Mobx"><a href="#状态管理-Mobx" class="headerlink" title="状态管理-Mobx"></a>状态管理-Mobx</h1><p><img src="flow.png" alt=""></p><h2 id="Observable-state-可观察的状态"><a href="#Observable-state-可观察的状态" class="headerlink" title="Observable state(可观察的状态)"></a>Observable state(可观察的状态)</h2><blockquote><p>observable &amp; observer</p></blockquote><h3 id="observable-value"><a href="#observable-value" class="headerlink" title="observable(value)"></a>observable(value)</h3><p>value可以是<code>objext</code>、<code>array</code>或<code>map</code> ，observable将其转换成observable entity 被观察的实体。对于javascript的基本类型（number、string、boolean、null和undefined）、function函数和class类类型不会起作用，甚至还会报错。</p><p><img src="Snipaste_2020-05-28_16-37-03.png" alt=""></p><p>对于这些例外的类型，需要使用<code>observable.box()</code> API</p><pre><code> n = observable.box(1); console.log(n.get())//读取 n.set(19)//设置新值</code></pre><p><strong>value为object</strong> </p><blockquote><p>observable.object(props, decorators?, options?)</p><p>props: object的属性</p><p>decorators:  对属性进行装饰，可以将属性设置成 action</p><p>options： 传入 <code>{ deep: false }</code> 作为第三个参数可以禁用属性值的自动转换</p></blockquote><pre><code>import {observable, autorun, action} from "mobx";var person = observable({    // observable 属性:    name: "John",    age: 42,    showAge: false,    // 计算属性:    get labelText() {        return this.showAge ? `${this.name} (age: ${this.age})` : this.name;    },    // 动作:    setAge(age) {        this.age = age;    }}, {    setAge: action});// 对象属性没有暴露 'observe' 方法,// 但不用担心, 'mobx.autorun' 功能更加强大autorun(() =&gt; console.log(person.labelText));person.name = "Dave";// 输出: 'Dave'person.setAge(21);// 等等</code></pre><pre><code> **属性的getter会自动变成衍生属性，也就是@computed**</code></pre><p><strong>value为array</strong></p><blockquote><p><code>observable.array(values?)</code> 或者将数组传给 <code>observable</code>，可以将数组转变为可观察的。 这也是递归的，所以数组中的所有(未来的)值都会是可观察的</p></blockquote><pre><code>import {observable, autorun} from "mobx";var todos = observable([    { title: "Spoil tea", completed: true },    { title: "Make coffee", completed: false }]);autorun(() =&gt; {    console.log("Remaining:", todos        .filter(todo =&gt; !todo.completed)        .map(todo =&gt; todo.title)        .join(", ")    );});// 输出: 'Remaining: Make coffee'todos[0].completed = false;// 输出: 'Remaining: Spoil tea, Make coffee'todos[2] = { title: 'Take a nap', completed: false };// 输出: 'Remaining: Spoil tea, Make coffee, Take a nap'todos.shift();// 输出: 'Remaining: Make coffee, Take a nap'</code></pre><p><strong>value为map</strong></p><blockquote><p>observable.map(values,options?)</p><p>observable(new Map())</p></blockquote><h3 id="observable-classProperty-value"><a href="#observable-classProperty-value" class="headerlink" title="@observable classProperty = value;"></a>@observable classProperty = value;</h3><p>ES7或TS类属性中使用装饰器模式</p><pre><code>@observable number = 0;@observable map = new Map();@onservable arr = [];</code></pre><h3 id="observer"><a href="#observer" class="headerlink" title="@observer"></a>@observer</h3><blockquote><p><code>observer</code> 函数/装饰器可以用来将 React 组件转变成响应式组件。 它用 <code>mobx.autorun</code> 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件。 <code>observer</code> 是由单独的 <code>mobx-react</code> 包提供的。</p></blockquote><p><strong>observable声明的是被观察者，需要观察者的存在才有意义</strong> </p><h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><blockquote><p>1: computed</p><p>2：autorun</p><p>3： when</p><p>4： reaction</p></blockquote><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><blockquote><p>根据现有状态或其它值衍生出来的值，可以在任意属性getter上使用<code>@computed</code>来声明式的创建计算属性</p></blockquote><pre><code>//carStore.js@computed get total() {    return this.items.length;  }//app.js&lt;p&gt;我是total &amp;nbsp;  &amp;nbsp;{store.total}&lt;/p&gt;</code></pre><p><img src="1.gif" alt=""></p><h3 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h3><blockquote><pre><code>如果你有一个函数应该自动运行，但不会产生一个新的值，请使用autorunautorun(effect-function): disposer-functioneffect-function: (data) =&gt; {}</code></pre></blockquote><p>​    执行 <code>autorun()</code> 之后返回一个可注销 <code>effect-function</code> 的 <code>disposer-function</code> 函数，此返回函数用于停止 <code>autorun()</code> 的监听，类似于<code>clearTimer(timer)</code> 的作用。</p><pre><code>//CartStore.js &lt;button onClick={() =&gt; store.disposer()}&gt;清除自动输出&lt;/button&gt;//App.js &lt;button onClick={() =&gt; store.disposer()}&gt;清除自动输出&lt;/button&gt;</code></pre><p><img src="Snipaste_2020-05-28_17-33-54.png" alt=""></p><p><img src="3.gif" alt=""></p><p>只有手动清除才能停止</p><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><blockquote><p>when(predicate: () =&gt; boolean, effect?: () =&gt; void, options?)</p><p>predicate返回true才会执行effect，执行完一次后会自动清除</p></blockquote><pre><code>//CartStore.jswhen(      () =&gt; this.items.some(item =&gt; item === "shoes"),      () =&gt; {        console.log("第一次收到鞋子");      }    );</code></pre><p><img src="4.gif" alt=""></p><h3 id="reaction"><a href="#reaction" class="headerlink" title="reaction"></a>reaction</h3><blockquote><p>reaction(() =&gt; data, (data, reaction) =&gt; { sideEffect }, options?)</p><p>只有当第一个参数产生新值，才会触发第二个参数的执行</p></blockquote><pre><code>//CartStore.js reaction(      () =&gt; {        let shoesNumber = 0;        this.items.forEach(item =&gt; {          if (item === "shoes") shoesNumber++;        });        return shoesNumber;      },      shoesNumber =&gt; {        console.log("收到鞋子啦。。。。。" + shoesNumber);      }    );</code></pre><p>效果见上图。</p><h2 id="改变observable"><a href="#改变observable" class="headerlink" title="改变observable"></a>改变observable</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><blockquote><ul><li><code>action(fn)</code></li><li><code>action(name, fn)</code></li><li><code>@action classMethod() {}</code></li><li><code>@action(name) classMethod () {}</code></li><li><code>@action boundClassMethod = (args) =&gt; { body }</code></li><li><code>@action(name) boundClassMethod = (args) =&gt; { body }</code></li><li><code>@action.bound classMethod() {}</code>  //确保this的指向正确，不能和箭头函数一起使用</li></ul><p>永远只对修改状态的函数使用<code>action</code></p></blockquote><pre><code>//CartStore.js  @action  addItem = (name, quantity) =&gt; {    while (quantity &gt; 0) {      this.items.push(name);      quantity--;    }    this.modified = new Date();  };</code></pre><p>在线示例： <a href="https://codesandbox.io/s/github/muyeyong/codesandbox" target="_blank" rel="noopener">https://codesandbox.io/s/github/muyeyong/codesandbox</a></p><p>MoBx中文文档：<a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">https://cn.mobx.js.org/</a></p><h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><blockquote><p>可以用来使用 React 的<code>context</code>机制来传递 store 给子组件。参见<a href="https://github.com/mobxjs/mobx-react#provider-experimental"><code>mobx-react</code> 文档</a>。</p></blockquote><h3 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h3><blockquote><p>相当于<code>Provider</code> 的高阶组件。可以用来从 React 的<code>context</code>中挑选 store 作为 prop 传递给目标组件.</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 状态管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mobx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-属性书写顺序</title>
      <link href="/2020/05/27/css-shu-xing-shu-xie-shun-xu/"/>
      <url>/2020/05/27/css-shu-xing-shu-xie-shun-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h1><p> <em>遵循以下顺序</em></p><p>1： 布局定位属性：display/position/float/clear/visibility/overfolw</p><p>2: 自身属性： width/height/margin/padding/border/background</p><p>3: 文本属性： color/font/text-decoration/text-align/vertial-align/white-space/breack-word</p><p>4: 其他属性(CSS3): content/cursor/border-radius/box-shadow/text/shadow</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-call apply bind 实现</title>
      <link href="/2020/05/26/javascript-call-apply-bind-shi-xian/"/>
      <url>/2020/05/26/javascript-call-apply-bind-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="call-apply-bind的实现"><a href="#call-apply-bind的实现" class="headerlink" title="call apply bind的实现"></a>call apply bind的实现</h1><blockquote><p>call、apply和bind的主要目的是改变this的指向。call 和 apply的区别是接收参数的不同，call接收的一系列的参数，apply接收的是一组参数。而bind的与call和apply的区别是，bind返回一个函数，可以延迟执行，call和apply会立即执行。</p></blockquote><h2 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h2><pre><code>// call // 改变 this 的指向，返回执行函数的结果// 1: 判断上下文是否合法// 2：绑定传入上下文// 3：传递参数// 4：返回执行结果Function.prototype.myCall = function (context, ...args) {  if (context === null || context === undefined) context = window;  else context = Object(context);  let sym = Symbol();  context[sym] = this; //this指的就是调用 mycall的函数  let result = context[sym](...args);  delete context[sym];  return result;}function saySomething(name) {  console.log(this.str, name)}A = {  str: '上帝说我帅的很'}saySomething.myCall(A, '花大姐')</code></pre><p><img src="Snipaste_2020-05-26_14-45-31.png" alt=""></p><h2 id="apply的实现"><a href="#apply的实现" class="headerlink" title="apply的实现"></a>apply的实现</h2><pre><code>Function.prototype.myapply = function (context, arg) {  if (context === null || context === undefined) context = window;  else context = Object(context);  let sym = Symbol();  context[sym] = this;  let result;  function isLikeArrayOrArray(o) {    if (Object.prototype.toString.call(o) === '[object Array]') return true;    if (o &amp;&amp; typeof o === 'object'      &amp;&amp; isFinite(o.lenght) &amp;&amp; o.lenght &gt;= 0      &amp;&amp; o.lenght === Math.floor(o.lenght)      &amp;&amp; o.lenght &lt; Math.pow(2, 32)) return true;    else return false;  }  if (arg) {    if (isLikeArrayOrArray(arg)) {      result = context[sym](...arg);    } else {      throw Error('参数类型错误');    }  } else {    result = context[sym]();  };  delete context[sym];  return result;}function printArray() {  this.arr.forEach(item =&gt; console.log(item))  if (arguments) {    console.log(arguments)  }}B = {  arr: [1, 2, 3, 4, 5, 6, 7]}printArray.myapply(B, [])</code></pre><p><img src="Snipaste_2020-05-26_15-00-29.png" alt=""></p><h2 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h2><pre><code>//bind   柯里化Function.prototype.mybind = function (context, ...args1) {  if (context === null || context === undefined) context = window;  else context = Object(context);  return (...args2) =&gt; this.call(context, ...args1, ...args2);}C = {  name: '马大哈'}function sayMyName() {  console.log('我是多余的参数...', arguments)  console.log('My name is ' + this.name);}let hi = sayMyName.mybind(C, '1234,走起')hi('456,出发')</code></pre><p><img src="Snipaste_2020-05-26_15-01-22.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结</title>
      <link href="/2020/05/18/jing-yan-kai-fa-zong-jie/"/>
      <url>/2020/05/18/jing-yan-kai-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="2020-05-21"><a href="#2020-05-21" class="headerlink" title="2020/05/21"></a>2020/05/21</h1><pre><code>这个迭代的单，逻辑上不难理解，根据某些逻辑，打开联系人的时候默认选中以IM（系统消息）的形式发送，三个端都需要改动，但是是在以前的老代码上改动。</code></pre><p>​    需要实现的效果</p><p><img src="Snipaste_2020-05-21_10-58-07.png" alt=""></p><p>​    在以前老项目上改动，就需要先理解原先代码的逻辑，这就让人很奔溃，老代码字段很多很多，而且没有注解或注解很少（公司规定），这就提高了开发的难度，虽然每个迭代开始之前会写开发文档，但是我觉得这样做主要目的是为了服务开发流程的，对后续去他人的开发参考价值并不大。我需要理解每个字段的含义（<del>草泥马</del>）。</p><p>​    在写代码的过程种发现了几个问题：</p><ol><li><p>变量的设计</p><p><img src="Snipaste_2020-05-21_11-16-40.png" alt=""></p><p>一个大的变量里面存储了这个结构的所有数据，上面展示的只是冰山一角，许多请求的数据都塞到一个变量里面。我需要去查找这个变量里面的某个字段需要多层遍历，这就让人觉得很恶心。归根结底就是怎么去组织代码里的数据结构，发现了问题，就要解决问题，<strong>挖坑待填</strong>。</p></li><li><p>不同端对于同一功能的设计</p><p>这次迭代是要对三个段进行改动，在写代码的过程中发现，尽管页面交互大致相同，但不同端的代码实现却不尽相同（<del>what fuck</del>）。</p></li><li><p>优雅的代码书写</p><p>看以前的老代码，代码还是存在一些问题。</p><ul><li><p>回调地狱</p><p>我终于遇到了回调地狱，每次请求之后都通过回调函数进行逻辑处理，不断的嵌套。。。。。</p></li><li><p>定位不清的文件</p><p><img src="Snipaste_2020-05-21_11-50-02.png" alt=""></p></li></ul><p>这两个文件，一个是用来视图的定义（communication_vm），一个写具体逻辑的（communication_new），但是在写代码的过程中，发现这两个文件串了味。</p><ol start="4"><li><p>在老功能基础上的开发</p><p>这次开发在验收这次修改的功能的时候，由于以前的一些设计跟这次的修改存在冲突，QA测试的时候觉得是这次迭代的功能没完善。还有在开发的过程中发现的一些问题都是口头描述，对后续功能上的看法出现冲突。</p></li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>配套文档缺少</p></li><li><p>代码质量不高，当时是怎么过review的？？？，设计的时候须要考虑到可扩展性，设计模式的应用。</p></li><li><p>对于在老代码的改动也尽量采用增量开发（开闭原则），提前对以前的功能对本次修改的影响，并且还要有相应的记录。</p></li></ol><hr><p>2020/06/03</p><p>​    来了来了，live bug来了，还是上一个迭代的单，今天在live上出bug了，原因是之前没有关注的可操作入口导致的。</p><p>​    总结一下： </p><ol><li>对于老代码的更改，在不明白全部逻辑的情况下大刀阔斧的更改，但是全部理清老代码的逻辑也需要时间的，是否可行还不一定，另一种想法还是增量开发，但是对于需求跟以前的代码有冲突，进行增量开发不一定可行，这又要求对整体的把握，总之开始写代码之前，一定要去看代码，理清逻辑。</li><li>还是粗心。今天再去测的时候发现有些接口还在报404，自测的时候为了省事，自测一部分，导致后面浪费更多时间。</li></ol><hr><h1 id="2020-07-25"><a href="#2020-07-25" class="headerlink" title="2020/07/25"></a>2020/07/25</h1><p>​    到新的公司都一周多了，也要对最近遇到的问题，进行总结一下了。</p><ul><li>搜索框实现像百度一样的效果</li></ul><p><img src="1.gif" alt=""></p><p>当搜索框获得焦点的时候，需要根据搜索框里面的内容显示搜索结果，当搜索框失去焦点的时候需要隐藏搜索结果，关于这一点我还写了一篇关于搜索优化的，写的不错哦！</p> {% post_link 代码优化-抖动节流 %} <p>基本思路是利用<code>onBlur</code> 和 <code>onFocus</code> ，控制结果框的显示，但是如果你直接这样写：</p><pre><code>//setIsshow()是给isshow赋值的，isshow控制结果框的显示与否onBlur={() =&gt; setIsshow(false)} onFocus={e =&gt; e.target.value.length &gt; 0 &amp;&amp; setIsshow(true)}</code></pre><p>就会出现这种情况：</p><p><img src="2.gif" alt=""></p><p>点击结果，不能发生跳转，其实是因为当<code>input</code>失去焦点的时候，<code>isshow</code>就被置成false了，下面的结果框dom其实已经不存在了，我想到了一个解决方案：</p><p>延迟执行<code>onBlur</code>的处理函数：利用<code>setTimeout</code>，于是代码变成了这样</p><pre><code>onBlur={() =&gt; (timeOut = setTimeout(() =&gt; setIsshow(false), 100))}onFocus={e =&gt; e.target.value.length &gt; 0 &amp;&amp; setIsshow(true) &amp;&amp; clearTimeout(timeOut)}//////////////</code></pre><p>当然要记得清除计时器哦，我觉得这不是唯一的解决办法，这几天看看以前的项目找一个更好的解决办法。</p><p>最终的效果：</p><p><img src="3.gif" alt=""></p><p>好像还有一个小问题：某些情况下不能完成跳转，暂时还不清楚</p><p>改成这样就可以了</p><pre><code> onBlur={() =&gt; {              isshow &amp;&amp;                (timeOut = setTimeout(() =&gt; setIsshow(false), 500, () =&gt; {                  clearTimeout(timeOut), (timeOut = null);                }));            }} onFocus={e =&gt; e.target.value.length &gt; 0 &amp;&amp; setIsshow(true)}</code></pre><ul><li>展示内容过长需要隐藏好的实现方法</li></ul><p>看一下现在项目中的效果：</p><p><img src="4.gif" alt=""></p><p>这就是隐藏了一个寂寞，我觉得实现这种功能需要实现下面几点：</p><ul><li>合理断句，不能直接将一段话一刀两段</li><li>当隐藏的部分很短时，是不是要考虑其他实现方法（就像图片上那样）</li></ul><p>#2020/08/13</p><a href="/2020/08/13/dai-ma-you-hua-shua-xin-jie-mian-hou-zen-me-bao-cun-yong-hu-shu-ju/" title="代码优化-刷新界面后怎么保存用户数据">代码优化-刷新界面后怎么保存用户数据</a><p>#2020/12/19</p><p>一直想总结下最近的项目经验，但是懒就拖到现在，最近两个月做项目的时候挫败感挺强的，深感到自己太菜了。</p><p><img src="https://i.loli.net/2020/12/19/hGlKiBMWREkFz7f.gif" alt=""></p><p>这是前一个月做的项目，总得来说上面三个圆环的联动以及折线图的数据联动。下面的统计时间限制，开始时间不能大于结束时间，结束时间不能早于开始时间。</p><p>我碰到的问题：</p><ol><li><p>这个页面其实是一个改版，接口大多数复用以前的接口，圆环里面的数据本来不是一个接口返回的，也就是说每一段小圆弧是一个接口返回的，一个圆环有十个小圆弧组成，需要请求十次才能将数据全部请求完，我那时候觉得能复用就复用，就直接沿用以前的接口，面临的一个问题是怎么判断十次请求全部结束，没请求一次就将数据塞到一个变量里面去，用watch观察，每变一次就执行指定的方法，反正最后的效果像屎一样（代码层次以及效果层次的双重），最后还是新写了一个接口返回全部数据解决的。</p></li><li><p>环状图、折线图以及柱状图的使用<strong>很不熟练</strong>，这种展示大屏项目，使用的大量的echarts，而我却对它不熟悉，致命的缺点。因为以前代码里面用过这些chart，我就致敬了原来的代码，但是那些代码本身也有问题，浪费了我很多时间。</p><p><img src="https://i.loli.net/2020/12/19/9M18dWCTPw6Osyb.png" alt=""></p></li></ol><ol start="3"><li>时间限制也比较简单，用iview提供的disabledDate就好，注意的是要使用箭头函数不然访问不到this（好像是这样）</li></ol><pre><code> datePickerOptionsStart: {       disabledDate: date=&gt; {          let time = moment(date).format('YYYY-MM')           let limitTime = this.endTime ==="" ? this.availableTimeList[this.availableTimeList.length-1] : this.endTime          if(this.availableTimeList.includes(time) &amp;&amp; moment(time).isSameOrBefore(limitTime)) return false          return true       }      },datePickerOptionsEnd: {       disabledDate: date=&gt; {          let time = moment(date).format('YYYY-MM')           let limitTime = this.startTime ==="" ? this.availableTimeList[0] : this.startTime          if(this.availableTimeList.includes(time) &amp;&amp; moment(time).isSameOrAfter(limitTime)) return false          return true       }      }</code></pre><ol start="4"><li><p>粗心大意我的天敌</p><p>在做环状图轮播的时候发现有时候它会乱转，这个问题用了我起码一个上午，期间还想到是不是操作太快程序执行速度赶不上我手速，接着就想出使用任务队列去解决还有其他一堆骚操作，但统统以失败告终，然后在一位同事的指点下发现我代码clearInterval()里面的参数少写了一个字母，我顿时吐血了，然鹅最近做的一个界面也出现了同样的问题，可以打死我自己了。</p></li></ol><p>这是上个月的总结：对于常用的东西不熟练以及粗心</p><p><img src="https://i.loli.net/2020/12/19/YjBXkg1m78CLrow.gif" alt=""></p><p>这个页面做了快一周了，发现了很多问题</p><ol><li><p>系统中常见的组件可以封装起来（也有封装好的组件，但是我不知道，导致开发效率低下，每次都重复造轮子）</p></li><li><p>技术不太行，对于滚动、echarts的使用还不是很熟练</p></li><li><p>有一个文件的代码竟然写了快一千多行，有点问题</p></li><li><p>没有跟ui沟通，增加开发成本（时间组件）</p></li><li><p>粗心（定时器的清除少写了有个字母，浪费了半个小时）</p></li></ol><p>改善计划：</p><ol><li><p>将常用的模块封装成组件</p></li><li><p>review代码，看看哪里写的不好</p></li></ol><p>这是我前天的反思，轮播的环状饼图和自动滚动的列表起始在项目里早就封装好了的，虽然饼图还是自己写的，但用到了自动滚动列表，出现这种现象的原因是没有开发文档以及自己对存在的工具方法不熟悉。前期没有很好的沟通也导致了我浪费了大量时间，我觉得ui出设计稿的同时也要跟前端沟通，看看怎样设计才能更快更好的完成，有这个想法是因为时间选择组件</p><p><img src="https://i.loli.net/2020/12/19/LvhOwRNFPxAJSbY.png" alt=""></p><p>完全可以使用组件库已有的，但这个设计就相当于让我自己重新去写一个新的组件，不是不能完成，是没有必要</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的插件-VSCode</title>
      <link href="/2020/05/13/hao-yong-de-cha-jian-vscode/"/>
      <url>/2020/05/13/hao-yong-de-cha-jian-vscode/</url>
      
        <content type="html"><![CDATA[<h1 id="好用的插件-VSCode"><a href="#好用的插件-VSCode" class="headerlink" title="好用的插件-VSCode"></a>好用的插件-VSCode</h1><h2 id="Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) Language Pack for Visual Studio Code"></a>Chinese (Simplified) Language Pack for Visual Studio Code</h2><blockquote><p>VSCode 汉化</p></blockquote><h2 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h2><pre><code>我通常会在vs上用js写算法题，但是想直接运行的话不太方便（可以以调试的形式运行，需要配置，详情参见 {% post_link 调试-VSCode  %} ），于是乎可以使用 `Code Runner`</code></pre><p><img src="Snipaste_2020-05-21_10-32-26.png" alt=""></p><h2 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h2><pre><code>可以默认起一个服务器，去运行你的HTML，改的的话，不需要刷新就可以看到改动</code></pre><p><img src="1.gif" alt=""></p><h2 id="open-in-browser"><a href="#open-in-browser" class="headerlink" title="open in browser"></a>open in browser</h2><pre><code>在默认浏览器打开你的HTML页面</code></pre><p><code>vetur</code> 、<code>ESlint</code>、<code>Prettier</code>都是用来检查代码规范的，这一些插件都有啥区别 🤣？</p><p><code>ESlint</code>：负责质量检测</p><p><code>Prettier</code>：负责风格检测</p><h2 id="Vetur（在Vue项目中的应用）"><a href="#Vetur（在Vue项目中的应用）" class="headerlink" title="Vetur（在Vue项目中的应用）"></a>Vetur（在Vue项目中的应用）</h2><p>Vetur能提供的功能:</p><ul><li>Syntax Highlighting(代码高亮)</li></ul><p>没有使用前，代码灰蒙蒙一片：</p><p><img src="%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6-VSCode/Snipaste_2020-07-17_16-37-36.png" alt=""></p><p>使用后，像极了我戴眼镜看世界的样子：</p><p><img src="C:/Users/xuxiaojian/AppData/Roaming/Typora/typora-user-images/image-20200717164435131.png" alt="image-20200717164435131"></p><ul><li>Snippet(代码片段)</li><li>Emmet(Emmet语法)</li><li>Linting / Error Checking(代码校验/错误检查)</li></ul><p><img src="%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6-VSCode/Snipaste_2020-07-18_09-50-57.png" alt=""></p><p>​    Vetur的Linting不支持修改，还需要安装<code>ESLint</code>。</p><ul><li>Formatting</li><li>IntelliSense</li><li>Debugging</li><li>Framework Support</li><li>Interpolation Support</li><li>VTI</li></ul><h2 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h2><h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><h2 id="Bracket-Pair-Colorizer-2"><a href="#Bracket-Pair-Colorizer-2" class="headerlink" title="Bracket Pair Colorizer 2"></a>Bracket Pair Colorizer 2</h2><h2 id="Code-Spell-Checker"><a href="#Code-Spell-Checker" class="headerlink" title="Code Spell Checker"></a>Code Spell Checker</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 好用的插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongoDB-聚合查询</title>
      <link href="/2020/05/13/mongodb-ju-he-cha-xun/"/>
      <url>/2020/05/13/mongodb-ju-he-cha-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="mongoDB聚合查询"><a href="#mongoDB聚合查询" class="headerlink" title="mongoDB聚合查询"></a>mongoDB聚合查询</h1><p>​    写毕业设计的时候需要实现一个需求，需要根据月份显示订单的数量信息，实现下图的效果</p><p><img src="Snipaste_2020-05-13_09-08-31.png" alt=""></p><p>​    上网查了下，需要使用mongoDB的<code>aggregate()</code>，聚合操作。</p><p>​    官方文档</p><p>​        英文：<a href="https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</a> </p><p>​        中文：<a href="https://www.mongodb.org.cn/tutorial/19.html" target="_blank" rel="noopener">https://www.mongodb.org.cn/tutorial/19.html</a></p><p>​    英文文档更加详实。</p><p>​    结合了思否上的提问：<a href="https://segmentfault.com/q/1010000010073540，写了自己的查询语句" target="_blank" rel="noopener">https://segmentfault.com/q/1010000010073540，写了自己的查询语句</a></p><pre><code>//表结构const productSchema = new mongoose.Schema({  woId: { type: String, required: true }, // 所属分类的id  userId: { type: String, required: true },  createDate: { type: Number, required: true },  deadline: { type: Number, required: true },  parentId: { type: String, required: true }, // 所属分类的id  selfId: { type: String, required: true },  serviceName: { type: String, required: true },  cost: { type: Number, required: true }, // 价格   address: { type: String, required: true },  status: { type: Number, default: 0 }, // 商品状态: 0:等待接收 1：订单派送中 3：拒接  3: 订单派送中  4：订单进行中   5 or 6：订单完成(不能操作)  imgs: { type: Array, default: [] }, // n个图片文件名的json字符串  detail: { type: String },  serviceStaffId: { type: String, default: '' }})</code></pre><pre><code>//查询语句ProductModel.aggregate([                { $match: { userId } },                {                    $group: {                        _id: {                            date: {                                $month: {                                     date: {                                        '$add': [                                             new Date(0),                                            '$createDate'                                        ]                                    }                                }                            },                            'name': '$serviceName',                        },                        count: { $sum: 1 }                    }                }, {                    $group: {                        _id: '$_id.date',                        name: {                            $push: {                                name: "$_id.name",                                count: "$count"                            }                        }                    }                }            ]).then(data =&gt; {                res.send({ status: 0, data: data })            }).catch(err =&gt; {                console.log(err)                res.send({ statu: 1, msg: '请稍后再试' })            })</code></pre><pre><code>[  {"_id":7,"name":[{"name":"搬运\\个人搬家","count":1}]},  {"_id":5,"name":[{"name":"搬运\\公司搬运","count":1},{"name":"室外\\草地修建","count":1},     {"name":"活动策划\\公司团建","count":1},{"name":"搬运\\个人搬家","count":5}]},  {"_id":8,"name":[{"name":"室内\\办公室打扫","count":1}]}]</code></pre><p>​    我的想法是根据表结构的<code>createDate</code> 这个字段（字段的类型是number，我将时间转成了毫秒数，这也是个坑），将同一月份的数据统计到一起（聚合）。</p><p>​    查询语句这一块<code>$match</code>是过滤条件，我是根据用户id查询数据。代码具体的细节我也是一知半解（原谅我的菜），说一下我踩的坑吧：</p><ol><li><p>日期这一块</p><p><img src="Snipaste_2020-05-13_09-56-23.png" alt=""></p><p>由于我的<code>createDate</code>是number类型，mongoDB不支持将它转成date类型，于是就利用$add操作符，把日期和时间戳相加，得到另一个日期解决。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PS-切图</title>
      <link href="/2020/05/08/ps-qie-tu/"/>
      <url>/2020/05/08/ps-qie-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="PS自带切图"><a href="#PS自带切图" class="headerlink" title="PS自带切图"></a>PS自带切图</h1><h1 id="CutMan-插件切图"><a href="#CutMan-插件切图" class="headerlink" title="CutMan 插件切图"></a>CutMan 插件切图</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 切图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷化-VSCode终端快捷命令</title>
      <link href="/2020/05/08/kuai-jie-hua-vscode-zhong-duan-kuai-jie-ming-ling/"/>
      <url>/2020/05/08/kuai-jie-hua-vscode-zhong-duan-kuai-jie-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode终端快捷命令"><a href="#VSCode终端快捷命令" class="headerlink" title="VSCode终端快捷命令"></a>VSCode终端快捷命令</h1><h2 id="快速调出终端Tab"><a href="#快速调出终端Tab" class="headerlink" title="快速调出终端Tab"></a>快速调出终端Tab</h2><blockquote><p>当终端Tab切换到其它Tab时，终端Tab会消失，可以使用<code>Ctrl + '</code>   快速调出终端Tab</p></blockquote><p><img src="1.gif" alt=""></p><h2 id="终端清屏"><a href="#终端清屏" class="headerlink" title="终端清屏"></a>终端清屏</h2><blockquote><p>使用nodejs调试的时候，输出会在终端显示。终端显示的东西越来越多，看起来很乱，是时候清理一下终端了。</p></blockquote><ul><li><p>清除历史输出</p><p><code>Ctrl + L</code> ，在代码还在运行的使用这个命令是没有用的。</p><p>​    代码停止运行了</p><p><img src="2.gif" alt=""></p></li><li><p>清除全部输出</p><p><code>Ctrl + K</code> ，这个命令需要配置才能使用，在代码运行的时候也是可以使用的。</p><ol><li><p>打开配置文件</p><p><code>Ctrl + Shift + P</code>  打开查询界面，输入 <code>open keyboard Shortcuts</code></p><p><img src="Snipaste_2020-05-08_10-42-09.png" alt=""></p></li><li><p>添加配置</p></li></ol><pre><code>  {    "key": "ctrl+k",    "command": "workbench.action.terminal.clear",    "when": "terminalFocus"  }</code></pre><p>​    保存就可以使用<code>Ctrl + K</code>，干干净净的终端就来了。</p><p><img src="3.gif" alt=""></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 快捷化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode终端快捷命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷化-VSCode中React代码块快速生成</title>
      <link href="/2020/05/07/kuai-jie-hua-vscode-zhong-react-dai-ma-kuai-kuai-su-sheng-cheng/"/>
      <url>/2020/05/07/kuai-jie-hua-vscode-zhong-react-dai-ma-kuai-kuai-su-sheng-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode快速生成代码块–以React为例"><a href="#VSCode快速生成代码块–以React为例" class="headerlink" title="VSCode快速生成代码块–以React为例"></a>VSCode快速生成代码块–以React为例</h1><blockquote><p>写React项目的时候，有时候需要快速生成模板代码，比如生成一个组件，打出几个关键字就可以引入基本依赖和基本代码块。</p></blockquote><h2 id="利用Snippets，设置用户代码块"><a href="#利用Snippets，设置用户代码块" class="headerlink" title="利用Snippets，设置用户代码块"></a>利用Snippets，设置用户代码块</h2><ol><li><p>起步</p><p>文件 –&gt; 首选项 –&gt; 代码块</p><p><img src="Snipaste_2020-05-07_15-31-48.png" alt=""></p><p>选择创建或修改代码段</p><p><img src="Snipaste_2020-05-07_15-36-06.png" alt=""></p><ul><li>创建全局代码片段，所有语言环境都可以触发</li><li>创建对应语言的代码片段，特定语言环境下才能触发</li><li>创建当前项目文件夹的代码片段</li></ul><p>输入代码段文件名</p></li><li><p>使用Snippet语法，设置需要的代码块</p><p>里面会有一个示例：</p><pre><code>"Print to console": {        "scope": "javascript,typescript",         "prefix": "log",         "body": [             "console.log('$1');",             "$2"         ],         "description": "Log output to console"     }</code></pre><ol><li><code>Print to console</code> 代码段的名称</li><li><code>scope</code> 代码段作用的范围</li><li><code>prefix</code> 对应触发代码片段的字符</li><li><code>body</code>代码段的内容</li><li><code>description</code> 对代码段的描述</li></ol></li><li><p>使用</p><p>输入触发代码段的字符串</p></li></ol><p><img src="Snipaste_2020-05-07_15-58-44.png" alt=""></p><ul><li><p>占位符$</p><ul><li><p>使用</p><p><code>$ + 数字</code> 表示代码段落入编辑器后光标的位置，光标位置按从小到大排序。</p></li></ul><p>修改自定义的代码段</p><pre><code>    "Print to console": {        "scope": "javascript,typescript",        "prefix": "log",        "body": [            "console.log('$1');",            " $3 ",            "console.log('$2')",        ],        "description": "Log output to console"    }</code></pre><p><img src="1.gif" alt=""></p><p>​    按<code>Tab</code>会按照数字的顺序（从小到大）跳转，但是注意<code>$0</code>是终止<code>Tab</code>跳转，（<code>$0</code>是最后执行的），数字相同会同时输入。</p><ul><li><p>占位符可选项</p><p><code>${1|可选项1|可选项2|可选项3}</code> 数字指的是光标的落入顺序</p><pre><code>    "方法注释": {        "prefix": "zs-Function",        "body": [            "/**",            " * @param name... { ${1|Boolean,Number,String,Object,Array|} }",            " * @description description...",            " * @return name... { ${2|Boolean,Number,String,Object,Array|} }",            " */",            "$0"        ],        "description": "添加方法注释"    }</code></pre><p><img src="2.gif" alt=""></p><p>​    </p></li></ul></li><li><p>变量</p><p><strong><em>1）文档相关：</em></strong></p><table><thead><tr><th>变量</th><th>变量含义</th></tr></thead><tbody><tr><td><code>TM_SELECTED_TEXT</code></td><td>当前选定的文本或空字符串</td></tr><tr><td><code>TM_CURRENT_LINE</code></td><td>当前行的内容</td></tr><tr><td><code>TM_CURRENT_WORD</code></td><td>光标下的单词内容或空字符串</td></tr><tr><td><code>TM_LINE_INDEX</code></td><td>基于零索引的行号</td></tr><tr><td><code>TM_LINE_NUMBER</code></td><td>基于单索引的行号</td></tr><tr><td><code>TM_FILENAME</code></td><td>当前文档的文件名</td></tr><tr><td><code>TM_FILENAME_BASE</code></td><td>当前文档没有扩展名的文件名</td></tr><tr><td><code>TM_DIRECTORY</code></td><td>当前文档的目录</td></tr><tr><td><code>TM_FILEPATH</code></td><td>当前文档的完整文件路径</td></tr><tr><td><code>CLIPBOARD</code></td><td>剪贴板的内容</td></tr><tr><td><code>WORKSPACE_NAME</code></td><td>已打开的工作空间或文件夹的名称</td></tr></tbody></table><p><strong><em>2）当前日期和时间：</em></strong></p><table><thead><tr><th>变量</th><th>变量含义</th></tr></thead><tbody><tr><td><code>CURRENT_YEAR</code></td><td>当前年份</td></tr><tr><td><code>CURRENT_YEAR_SHORT</code></td><td>当前年份的最后两位数</td></tr><tr><td><code>CURRENT_MONTH</code></td><td>月份为两位数（例如’02’）</td></tr><tr><td><code>CURRENT_MONTH_NAME</code></td><td>月份的全名（例如’June’）（中文语言对应六月）</td></tr><tr><td><code>CURRENT_MONTH_NAME_SHORT</code></td><td>月份的简称（例如’Jun’）（中文语言对应是6月）</td></tr><tr><td><code>CURRENT_DATE</code></td><td>这个月的哪一天</td></tr><tr><td><code>CURRENT_DAY_NAME</code></td><td>当天是星期几（例如’星期一’）</td></tr><tr><td><code>CURRENT_DAY_NAME_SHORT</code></td><td>当天是星期几的简称（例如’Mon’）（中文对应周一）</td></tr><tr><td><code>CURRENT_HOUR</code></td><td>24小时时钟格式的当前小时</td></tr><tr><td><code>CURRENT_MINUTE</code></td><td>当前分</td></tr><tr><td><code>CURRENT_SECOND</code></td><td>当前秒</td></tr></tbody></table><p><strong><em>3）要插入行或块注释，请遵循当前语言：</em></strong></p><table><thead><tr><th>变量</th><th>变量含义</th></tr></thead><tbody><tr><td><code>BLOCK_COMMENT_START</code></td><td>输出：PHP /*或HTML格式&lt;!–</td></tr><tr><td><code>BLOCK_COMMENT_END</code></td><td>输出：PHP */或HTML格式–&gt;</td></tr><tr><td><code>LINE_COMMENT</code></td><td>输出：PHP //或HTML格式</td></tr></tbody></table><p>​    项目中常用的用户代码块：</p><pre><code>{  // Place your snippets for javascriptreact here. Each snippet is defined under a snippet name and has a prefix, body and   // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the   // same ids are connected.  // Example:  "Print to console": {    "prefix": "log",    "body": [      "console.log('$1');",      "$2"    ],    "description": "Log output to console"  },    "db": {        "prefix": "db",        "body": [            "data-behavior=\"$0\""        ],        "description": "data-behavior"    },  "input getDerivedStateFromProps": {    "prefix": "sfp",    "body": [      "static getDerivedStateFromProps(props, states) {",      "\tconst {  } = props;",      "\treturn {",      "\t\t...states,",      "\t};",      "}"    ],    "description": "input getDerivedStateFromProps"  },  "const {} = this.props": {    "prefix": "cp",    "body": [      "const { $0 } = this.props;",    ],    "description": "const {} = this.props"  },  "create a component": {    "prefix": "component",    "body": [      "import React from 'react';",      "import classnames from 'classnames';\n",      "class $1 extends React.Component&lt;I$1Props, I$1States&gt; {\n",      "\trender() {\n\t\t$0\n\t}\n}\n",      "interface I$1Props {\n}\n",      "interface I$1States {\n}\n",      "export default $1;"    ],    "description": "create a component"  },  "create a container": {    "prefix": "container",    "body": [      "import React from 'react';",      "import { inject, observer } from 'mobx-react';",      "import { $2, I$2Props } from '@business/header/header';\n",      "@inject($2)",      "@observer",      "class $1 extends React.Component&lt;I$1Props, I$1States&gt; {\n",      "\trender() {\n\t\t$0\n\t}\n}\n",      "interface I$1Props extends I$2Props {\n}\n",      "interface I$1States {\n}\n",      "export default $1;"    ],    "description": "create a container"  },  "create a hoc": {    "prefix": "hoc",    "body": [      "import React from 'react';",      "import { observer } from 'mobx-react';\n",      "function with$2(WrappedComponent: React.ComponentClass) {\n",      "\t@observer",      "\tclass $2Wrapper extends React.Component&lt;I$2WrapperProps, {}&gt; {\n",      "\t\trender() {",      "\t\t\treturn &lt;WrappedComponent {...this.props} /&gt;;",      "\t\t}",      "\t}",      "\treturn $2Wrapper;",      "}\n",      "interface I$2WrapperProps extends IKeyValueMap {\n",      "}\n",      "export default with$2;"    ],    "description": "create a hoc"  },  "create a intl": {    "prefix": "intl",    "body": [      "&lt;FormattedMessage id=\"$0\" /&gt;"    ],    "description": "create a intl"  },  "import a intl": {    "prefix": "intlimport",    "body": [      "import { FormattedMessage } from 'react-intl';"    ],    "description": "import a intl"  },  "create classnames": {    "prefix": "classnames",    "body": [      "{classnames(\"\", $1)}"    ],    "description": "create classnames"  },  "create a SCU": {    "prefix": "SCU",    "body": "\nshouldComponentUpdate(nextProps, nextState){\n\t$1\n}\n",    "description": "create a SCU"  },  "create a componentWillReceiveProps": {    "prefix": "CWRP",    "body": "\ncomponentWillReceiveProps(nextProps, nextState){\n\t$1\n}\n",    "description": "create a componentWillReceiveProps"  },  "create a componentDidMount": {    "prefix": "CDM",    "body": "\ncomponentDidMount(){\n\t$1\n}\n",    "description": "create a ncomponentDidMount"  },  "create a componentWillUnmount": {    "prefix": "CWUM",    "body": "\ncomponentWillUnmount(){\n\t$1\n}\n",    "description": "create a componentWillUnmount"  },  "create a component test": {    "prefix": "test",    "body": [      "import React from 'react';",      "import { shallow, mount, render } from 'enzyme';",      "import renderer from 'react-test-renderer';\n",      "describe('$1', () =&gt; {\n\t$0\n});",    ],    "description": "create a component test"  },  "create a it test": {    "prefix": "it",    "body": [      "it('$1', () =&gt; {\n\t$0\n});"    ],  },    "description": "create a it test"}</code></pre></li></ul><h1 id="使用VSCode插件–ES7-React-Redux-GraphQL-React-Native-snippets"><a href="#使用VSCode插件–ES7-React-Redux-GraphQL-React-Native-snippets" class="headerlink" title="使用VSCode插件–ES7 React/Redux/GraphQL/React-Native snippets"></a>使用VSCode插件–ES7 React/Redux/GraphQL/React-Native snippets</h1><p>  ​    安装这个插件后，使用内置的命令实现快速生成代码块</p><p>  <img src="3.gif" alt=""></p><p>  详情可查看github:<a href="https://github.com/dsznajder/vscode-es7-javascript-react-snippets">https://github.com/dsznajder/vscode-es7-javascript-react-snippets</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 快捷化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode快捷化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-清除浮动</title>
      <link href="/2020/05/07/css-qing-chu-fu-dong/"/>
      <url>/2020/05/07/css-qing-chu-fu-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS清除浮动"><a href="#CSS清除浮动" class="headerlink" title="CSS清除浮动"></a>CSS清除浮动</h1><h2 id="为什么需要清除浮动"><a href="#为什么需要清除浮动" class="headerlink" title="为什么需要清除浮动"></a>为什么需要清除浮动</h2><p>​    当容器高度为<code>auto</code>的时候，且容器内包含浮动的元素，这种情况下容器不能自动拉伸适应内容的高度，使得内容溢出到容器外面，这种现象称为浮动溢出。</p><p>​    没有使用浮动</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;css为什么需要清除浮动&lt;/title&gt;  &lt;style&gt;    .box {      width: 500px;      background-color: skyblue;    }    .div1 {      height: 300px;      width: 100px;      background-color: pink;    }    .div2 {      height: 400px;      width: 200px;      background-color: purple;    }    .footer {      height: 100px;      background-color: black;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class="box"&gt;    &lt;div class="div1"&gt;1&lt;/div&gt;    &lt;div class="div2"&gt;2&lt;/div&gt;  &lt;/div&gt;  &lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="Snipaste_2020-05-07_13-51-47.png" alt=""></p><p>​    父盒子没有定义高度，子盒子定义了高度，父盒子可以自适应高度。</p><p>​    当使用浮动，父盒子不能自适应高度。</p><p><img src="Snipaste_2020-05-07_14-00-04.png" alt=""></p><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><ul><li><p><strong>使用带clear属性的空元素（额外标签法）</strong></p><blockquote><p>在浮动元素后加一个空元素，例如<code>&lt;div class='clear'&gt;&lt;/div&gt;</code> ，并在css中<code>.clear{clear:both}</code>，就可以清除浮动。</p></blockquote><p><img src="Snipaste_2020-05-07_14-09-36.png" alt=""></p><p>这种方法代码少，但添加了空白标签，代码不优雅，后期不容易维护。</p></li><li><p><strong>给父元素添加overflow属性</strong></p><blockquote><p>给父元素添加<code>overflow:hidden</code> 或 <code>overfloaw:auto</code>，可以清除浮动。</p></blockquote><p><img src="Snipaste_2020-05-07_14-18-14.png" alt=""></p></li><li><p><strong>使用:after伪元素</strong></p><blockquote><p>在父级元素的最后添加一个<code>:after</code>伪元素</p></blockquote></li></ul><p>​    在父元素添加类似如下的样式</p><pre><code>.clearfix:after {    content: '.';    height: 0;    display: block;    clear: both;}//兼容IE6、7.clearfix {    *zoom: 1; } </code></pre><p><img src="Snipaste_2020-05-07_14-39-43.png" alt=""></p><p>​    伪元素的<code>display</code>是<code>block</code> ，它实际上是一个不可见的块级元素，这是第一种方法的变形使用。</p><p>​    需要兼容IE6、7.</p><ul><li><p><strong>使用双伪元素</strong></p><blockquote><p>完全闭合浮动</p></blockquote><p>​    父元素添加类似的样式</p><pre><code>.clearfix:before, .clearfix:after {        content: "";         display: table;    }    .clearfix:after {        clear: both;    }    //兼容IE6、7    .clearfix {        *zoom: 1;    }</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongoDB异步取数据</title>
      <link href="/2020/04/29/mongodb-yi-bu-qu-shu-ju/"/>
      <url>/2020/04/29/mongodb-yi-bu-qu-shu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="mongoDB异步获取数据"><a href="#mongoDB异步获取数据" class="headerlink" title="mongoDB异步获取数据"></a>mongoDB异步获取数据</h1><blockquote><p>介绍一下背景</p><p><img src="Snipaste_2020-04-29_17-57-16.png" alt=""></p><p>​    这四个订单分类下面有若干订单，我需要统计出来可视化展示，我先获取了分类的唯一标识<code>_id</code>，把它们放入到一个数组中，接下来就是要获取每个分类下面有多少订单数目</p></blockquote><p>​    接下来就是我的骚操作了：</p><p>​        数据库操作的代码：</p><p><img src="image-20200429192823808.png" alt=""></p><p>​        请求过程：</p><p><img src="Snipaste_2020-04-29_19-34-40.png" alt=""></p><p><img src="Snipaste_2020-04-29_19-35-57.png" alt=""></p><p>​    首先就算分类下面没有订单，也会返回0，然后我们看数据库那一块代码。</p><p><img src="Snipaste_2020-04-29_19-40-01.png" alt=""></p><p>​    有两个输出，从结果来看，查询还没有结束就已经返回了。是因为异步的原因，那么怎么解决等数据库查询结束后在返回我们需要的数据。</p><p>我的解决方案是使用<code>Async</code> ，首先需要安装<code>npm i anync --save</code>，查看文档</p><pre><code>官方文档：https://github.com/caolan/async第三方注释文档：https://github.com/bsspirit/async_demo</code></pre><p>选择合适的api，针对我的使用场景，我选用了 <code>async.eachSeries</code>，一个一个按循序执行。</p><p>​    改造完的代码：</p><p><img src="Snipaste_2020-04-29_19-52-50.png" alt=""></p><p>现在就没问题了：</p><p><img src="Snipaste_2020-04-29_19-53-50.png" alt=""></p><p>还有其它的解决办法，我后续补充……………………….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实战-快报</title>
      <link href="/2020/04/28/css-shi-zhan-kuai-bao/"/>
      <url>/2020/04/28/css-shi-zhan-kuai-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS实战-快报"><a href="#CSS实战-快报" class="headerlink" title="CSS实战-快报"></a>CSS实战-快报</h1><p>实现效果：</p><p><img src="Snipaste_2020-04-28_16-32-33.png" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;快报&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;      padding: 0;    }    li {      list-style: none;    }    /* a {      text-decoration: none;      color: #666;    } */    .box {      width: 290px;      height: 160px;      margin: 100px auto;      border: 1px solid #ccc    }    .box h3 {      height: 30px;      font-size: 14px;      line-height: 30px;      font-weight: 400;      padding-left: 15px;      border-bottom: 1px dotted #ccc;    }    .box ul li a {      font-size: 12px;      color: #666;      text-decoration: none;    }    .box ul li {      padding-left: 18px;      padding-top: 10px;      font-size: 12px;    }    .box ul li a:hover {      text-decoration: underline;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class="box"&gt;    &lt;h3&gt;新闻大揭秘&lt;/h3&gt;    &lt;ul&gt;      &lt;li&gt;&lt;a href="#"&gt;【惊天大新闻】我也不知道写点啥&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;【惊天大新闻】我也不知道写点啥&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;【惊天大新闻】我也不知道写点啥&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;【惊天大新闻】我也不知道写点啥&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-生命周期加载顺序引发的思考</title>
      <link href="/2020/04/28/react-sheng-ming-zhou-qi-jia-zai-shun-xu-yin-fa-de-si-kao/"/>
      <url>/2020/04/28/react-sheng-ming-zhou-qi-jia-zai-shun-xu-yin-fa-de-si-kao/</url>
      
        <content type="html"><![CDATA[<h1 id="React生命周期加载顺序引发的思考"><a href="#React生命周期加载顺序引发的思考" class="headerlink" title="React生命周期加载顺序引发的思考"></a>React生命周期加载顺序引发的思考</h1><p>​    在写毕业设计的时候用到了<code>componentWillMount(已经不推荐使用了)</code>  和<code>componentDidMount</code>两个生命周期，<code>componentWillMount</code>  里面写了请求， <code>componentDidMount</code>里面也写了请求（<del>原谅我的骚操作</del>），而<code>componentDidMount</code>里面的请求依赖<code>componentWillMount</code>里面的请求（<del>是不是很骚</del>），但是<code>componentDidMount</code>并没有接收到<code>componentWillMount</code>请求来的数据，我就有点纳闷，按照加载顺序不应该是这样的，模拟一下当时的情况：</p><p><img src="Snipaste_2020-04-28_11-47-24.png" alt=""></p><p>​    它会按生命周期的顺序加载，但不会同步等待完成在进行另一个生命周期，还有请求数据的话，一般放到<code>componentDidMount</code>里面去执行，问题来了，为什么要放在<code>componentDitMount</code>里面去请求数据。</p><p>​    React16以后采用了 <code>Fiber</code> 架构，一次更新过程被分为很多的片段，不在是一开始更新就不能停止的状态，会存在一个更新片段还没更新完，就被另一个优先级更高的片段取代，导致优先级相对较低的片段的更新任务完全废止，直到下一次被调用。</p><pre><code>采用fiber的原因以及优先级的解释：    React的渲染分为两个阶段：        调度阶段： 更新数据，生成虚拟DOM，根据diff算法查出需要更新的真实DOM，放入更新队列        渲染阶段： 将更新队列的数据一次性更新到真实DOM上    调度阶段是不可控的，整个阶段的主线程都被占用，这个阶段用户的操作得不到反馈，只有当React中的同步更新完成之后主线程才会被释放。    fiber会让我们获得以下权限：        1：暂停运行的任务        2：恢复并继续执行任务        3：确定优先级    fiber创建了自己的堆栈帧，而没有使用JavaScript的堆栈帧，就可以使上述的权限成为可能，将调度任务拆分成一小段并设定执行时间。    优先级的确定：        文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</code></pre><p>调度阶段的生命周期：</p><ul><li>construct</li><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>render</li><li><del>componentWillMount</del></li><li><del>componentWillReceiveProps</del></li><li><del>componentWillUpdate</del></li></ul><p><strong>加删除线的生命周期是准备废弃的</strong></p><p>渲染阶段的生命周期：</p><ul><li><p>componentDidMount</p></li><li><p>componentDidUpdate</p></li><li><p>componentWillUnmount</p><p>由于调度阶段的更新任务可能被打断重新开始，所以调度阶段的生命周期可能会执行多次。</p></li></ul><p>纵向分析的话，生命周期分为三个阶段：</p><ol><li>挂载阶段</li></ol><ul><li>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this</li><li>getDerivedStateFromProps: <code>static getDerivedStateFromProps(nextProps, prevState)</code>,这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps</li><li>render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</li><li>componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅</li></ul><ol><li>更新阶段<ul><li>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</li><li>shouldComponentUpdate: <code>shouldComponentUpdate(nextProps, nextState)</code>,有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能</li><li>render: 更新阶段也会触发此生命周期</li><li>getSnapshotBeforeUpdate: <code>getSnapshotBeforeUpdate(prevProps, prevState)</code>,这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用</li><li>componentDidUpdate: <code>componentDidUpdate(prevProps, prevState, snapshot)</code>,该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态</li></ul></li><li>卸载阶段<ul><li>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作</li></ul></li></ol><p>补一张最新的生命周期图：</p><p>查看React生命周期的网站：<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p><p><img src="Snipaste_2020-04-28_15-11-30.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-定位</title>
      <link href="/2020/04/27/css-ding-wei/"/>
      <url>/2020/04/27/css-ding-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS-定位"></a>CSS-定位</h1><h2 id="为什么需要定位？"><a href="#为什么需要定位？" class="headerlink" title="为什么需要定位？"></a>为什么需要定位？</h2><p>实现标准流和浮动都无法实现的效果。浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子。定位则是可以让盒子自由的在某个盒子内移动位置或固定到某个位置，并且可以压住其他盒子。</p><h2 id="定位的组成"><a href="#定位的组成" class="headerlink" title="定位的组成"></a>定位的组成</h2><blockquote><p>将盒子固定在某个位置</p></blockquote><p>定位 = 定位模式 + 边偏移</p><p>定位模式用于指定一个元素在文档中的定位方式。边偏移则决定该元素的最终位置。</p><h3 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h3><p>定位模式决定元素的定位方式，它通过CSS的position属性来设置，其值可以分为四个：</p><table><thead><tr><th>值</th><th>语义</th></tr></thead><tbody><tr><td>static</td><td>静态定位</td></tr><tr><td>relative</td><td>相对定位</td></tr><tr><td>absolute</td><td>绝对定位</td></tr><tr><td>fixed</td><td>固定定位</td></tr></tbody></table><h3 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h3><p>边偏移就是定位盒子移动的最终位置。有top、bottom、left 和 right 4个属性。</p><table><thead><tr><th>属性</th><th>语义</th></tr></thead><tbody><tr><td>top</td><td>顶端偏移量，相对其父元素上边线的距离</td></tr><tr><td>bottom</td><td>底部偏移量，相对其父元素下边线的距离</td></tr><tr><td>left</td><td>左侧偏移量，相对其父元素左边线的距离</td></tr><tr><td>right</td><td>右侧偏移量，相对其父元素右边线的距离</td></tr></tbody></table><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h2 id="静态定位（static）"><a href="#静态定位（static）" class="headerlink" title="静态定位（static）"></a>静态定位（static）</h2><p>静态定位是元素的默认定位方式，无定位的意思。</p><p>语法：</p><pre><code>选择器 { position: static;}        </code></pre><ul><li>静态定位按照标准流特性摆放位置，它没有边偏移</li><li>静态定位在布局中很少使用</li></ul><h3 id="相对定位（relative）"><a href="#相对定位（relative）" class="headerlink" title="相对定位（relative）"></a>相对定位（relative）</h3><p>相对定位是元素在移动位置的时候，是相对于它的原来位置来说的。</p><p>语法：</p><pre><code>选择器 {position: relative;}</code></pre><p>相对定位的特点：</p><ol><li>它相对于自己原来的位置来移动的</li><li>原来在标准流的位置继续占有，后面的盒子任然以标准流的方式对待它（不脱标，继续保留原来的位置）</li></ol><p>最典型的应用是给绝对定位当<code>爹</code> </p><p>没有使用定位前：</p><p><img src="Snipaste_2020-07-09_16-14-14.png" alt=""></p><p>使用了定位：</p><p><img src="Snipaste_2020-07-09_16-16-26.png" alt=""></p><p>虽然 div1 离开了最初的位置，但是 div2 没有到改变自己的位置，div1的位置继续保留，没有脱标。</p><h3 id="绝对定位（absolute）"><a href="#绝对定位（absolute）" class="headerlink" title="绝对定位（absolute）"></a>绝对定位（absolute）</h3><p>绝对定位是元素在移动位置的时候，是相对它的祖先元素来说的</p><p>语法：</p><pre><code>选择器 { position: absolute; }</code></pre><p>绝对定位的特点：</p><ol><li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document文档）</li><li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级有定位祖先元素为参考点移动位置</li><li>绝对定位不在占有原先的位置（脱标）</li></ol><h3 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h3><blockquote><p>子级是绝对定位的话，父级要用相对定位</p></blockquote><ol><li>子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个位置，不会影响其他的兄弟盒子。</li><li>父盒子需要加定位限制子盒子在父盒子内显示。</li><li>父盒子布局的时候，需要占有位置，因此父亲只能是相对定位。</li></ol><p>当然子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。</p><p>示例：</p><p>​    父盒子没有使用定位，子盒子就相对浏览器定位</p><p><img src="Snipaste_2020-07-12_15-26-20.png" alt=""></p><p>父盒子使用定位后：</p><p><img src="Snipaste_2020-07-12_15-37-06.png" alt=""></p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>固定定位元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时元素的位置不发生变化。</p><p>语法：</p><pre><code>选择器 { position: fixed;}</code></pre><p>固定定位的特点：</p><ol><li>以浏览器的可视窗口为参照点移动元素<ul><li>跟父元素没有任何关系</li><li>不随滚动条滚动</li></ul></li><li>固定定位不占有原先的位置（脱标）</li></ol><h4 id="小技巧-固定在版心右侧的位置"><a href="#小技巧-固定在版心右侧的位置" class="headerlink" title="小技巧-固定在版心右侧的位置"></a>小技巧-固定在版心右侧的位置</h4><ol><li>让固定定位的盒子left:50%.走到浏览器可视区域的一半</li><li>让固定定位的盒子margin-left：版心宽度的一半距离. 多走版心宽度的一半</li></ol><h3 id="粘性定位（sticky）"><a href="#粘性定位（sticky）" class="headerlink" title="粘性定位（sticky）"></a>粘性定位（sticky）</h3><p>粘性定位可以被认为是相对定位和固定定位的混合。</p><p>语法：</p><pre><code>选择器 { position: sticky;top: 10px;}</code></pre><p>特点：</p><ul><li>以浏览器的可视窗户口为参照点移动元素（固定定位的特点）</li><li>占有原先的位置（相对定位的特点）</li><li>必须添加 top、left、right、bottom其中的一个才有效</li></ul><p>跟页面滚动搭配使用。兼容性差、IE不支持。</p><p>最右边的那个盒子就是<code>sticky</code>的效果</p><p><img src="1.gif" alt=""></p><h3 id="定位叠放次序（z-index）"><a href="#定位叠放次序（z-index）" class="headerlink" title="定位叠放次序（z-index）"></a>定位叠放次序（z-index）</h3><p>在使用定位布局时，可能会出现盒子盒子重叠的情况。此时，可以使用z-indx来控制盒子的前后次序（z轴）</p><p>语法：</p><pre><code>选择器{z-index : 1;} </code></pre><ul><li>数值可以是整数、负数或零，默认为auto，数值越大，盒子越靠上</li><li>如果属性值相同，则按照书写顺序，后来者居上</li><li>数字后面不能加单位</li><li>只用定位的盒子才有 z-index 属性</li></ul><h3 id="定位的扩展"><a href="#定位的扩展" class="headerlink" title="定位的扩展"></a>定位的扩展</h3><h4 id="绝对定位的盒子实现水平居中（固定定位的盒子贴在版心右侧）"><a href="#绝对定位的盒子实现水平居中（固定定位的盒子贴在版心右侧）" class="headerlink" title="绝对定位的盒子实现水平居中（固定定位的盒子贴在版心右侧）"></a>绝对定位的盒子实现水平居中（固定定位的盒子贴在版心右侧）</h4><p>不能通过<code>margin:0 auto</code>实现</p><p>通过：</p><ol><li><p>left: 50% 让盒子的左侧移动到父元素的水平中心位置</p></li><li><p>margin-left: -100px 让盒子向左移动自身宽度的一半</p></li></ol><p>实现垂直居中也是这个原理</p><h4 id="定位的特殊性"><a href="#定位的特殊性" class="headerlink" title="定位的特殊性"></a>定位的特殊性</h4><p>绝对定位和固定定位也和浮动类似</p><ol><li>行内元素添加最对或固定定位，可以直接设置高度和宽度</li><li>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小(不会占据一整行)</li></ol><h4 id="绝对定位-固定定位-会完全压住盒子"><a href="#绝对定位-固定定位-会完全压住盒子" class="headerlink" title="绝对定位(固定定位)会完全压住盒子"></a>绝对定位(固定定位)会完全压住盒子</h4><p>浮动元素不同，只会压住它下面的标准流盒子，但不会压住下面标准流盒子里面的文字(图片)。</p><p>但绝对定位(固定定位)会压住下面标准流所有的内容。</p><p>浮动之所以不会压住文字，是因为浮动产生的目的是为了做文字的环绕效果的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-传统网页布局方式</title>
      <link href="/2020/04/27/css-chuan-tong-wang-ye-bu-ju-fang-shi/"/>
      <url>/2020/04/27/css-chuan-tong-wang-ye-bu-ju-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="传统网页的布局方式"><a href="#传统网页的布局方式" class="headerlink" title="传统网页的布局方式"></a>传统网页的布局方式</h1><h2 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h2><p>​    普通流就是按照<code>元素的显示模式</code>进行排列，块级元素就独占一行，行内元素和行内块元素能排列在同一行的话就排列在同一行。</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><a href="/2020/04/27/css-fu-dong/" title="CSS-浮动">CSS-浮动</a><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><a href="/2020/04/27/css-ding-wei/" title="CSS-定位">CSS-定位</a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-浮动</title>
      <link href="/2020/04/27/css-fu-dong/"/>
      <url>/2020/04/27/css-fu-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS浮动（float）"><a href="#CSS浮动（float）" class="headerlink" title="CSS浮动（float）"></a>CSS浮动（float）</h1><h2 id="什么是浮动"><a href="#什么是浮动" class="headerlink" title="什么是浮动"></a>什么是浮动</h2><blockquote><p>float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘</p></blockquote><p>语法：</p><pre><code>选择器{ float:属性值 }</code></pre><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动</td></tr><tr><td>left</td><td>元素左浮动</td></tr><tr><td>right</td><td>元素右浮动</td></tr></tbody></table><p>​    普通流：</p><p><img src="Snipaste_2020-04-27_16-19-40.png" alt=""></p><p>使用浮动：</p><p>​    <img src="Snipaste_2020-04-27_16-21-34.png" alt=""></p><h2 id="浮动特性"><a href="#浮动特性" class="headerlink" title="浮动特性"></a>浮动特性</h2><ul><li><p>脱离标准流（脱标）</p><p>不会按标准流来排列，会把原来的位置空出来</p><p><img src="Snipaste_2020-04-27_16-34-26.png" alt=""></p><p>​    第一个盒子使用了<code>左浮动</code>，第二个盒子是标准流排列，第一个盒子把第二个遮住了，是因为第一个盒子使用了浮动，把原来的位置空出来了，第二个盒子就从第一个盒子空出来的位置进行排列，但第一个盒子使用的是左浮动，就把第二个盒子覆盖了。</p></li><li><p>具有行内元素的特性</p><p><img src="Snipaste_2020-04-27_16-46-43.png" alt=""></p><p>会像行内元素一样，在同一行并排显示，之间不会有空隙</p></li></ul><h2 id="浮动元素经常搭配标准流的父元素"><a href="#浮动元素经常搭配标准流的父元素" class="headerlink" title="浮动元素经常搭配标准流的父元素"></a>浮动元素经常搭配标准流的父元素</h2><blockquote><p>纵行显示找标准流，横排显示找浮动</p></blockquote><p>​    <img src="Snipaste_2020-04-27_17-06-50.png" alt=""></p><p>​    一个大的标准流父元素包含若干个浮动元素</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-阴影</title>
      <link href="/2020/04/26/css-yin-ying/"/>
      <url>/2020/04/26/css-yin-ying/</url>
      
        <content type="html"><![CDATA[<h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><h2 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h2><blockquote><p>box-shadow设置盒子的阴影</p></blockquote><p><img src="yinying3.gif" alt=""></p><table><thead><tr><th>值</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>h-shadow</td><td>长度值</td><td>必需，水平阴影的位置</td></tr><tr><td>v-shadow</td><td>长度值</td><td>必需，垂直阴影的位置</td></tr><tr><td>blur</td><td>长度值</td><td>可选，设置阴影的模糊度</td></tr><tr><td>color</td><td>颜色值</td><td>可选，设置阴影的颜色</td></tr><tr><td>inset</td><td>阴影在边框外，即阴影向外扩散,指定inset阴影在盒子内</td><td>可选</td></tr></tbody></table><h2 id="水平、垂直阴影位置解释"><a href="#水平、垂直阴影位置解释" class="headerlink" title="水平、垂直阴影位置解释"></a>水平、垂直阴影位置解释</h2><pre><code> .nav {      height: 300px;      width: 300px;      line-height: 300px;      margin: 100px auto;      background-color: pink;      text-align: center;      box-shadow: 10px 20px black;    }</code></pre><p><img src="yinying1.gif" alt=""></p><p><img src="Snipaste_2020-04-27_11-36-53.png" alt=""></p><h3 id="blur-属性解释"><a href="#blur-属性解释" class="headerlink" title="blur 属性解释"></a>blur 属性解释</h3><pre><code>.nav {      height: 300px;      width: 300px;      line-height: 300px;      margin: 100px auto;      background-color: pink;      text-align: center;      box-shadow: 5px 5px 5px rgba(0, 0, 0, .6);    }</code></pre><p><img src="yinying2.gif" alt=""></p><p><code>blur</code>越大越模糊，越小越清晰</p><h3 id="关于inset"><a href="#关于inset" class="headerlink" title="关于inset"></a>关于<code>inset</code></h3><p>​    使用 <code>inset</code> 关键字会使得阴影落在盒子内部，这样看起来就像是内容被压低了。 此时阴影会在边框之内 (即使是透明边框）、背景之上、内容之下。</p><p><img src="Snipaste_2020-04-27_13-52-17.png" alt=""></p><h2 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h2><blockquote><p>text-shadow，设置文字阴影，可以有两三个<code>lenght</code>参数</p></blockquote><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>color</td><td>设置阴影颜色</td></tr><tr><td>offset-x  offset-y</td><td>以文字中心为中标原点，设置<code>xy</code>轴的偏移</td></tr><tr><td>blur</td><td>阴影模糊度</td></tr></tbody></table><pre><code> span {      text-shadow: pink 10px 10px 10px;    }</code></pre><p><img src="Snipaste_2020-04-27_13-51-10.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-圆角边框</title>
      <link href="/2020/04/26/css-yuan-jiao-bian-kuang/"/>
      <url>/2020/04/26/css-yuan-jiao-bian-kuang/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS圆角边框"><a href="#CSS圆角边框" class="headerlink" title="CSS圆角边框"></a>CSS圆角边框</h1><blockquote><p>盒子不仅仅有矩形，还可以设置圆角，通过<code>border-radius</code>设置</p></blockquote><p><img src="Snipaste_2020-04-26_19-36-43.png" alt=""></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><blockquote><p>属性值： 长度单位 或 百分比，用属性值来设置边框圆角半径</p></blockquote><ul><li><p>一个参数</p><blockquote><p>设置四个角的圆角半径</p></blockquote><pre><code> .nav1 {      height: 300px;      width: 300px;      background-color: pink;      line-height: 300px;      text-align: center;      margin: 100px auto;      border-radius: 20px;    }</code></pre></li></ul><p>  <img src="CSS-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/Snipaste_2020-04-27_09-46-00.png" alt=""></p><ul><li><p>两个参数</p><blockquote><p>设置<code>左上角、右下角</code> 和 <code>右上角、左下角</code>的边框半径</p></blockquote><pre><code>  .nav2 {      height: 300px;      width: 300px;      line-height: 300px;      text-align: center;      background-color: red;      margin: 100px auto;      border-radius: 20px 40px;    }</code></pre></li></ul><p>  <img src="CSS-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/Snipaste_2020-04-27_09-49-42.png" alt=""></p><ul><li><p>三个参数</p><blockquote><p>设置<code>左上角</code>  <code>右上角、左下角</code> <code>右下角</code> 的边框半径</p></blockquote><pre><code>.nav3 {      height: 300px;      width: 300px;      line-height: 300px;      text-align: center;      background-color: lightblue;      margin: 100px auto;      border-radius: 20px 40px 60px;    }</code></pre></li></ul><p>  <img src="CSS-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/Snipaste_2020-04-27_09-52-25.png" alt=""></p><ul><li><p>四个参数</p><blockquote><p>按顺时针方向设置每个角的圆角边框</p></blockquote><pre><code>.nav4 {      height: 300px;      width: 300px;      line-height: 300px;      text-align: center;      background-color: purple;      margin: 100px auto;      border-radius: 20px 40px 60px 80px;    }</code></pre></li></ul><p>  <img src="CSS-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/Snipaste_2020-04-27_09-55-07.png" alt=""></p><ul><li><p>单独设置每个角的圆角边框</p><pre><code>.nav5 {      height: 300px;      width: 300px;      line-height: 300px;      text-align: center;      background-color: pink;      margin: 100px auto;      border-top-left-radius: 10px;      border-top-right-radius: 30px;      border-bottom-right-radius: 50px;      border-bottom-left-radius: 70px;    }</code></pre><p><img src="CSS-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/Snipaste_2020-04-27_10-00-22.png" alt=""></p></li></ul><h2 id="圆角边框原理"><a href="#圆角边框原理" class="headerlink" title="圆角边框原理"></a>圆角边框原理</h2><blockquote><p>是时候展示真正的技术了，上图</p></blockquote><p><img src="CSS-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/Snipaste_2020-04-27_10-06-21.png" alt=""></p><p>​    以第三个div为例，代码如下</p><pre><code>.nav3 {      height: 300px;      width: 300px;      line-height: 300px;      text-align: center;      background-color: lightblue;      margin: 100px auto;      border-radius: 20px 40px 60px;    }</code></pre><p>​    它的圆角边框的半径分别是: <code>左上：20px 右上 左下：40px 右下：60px</code> ，想象一下（看图），有三个半径为 20px 、40px、60px的圆跟盒子的四个角相切，很不是就明白了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件资源</title>
      <link href="/2020/04/24/ruan-jian-zi-yuan/"/>
      <url>/2020/04/24/ruan-jian-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="下载神器-IDM"><a href="#下载神器-IDM" class="headerlink" title="下载神器-IDM"></a>下载神器-IDM</h1><p>IDM下载：</p><p><a href="https://muyeyong.lanzous.com/ibvwclc" target="_blank" rel="noopener">https://muyeyong.lanzous.com/ibvwclc</a></p><p>油猴(tampermonkey)插件下载：</p><p><a href="https://muyeyong.lanzous.com/ibw442d" target="_blank" rel="noopener">https://muyeyong.lanzous.com/ibw442d</a></p><p>在这里插个坑，还需要把使用教程补上。</p><h1 id="GIF制作"><a href="#GIF制作" class="headerlink" title="GIF制作"></a>GIF制作</h1><p><a href="https://muyeyong.lanzous.com/i5Mxhdk9vib" target="_blank" rel="noopener">https://muyeyong.lanzous.com/i5Mxhdk9vib</a></p><h1 id="PS破解版"><a href="#PS破解版" class="headerlink" title="PS破解版"></a>PS破解版</h1><p><a href="https://pan.baidu.com/s/1_SGVRWLIWcGSRpYpQwYOkQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1_SGVRWLIWcGSRpYpQwYOkQ</a></p><p>提取码：j74b</p><h1 id="FastStone-Capture"><a href="#FastStone-Capture" class="headerlink" title="FastStone Capture"></a>FastStone Capture</h1><p><a href="https://muyeyong.lanzous.com/i0HNedk9rxc" target="_blank" rel="noopener">https://muyeyong.lanzous.com/i0HNedk9rxc</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷化-HTML快速填充</title>
      <link href="/2020/04/24/kuai-jie-hua-html-kuai-su-tian-chong/"/>
      <url>/2020/04/24/kuai-jie-hua-html-kuai-su-tian-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML代码快速填充"><a href="#HTML代码快速填充" class="headerlink" title="HTML代码快速填充"></a>HTML代码快速填充</h1><p>​    使用Emmet语法批量生成HTML标签时，可以使用 <code>Shift + Alt + 鼠标左键</code> 就可以批量填充内容。</p><p><img src="Snipaste_2020-04-24_17-53-48.png" alt=""></p><p><img src="Snipaste_2020-04-24_17-54-08.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 快捷化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML代码快速填充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PS-基本操作</title>
      <link href="/2020/04/24/ps-ji-ben-cao-zuo/"/>
      <url>/2020/04/24/ps-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="PS基本操作"><a href="#PS基本操作" class="headerlink" title="PS基本操作"></a>PS基本操作</h1><h2 id="打开标尺"><a href="#打开标尺" class="headerlink" title="打开标尺"></a>打开标尺</h2><p><code>Ctr + R</code> : 打开或关闭视图</p><h2 id="视图放大缩小"><a href="#视图放大缩小" class="headerlink" title="视图放大缩小"></a>视图放大缩小</h2><p><code>Ctr + +</code>:   放大视图</p><p><code>Ctr + -</code>: 缩小视图</p><h2 id="拖动视图"><a href="#拖动视图" class="headerlink" title="拖动视图"></a>拖动视图</h2><p><code>按住空格鼠标会自动变成小手，就可以进行拖动</code>                        </p><h2 id="测量视图大小"><a href="#测量视图大小" class="headerlink" title="测量视图大小"></a>测量视图大小</h2><p><img src="Snipaste_2020-04-24_17-08-29.png" alt=""></p><p>点击就可以对视图进行测量大小</p><h2 id="取色"><a href="#取色" class="headerlink" title="取色"></a>取色</h2><p><img src="Snipaste_2020-04-24_17-09-33.png" alt=""></p><p>点击就可以取色</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实战-小米商品展示</title>
      <link href="/2020/04/24/css-shi-zhan-xiao-mi-shang-pin-zhan-shi/"/>
      <url>/2020/04/24/css-shi-zhan-xiao-mi-shang-pin-zhan-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS实战-小米商品展示"><a href="#CSS实战-小米商品展示" class="headerlink" title="CSS实战-小米商品展示"></a>CSS实战-小米商品展示</h1><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="Snipaste_2020-04-24_17-14-40.png" alt=""></p><h2 id="使用技能"><a href="#使用技能" class="headerlink" title="使用技能"></a>使用技能</h2><p>​    1. PS的基本操作（测量视图的大小、取色）</p><p>​    2. margin、padding的使用</p><pre><code>3. 居中操作（块级元素居中、行内元素居中、图片居中） 4. 字体属性的应用 5. 行内元素 和 块级元素 的转换</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol><li><p>先把图片截下来（选取效果图的第一个图片进行操作）</p><p>使用<code>Snipaste</code> 截取图片</p></li><li><p>分析构造</p><p><img src="Snipaste_2020-04-24_17-19-10.png" alt=""></p></li></ol><p>可以分为四个盒子</p><pre><code>     第一个盒子： 使用了图片，图片需要水平居中</code></pre><p>​        二、三、四个盒子：都是对文字的操作</p><p>​        整体： 鼠标放上去会变成手，需要加上a链接，需要去除a链接的默认样式</p><ol start="3"><li>编码</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;小米商品展示&lt;/title&gt;  &lt;style&gt;    * {      padding: 0;      margin: 0;    }    a {      text-decoration: none;      color: #333;    }    body {      background-color: #f5f5f5;    }    .product-father {      display: block;      width: 235px;      height: 300px;      margin: 100px auto;      background-color: #fff;    }    .product {      padding: 20px 0;      height: 260px;    }    .product .figure-img {      margin: 0 37px 18px 37px;    }    .product .figure-img img {      width: 160px;      height: 160px;    }    .product h4 {      font-size: 14px;      font-weight: 400;      text-align: center;      margin-bottom: 6px    }    .product .decs {      font-size: 12px;      text-align: center;      color: #c2b0b0;      padding-bottom: 17px;    }    .product .buttom {      text-align: center;      font-size: 14px;    }    .product .buttom .left {      color: #ff6700;    }    .product .buttom .right {      color: #c2b0b0;      margin-left: 8px;      text-decoration: line-through;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- shift + alt + 鼠标左键 --&gt;  &lt;a href="#" class="product-father"&gt;    &lt;div class="product"&gt;      &lt;div class="figure-img"&gt;        &lt;img src="./imags/earphone.jpg" alt="耳机"&gt;      &lt;/div&gt;      &lt;h4&gt;小米真无线蓝牙耳机Air 2&lt;/h4&gt;      &lt;div class="decs"&gt;智能真无线，轻松舒适戴&lt;/div&gt;      &lt;div class="buttom"&gt;        &lt;span class='left'&gt;369&lt;/span&gt; &lt;span class="right"&gt;399&lt;/span&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>首先需要先消除每个元素的内外边距</li><li>如果没有指定元素的宽或高，margin padding  不会撑大盒子</li><li>注意HTML的语义化</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> padding margin 应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试-VSCode</title>
      <link href="/2020/04/19/diao-shi-vscode/"/>
      <url>/2020/04/19/diao-shi-vscode/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode调试"><a href="#VSCode调试" class="headerlink" title="VSCode调试"></a>VSCode调试</h1><h2 id="在nodejs中调试"><a href="#在nodejs中调试" class="headerlink" title="在nodejs中调试"></a>在nodejs中调试</h2><ol><li>点击图标</li></ol><p><img src="Snipaste_2020-04-26_18-04-19.png" alt=""></p><ol start="2"><li>编辑或新建配置文件</li></ol><p><img src="Snipaste_2020-04-26_18-05-46.png" alt=""></p><ol start="3"><li>点击编辑的图标</li></ol><p>​    进入编辑配置文件的文件（没有配置文件会新建）</p><ol start="4"><li>编辑配置文件</li></ol><p><img src="Snipaste_2020-04-26_18-09-49.png" alt=""></p><p><img src="Snipaste_2020-04-26_18-12-20.png" alt=""></p><ol start="5"><li><p>进行调试</p><p>单击<code>F5</code>进行调试，在代码的左侧<code>鼠标右键单击</code>添加断点</p><p><img src="Snipaste_2020-04-26_18-15-20.png" alt=""></p><p><img src="Snipaste_2020-04-26_18-14-39.png" alt=""></p></li></ol><h2 id="在Chrome中调试"><a href="#在Chrome中调试" class="headerlink" title="在Chrome中调试"></a>在Chrome中调试</h2><ol><li>下载<code>Debugger for Chrome</code> 插件</li></ol><p><img src="Snipaste_2020-04-26_18-18-20.png" alt=""></p><ol start="2"><li><p>编辑配置文件</p><p>​    点击添加配置的时候，有两种选择</p><p><img src="Snipaste_2020-04-26_18-23-11.png" alt=""></p><blockquote><p>attach:</p><p>​    会跟踪你已经运行的程序</p><p>launch:</p><p>​    会创建一个新的程序，并以一个新的用户打开新的窗口</p></blockquote></li></ol><p><img src="Snipaste_2020-04-26_18-35-53.png" alt=""></p><ol start="3"><li><p>进行调试</p><p>我已经在本地启动了项目</p><p><img src="Snipaste_2020-04-26_18-38-21.png" alt=""></p><p>我用<code>launch</code>模式进行调试，<code>F5</code>选择对应配置</p><p><img src="Snipaste_2020-04-26_18-40-30.png" alt=""></p></li></ol><p>可以进行调试：</p><p><img src="Snipaste_2020-04-26_18-41-33.png" alt=""></p><h2 id="留坑待填"><a href="#留坑待填" class="headerlink" title="留坑待填"></a>留坑待填</h2><p>​    我使用<code>attach</code> 模式去调试，但是失败了</p><p><img src="Snipaste_2020-04-26_17-54-07.png" alt=""></p><p>报了一个这个错，试了很多方法还是不行</p><p>更多详细配置可以看官方文档：<a href="https://github.com/Microsoft/vscode-chrome-debug">https://github.com/Microsoft/vscode-chrome-debug</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-怎么跳出Array.forEach()</title>
      <link href="/2020/04/19/javascript-zen-me-tiao-chu-array-foreach/"/>
      <url>/2020/04/19/javascript-zen-me-tiao-chu-array-foreach/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-怎么跳出Array-forEach"><a href="#JavaScript-怎么跳出Array-forEach" class="headerlink" title="JavaScript-怎么跳出Array.forEach()"></a>JavaScript-怎么跳出Array.forEach()</h1><blockquote><p>forEach()会遍历完整个数组，不会中途退出</p></blockquote><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><pre><code>function foreach(a, f, t) {  try {    a.forEach(f, t)  }  catch (e) {    if (e === foreach.break) return;    else throw e;  }}foreach.break = new Error('StopInteration');arr = [1, 2, 3, 4, 5]foreach(arr, x =&gt; { if (x === 3) throw foreach.break; else console.log(x) })//输入 1,2</code></pre><h2 id="使用forEach的第二个参数"><a href="#使用forEach的第二个参数" class="headerlink" title="使用forEach的第二个参数"></a>使用forEach的第二个参数</h2><pre><code>[1, 2, 3, 4].forEach(x =&gt; {  if (this.break == true) {    return;  }  if (x === 2) this.break = true;  console.log(x)}, {})</code></pre><h2 id="改变数组本身"><a href="#改变数组本身" class="headerlink" title="改变数组本身"></a>改变数组本身</h2><pre><code>arr = [1, 2, 3, 4, 5]arr.forEach((v, index) =&gt; {  if (v &gt; 2) {    arr.splice(index, arr.length - index)  }  console.log(v)})//输出 1,2,3</code></pre><h2 id="放大招了"><a href="#放大招了" class="headerlink" title="放大招了"></a>放大招了</h2><p><strong>用some() ,for循环不香吗？？</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码-V8sort</title>
      <link href="/2020/04/19/yuan-ma-v8sort/"/>
      <url>/2020/04/19/yuan-ma-v8sort/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V8排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数组排序</title>
      <link href="/2020/04/19/suan-fa-shu-zu-pai-xu/"/>
      <url>/2020/04/19/suan-fa-shu-zu-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>自己平时的算法练习：<a href="https://github.com/muyeyong/-algorithm-javascript">https://github.com/muyeyong/-algorithm-javascript</a></p><pre><code>let arr = [8, 34, 1, 9, 354, 2, 3, 6]//冒泡排序function bubbleSort(arr) {  for (let i = 0; i &lt; arr.length; i++) {    for (let j = 0; j &lt; arr.length - i - 1; j++) {      if (arr[j] &gt; arr[j + 1]) {        let temp = arr[j];        arr[j] = arr[j + 1];        arr[j + 1] = temp;      }    }  }}// bubbleSort(arr)// console.log(arr)//插入排序let arr1 = [3, 4, 1, 8]function insertSort(arr) {  if (arr.length &lt;= 1) return;  for (let i = 1; i &lt; arr.length; i++) {    let flagIndex = i - 1;    for (let j = 0; j &lt; i; j++) {      if (arr[j] &gt; arr[i]) {        flagIndex = j;        break;      }    }    if (arr[flagIndex] &lt;= arr[i]) continue;    let temp = arr[i];    for (let k = i - 1; k &gt;= flagIndex; k--) {      arr[k + 1] = arr[k];    }    arr[flagIndex] = temp;  }}function insertSort1(arr) {  if (arr.length &lt;= 1) return;  for (let i = 1; i &lt; arr.length; i++) {    let temp = arr[i];    let j = i - 1;    for (; j &gt;= 0; j--) {      if (arr[j] &gt; temp) arr[j + 1] = arr[j];      else break;    }    arr[j + 1] = temp;  }}// insertSort(arr1)// console.log(arr1)// insertSort1(arr1)// console.log(arr1)//选择排序function selectSort(arr) {  if (arr.length &lt;= 0) return;  for (let i = 0; i &lt; arr.length; i++) {    let minIndex = i;    for (let j = i + 1; j &lt; arr.length; j++) {      if (arr[j] &lt; arr[minIndex]) minIndex = j;    }    let temp = arr[i];    arr[i] = arr[minIndex];    arr[minIndex] = temp;  }}// selectSort(arr)// console.log(arr)// 归并排序// 利用哨兵简化merge过程const mergeArr = (left, right) =&gt; {  let temp = []  let leftIndex = 0  let rightIndex = 0  // 判断2个数组中元素大小，依次插入数组  while (left.length &gt; leftIndex &amp;&amp; right.length &gt; rightIndex) {    if (left[leftIndex] &lt;= right[rightIndex]) {      temp.push(left[leftIndex])      leftIndex++    } else {      temp.push(right[rightIndex])      rightIndex++    }  }  // 合并 多余数组  return temp.concat(left.slice(leftIndex)).concat(right.slice(rightIndex))}const mergeSort = (arr) =&gt; {  if (arr.length &lt;= 1) return arr;  let middle = Math.floor(arr.length / 2);  let leftArr = arr.slice(0, middle);  let rightArr = arr.slice(middle);  return mergeArr(mergeSort(leftArr), mergeSort(rightArr))}console.log(mergeSort([1, 4, 6, 2, 89]))//快速排序const swap = (arr, i, j) =&gt; {  let temp = arr[i];  arr[i] = arr[j];  arr[j] = temp;}const partition = (arr, left, right, pivot) =&gt; {  let value = arr[pivot];  let i = left;  for (let j = left; j &lt; right; j++) {    if (arr[j] &lt; value) {      swap(arr, i, j);      i++;    }  }  swap(arr, i, pivot);  return i;}const quickSort = (arr, left, right) =&gt; {  if (left &lt; right) {    let pivot = right    let partitionIndex = partition(arr, left, right, pivot)    quickSort(arr, left, partitionIndex - 1 &lt; left ? left : partitionIndex - 1)    quickSort(arr, partitionIndex + 1 &gt; right ? right : partitionIndex + 1, right)  }}const testArr = []let i = 0while (i &lt; 10) {  testArr.push(Math.floor(Math.random() * 1000));  i++;}console.log('sort before...', testArr)quickSort(testArr, 0, testArr.length - 1);console.log('sort after....', testArr);const partition = (arr) =&gt; {  let value = arr[arr.lenght - 1];  let i = 0;  for (let j = 0; j &lt; arr.lenght - 1; j++) {    if (arr[j] &lt; value) {      swap(arr, i, j);      i++;    }  }  swap(arr, i, arr.lenght - 1);  return i;}const quickSort = (arr) =&gt; {  if (arr.lenght &lt;= 1) return;  let i = partition(arr);  quickSort(arr.slice(0, i - 1 &gt; 0 ? i - 1 : 0));  quickSort(arr.slice(i + 1 &gt; arr.lenght ? arr.lenght : i + 1));}const testArr = []let i = 0while (i &lt; 10) {  testArr.push(Math.floor(Math.random() * 1000))  i++}console.log('sort before...', testArr)quickSort(testArr);console.log('sort after....', testArr);const swap = (arr, i, j) =&gt; {  const temp = arr[i]  arr[i] = arr[j]  arr[j] = temp}// 获取 pivot 交换完后的indexconst partition = (arr, pivot, left, right) =&gt; {  const pivotVal = arr[pivot]  let startIndex = left  for (let i = left; i &lt; right; i++) {    if (arr[i] &lt; pivotVal) {      swap(arr, i, startIndex)      startIndex++    }  }  swap(arr, startIndex, pivot)  return startIndex}const quickSort = (arr, left, right) =&gt; {  if (left &lt; right) {    console.log(arr)    let pivot = right    let partitionIndex = partition(arr, pivot, left, right)    quickSort(arr, left, partitionIndex - 1 &lt; left ? left : partitionIndex - 1)    quickSort(arr, partitionIndex + 1 &gt; right ? right : partitionIndex + 1, right)  }}const testArr = []let i = 0while (i &lt; 10) {  testArr.push(Math.floor(Math.random() * 1000))  i++}console.log('unsort', testArr)quickSort(testArr, 0, testArr.length - 1);console.log('sort', testArr)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-数组</title>
      <link href="/2020/04/18/javascript-shu-zu/"/>
      <url>/2020/04/18/javascript-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><blockquote><p>将数组中的元素转化为字符串连接在一起，可以指定连接符</p></blockquote><p><img src="Snipaste_2020-04-18_18-30-06.png" alt=""></p><p><code>Array.join()</code> 是 <code>String.split()</code>的逆操作</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><blockquote><p>将数组里面的元素逆序，不生成新的数组，只是在原来数组的基础上操作</p></blockquote><p><img src="Snipaste_2020-04-18_18-41-36.png" alt=""></p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><blockquote><p>将数组中的元素排序并返回排序后的数组，可自定义排序方法</p></blockquote><ul><li><p>不自定义排序方法，会按照字母顺序排序</p><p><img src="Snipaste_2020-04-19_16-59-37.png" alt=""></p></li><li><p>自定义排序</p><blockquote><p>传入比较函数，比较函数决定了它的两个参数在排序好的数组中的先后顺序。假设第一个参数在前，返回一个小于0的数，第二个参数在前返回一个大于0的数，两值相等返回0</p></blockquote></li></ul><p>举一个极端的例子： </p><p>​    <img src="Snipaste_2020-04-19_17-07-23.png" alt=""></p><p>相当于给数组逆序了，反之反然。</p><p>*<em>想知道sort的内部实现以及为啥可以通过指定比较函数来排序吗，come with me *</em></p><a href="/2020/04/19/yuan-ma-v8sort/" title="来呀，老弟">来呀，老弟</a><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><blockquote><p>创建并返回一个新的数组</p></blockquote><pre><code> 返回新数组的元素包括调用concat()的原始数组的原始和concat()的每个参数，如果这些元素任何一个自身是数组，则连接的是数组的元素，而不是数组本身。concat()，不会递归扁平化数组的数组。</code></pre><p><img src="Snipaste_2020-04-19_19-01-24.png" alt=""></p><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><blockquote><p>返回指定数组的片段或子数组，不修改原来的数组</p></blockquote><p>​    它的两个参数指定了片段或子数组开始和结束的位置，返回的元素包含第一个参数指定的位置和所有到但不包含第二个参数指定的位置之间的所有元素。如果只指定一个参数，返回的数组包含开始位置到数组结尾的所有元素。如果指定的位置是负数，则表示相对数组中最后一个元素的位（最后一个元素的位置是-1）</p><p><img src="Snipaste_2020-04-19_19-13-29.png" alt=""></p><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><blockquote><p>在数组中插入或删除元素，会修改数组本身</p></blockquote><p>​    第一个参数指定插入/删除位置，第二个参数指定删除元素的个数，如果忽略的话会删除从指定位置到数组结尾的元素，返回一个由删除元素组成的数组，如果没有，返回空数组。</p><p><img src="Snipaste_2020-04-19_20-26-29.png" alt=""></p><p>​    插入元素的话，除了指定前两个参数外，还可以指定若干个其它元素，作为插入元素。</p><p><img src="Snipaste_2020-04-19_20-29-33.png" alt=""></p><h3 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push() 和 pop()"></a>push() 和 pop()</h3><blockquote><p>push() 和 pop()允许将数组当中栈来使用，修改原来的数组</p></blockquote><p>​    push()方法在数组的尾部添加一个或多个元素，返回数组新的长度，pop()删除数组的最后一个元素，返回它删除的值。</p><p><img src="Snipaste_2020-04-19_19-19-42.png" alt=""></p><h3 id="unshift-和-shift"><a href="#unshift-和-shift" class="headerlink" title="unshift() 和 shift()"></a>unshift() 和 shift()</h3><blockquote><p>类似于pop() 和 push()，只不过 unshift() 和 shift()是在数组头部操作的</p></blockquote><p> <img src="Snipaste_2020-04-19_19-37-22.png" alt=""></p><p>​    有木有发现很神奇的一点，unshift 在加入元素的时候不是一个一个加的，是一坨一坨加的</p><p><strong>问题来了，创建数组的时候可以指定数组大小 ,例如<code>new Array(3)</code> ，向数组加入元素超过数组本身大小会怎么办？？</strong></p><p>​    0202年了，<del>肯定会自动扩展嘛</del>。</p><p><img src="Snipaste_2020-04-19_19-35-55.png" alt=""></p><p>​    打扰了，默默的报个错就完了，没那么多花里胡哨的。</p><h3 id="toString-和-toLocaleString"><a href="#toString-和-toLocaleString" class="headerlink" title="toString() 和 toLocaleString()"></a>toString() 和 toLocaleString()</h3><blockquote><p>将数组转换成字符串</p></blockquote><p>​    输出用逗号分隔的字符串列表，不包含方括号和其他形式的包裹数组值得分隔符。</p><p><img src="Snipaste_2020-04-19_19-56-22.png" alt=""></p><p><code>toLocaleString</code>是toString的本地化实现</p><p><img src="Snipaste_2020-04-19_19-58-35.png" alt=""></p><h2 id="ECMAScript5中的数组方法"><a href="#ECMAScript5中的数组方法" class="headerlink" title="ECMAScript5中的数组方法"></a>ECMAScript5中的数组方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><blockquote><p> 从头到尾遍历数组，对每个元素使用指定函数</p></blockquote><p>指定函数<code>function(value,index,array){}</code>可以包含三个参数，后面两个可以省略。</p><p><img src="Snipaste_2020-04-19_20-45-42.png" alt=""></p><p><strong>forEach()无法在所有元素遍历完之前停止遍历，凡事都有个例外，欲知后事如何，且看这篇文章</strong></p>{% post_link JavaScript-怎么跳出Array-forEach %}<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><blockquote><p>调用数组的每一个元素传递给指定函数，并返回一个新数组</p></blockquote><p><img src="Snipaste_2020-04-20_10-32-52.png" alt=""></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><blockquote><p>返回的数组元素是调用的数组的子集，传递的函数是用来逻辑判断的，返回true 或 false，如果返回的是true 或能转换成true的值，那么传递给判定函数的元素就是这个子集的成员，不改变原数组</p></blockquote><p><img src="Snipaste_2020-04-20_10-38-09.png" alt=""></p><h3 id="every-和-some"><a href="#every-和-some" class="headerlink" title="every() 和 some()"></a>every() 和 some()</h3><blockquote><p>对数组元素应用指定的函数进行判定，返回true 或 false</p></blockquote><p><img src="Snipaste_2020-04-20_11-22-17.png" alt=""></p><p>​    一旦<code>every()</code> 和 <code>some()</code>确认返回什么值（true or false），就会停止遍历数组</p><h3 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce() 和 reduceRight()"></a>reduce() 和 reduceRight()</h3><blockquote><p>使用指定函数将数组元素进行组合，生成单个值，称为注入跟折叠</p></blockquote><p>​    <code>reduce()</code>需要两个两个参数。第一个是执行化简的函数，化简函数是运用某种方法将两个值合并或化简为一个值，并返回化简后的值。第二个参数（可选）是传递给函数的初始值。</p><p><img src="Snipaste_2020-04-20_17-19-19.png" alt=""></p><p>​    两者返回值都是一样，但第一个有初始化值，第二个没有初始值，有初始值的时候，第一个参数就是初始值（第一个reduce第一次调用的参数是<code>x=0</code> <code>y=1</code> ），没有初始值的时候会使用数组的第一个元素作为初始值（第二个Reduce第一次调用的参数<code>x=1</code> <code>y=2</code>，就是数组的第一二个元素）。</p><p>​    <code>reduceRight()</code>原理跟<code>reduce</code>一样，只不过它按照数组索引从高到低处理数组元素。</p><h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h3><blockquote><p>搜索整个数组中具有给定值的元素，返回找到第一个元素的索引或没有找到返回-1</p></blockquote><p><code>indecOf()</code>  : 从数组头部开始搜索</p><p><code>lastIndexOf()</code>:从数组尾部进行搜索</p><p>​    可以接收两个参数，第一个是待搜索的元素，第二个是搜索的起始位置（可以为负数）</p><p><img src="Snipaste_2020-04-20_17-49-41.png" alt=""></p><h2 id="ECMAScript6-数组的扩展"><a href="#ECMAScript6-数组的扩展" class="headerlink" title="ECMAScript6-数组的扩展"></a>ECMAScript6-数组的扩展</h2><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符(...)"></a>扩展运算符(<code>...</code>)</h3><blockquote><p>将数组分解为逗号分隔的参数序列</p></blockquote><p><img src="Snipaste_2020-04-21_13-59-35.png" alt=""></p><p><img src="Snipaste_2020-04-21_14-08-02.png" alt=""></p><p><strong>扩展运算符只有在函数调用的时候才能放在圆括号里面</strong></p><p>​    <strong>应用</strong></p><p>复制数组： </p><pre><code>let arr = [1,2,3,4]//写法一let arr2 = [...arr]//写法二let [...arr3] = arr</code></pre><p>合并数组：</p><pre><code>let arr1 = [1,2,3,4]let arr2 = [5,6,7,8]//合并let arr3 = [...arr1,arr2]</code></pre><p>与解构赋值的结合：</p><pre><code>let list = [1,2,3,4,5,6]let [first , ...rest] = list //其实也就相当于复制数组的第二种写法</code></pre><p>可以将字符串变成数组：</p><pre><code>console.log(...'str')// ['s','t','r']</code></pre><h2 id="Array-form"><a href="#Array-form" class="headerlink" title="Array.form()"></a>Array.form()</h2><blockquote><p>将类数组对象和可遍历对象转化成真正的数组</p></blockquote><p>所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性，常见的类数组对象是数组内部的<code>arguments</code> 和 DOM操作返回的NodeList 节点。</p><pre><code>let arrayLike = { '0':'0', '1':'1' '2':'2' lenght: 3}//ES5[].slice.call(arrayLike); //['1','2','3']//ES6Array.form(arrayLike);//['1','2','3']</code></pre><p><code>Array.form()</code>可以接收第二个参数，作用类似于数组的<code>map()</code>，对每个元素进行处理后返回。</p><p><img src="Snipaste_2020-04-21_14-51-18.png" alt=""></p><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><blockquote><p>将一组值转换成数组</p></blockquote><p><code>Array.of()</code>是为了弥补<code>Array()</code>行为不一致的问题</p><p><img src="Snipaste_2020-04-21_14-57-36.png" alt=""></p><p>参数不一样，<code>Array()</code>表现得不一样</p><h2 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h2><blockquote><p>find：找到符合条件的第一个数组成员，没有找到返回undefine</p><p>findexIndex：找到符合条件的数组成员的下表，没有找到返回-1</p></blockquote><p><img src="Snipaste_2020-04-21_15-09-34.png" alt=""></p><p>回调函数可以接收三个值：元素本身、元素下标、数组本身</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><blockquote><p>对数组进行填充</p></blockquote><ul><li><p>待填充的数组没有值</p><p><img src="Snipaste_2020-04-21_15-14-31.png" alt=""></p></li><li><p>待填充的数组有值</p><p><img src="Snipaste_2020-04-21_15-16-20.png" alt=""></p></li></ul><p>会把原有的值进行覆盖</p><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><blockquote><p>判断数组中是否包含某个值，返回true 或 false</p></blockquote><pre><code>[1,2,3,NaN].includes(NaN,1)//第一个参数是待判断的值，第二个参数可选，指定搜索起点。</code></pre><h2 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h2><blockquote><p>拉平数组，一维化</p></blockquote><p>​    在vscode中用，有点问题</p><p><img src="Snipaste_2020-04-21_17-16-57.png" alt=""></p><p>自己试试写，就是一个简单的递归</p><pre><code>function flat(arr) {  let result = [];  if (Object.prototype.toString.call(arr) === '[object Array]') {    arr.forEach(item =&gt; {      if (Object.prototype.toString.call(item) === '[object Array]') {        result = result.concat(flat(item))      } else {        result.push(item);      }    })  }  return result;}</code></pre><p><img src="Snipaste_2020-04-21_17-09-50.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常翻车集锦-数组操作</title>
      <link href="/2020/04/17/ri-chang-fan-che-ji-jin-shu-zu-cao-zuo/"/>
      <url>/2020/04/17/ri-chang-fan-che-ji-jin-shu-zu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="日常翻车集锦-数组篇"><a href="#日常翻车集锦-数组篇" class="headerlink" title="日常翻车集锦-数组篇"></a>日常翻车集锦-数组篇</h1><p>​    今天写代码操作数组时，用了几个关于数组的操作，数据一直不是我想要的，一直很困惑，直到我翻开了</p><p><img src="s9056065.jpg" alt=""></p><p>使用的是 <code>Array.filter()</code>  和<code>Array.push()</code>，是不是觉得很迷，这么简单的方法都能出错，哈哈哈。</p><p>​    使用<code>Array.filter()</code>的时候是为了从一个这样的数据结构中获取里面对象的relys：</p><p><img src="Snipaste_2020-04-17_20-35-08.png" alt=""></p><p>​    我以为返回给我的数据就是单个的relys（本身过滤条件只会返回一条数据），但是返回给我的数据包了一层数组，类似于这样<code>[[]]</code> ，导致我搞了好久。</p><p>​    使用<code>Array.push()</code> ，直接上图</p><p><img src="Snipaste_2020-04-17_20-43-01.png" alt=""></p><p>请求里面的参数，resourceId不是我想要的数据，是因为<code>Array.push()</code>返回值的问题。</p><p><strong>作为奖励，计划把数组的全部操作写一篇文章</strong></p><p><strong>不要问为什么，我就是这么菜</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常翻车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-操作失误案例</title>
      <link href="/2020/04/16/git-cao-zuo-shi-wu-an-li/"/>
      <url>/2020/04/16/git-cao-zuo-shi-wu-an-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Git操作失误案例"><a href="#Git操作失误案例" class="headerlink" title="Git操作失误案例"></a>Git操作失误案例</h1><h2 id="git-init-后找不到本地分支"><a href="#git-init-后找不到本地分支" class="headerlink" title="git init 后找不到本地分支"></a>git init 后找不到本地分支</h2><p><img src="Snipaste_2020-04-16_19-58-54.png" alt=""></p><p>  进行 <code>git init</code> 命令后，出现了master分支，然后我就傻傻的去查看本地分支<code>git branch -a</code>,但是没有任何输出：</p><p><img src="Snipaste_2020-04-16_20-02-17.png" alt=""></p><p>  就觉得很奇怪，后面查资料才知道，<strong>git 分支必须指向一个commit，没有任何commit就没有任何分支</strong> ，提交（git commit过一次，以后新建的分支不管有没有提交数据，都会显示。</p><h2 id="添加远程仓库后，看不到远程分支"><a href="#添加远程仓库后，看不到远程分支" class="headerlink" title="添加远程仓库后，看不到远程分支"></a>添加远程仓库后，看不到远程分支</h2><p>   新建的本地仓库需要关联远程仓库，使用命令<code>git remote add origin git@github.com:muyeyong/React.git</code> 后，使用<code>git branch -a</code>查看所有分支（包括远程），发现只查到本地分支</p><p><img src="Snipaste_2020-04-16_20-17-36.png" alt=""></p><p>  只是建立了连接，并没有获取远程分支的信息，还需要使用<code>git fetch</code>获取远程分支的所有信息。</p><p><img src="Snipaste_2020-04-16_20-33-58.png" alt=""></p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><pre><code> git fetch 和 git pull 的不同：</code></pre><p>​        首先使用一张盗的图</p><p><img src="Snipaste_2020-04-16_20-32-56.png" alt=""></p><p>解释一下远程仓库副本： 本地的远程仓库缓存</p><p>git fetch 获取远程仓库，并没有合并到本地分支，一般情况下<code>git pull = git fetch + git merge</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 失误案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-常用标签</title>
      <link href="/2020/04/15/html-chang-yong-biao-qian/"/>
      <url>/2020/04/15/html-chang-yong-biao-qian/</url>
      
        <content type="html"><![CDATA[<h1 id="Web常用标签"><a href="#Web常用标签" class="headerlink" title="Web常用标签"></a>Web常用标签</h1><table><thead><tr><th align="center">标签名</th><th align="center">用途</th><th align="left">属性</th></tr></thead><tbody><tr><td align="center">&lt;!DOCTYPE&gt;</td><td align="center">表明HTML使用的版本</td><td align="left"></td></tr><tr><td align="center">html lang=xxx</td><td align="center">html网站使用语言说明,对浏览器识别有辅助作用</td><td align="left"></td></tr><tr><td align="center">meta charset=xxx</td><td align="center">编码字符规定, 一般使用UTF-8，万国码</td><td align="left"></td></tr><tr><td align="center">p</td><td align="center">双标签，标明一个段落,p标签之间有明显的间隙</td><td align="left"></td></tr><tr><td align="center">br</td><td align="center">单标签，换行</td><td align="left"></td></tr><tr><td align="center">strong/b</td><td align="center">双标签，字体加粗</td><td align="left"></td></tr><tr><td align="center">em/</td><td align="center">双标签,字体倾斜效果</td><td align="left"></td></tr><tr><td align="center">del</td><td align="center">双标签,删除线效果</td><td align="left"></td></tr><tr><td align="center">ico</td><td align="center">双标签,下划线</td><td align="left"></td></tr><tr><td align="center">div</td><td align="center">双标签,块级域,单独成行</td><td align="left"></td></tr><tr><td align="center">span</td><td align="center">双标签,块级域,可多个span标签在一行</td><td align="left"></td></tr><tr><td align="center">img</td><td align="center">单标签,引入图片</td><td align="left">src:图片路径,alt:图片显示不了的时候的文字说明，title:图片说明,width:图片宽度,height:图片高度</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-Web标准</title>
      <link href="/2020/04/15/html-web-biao-zhun/"/>
      <url>/2020/04/15/html-web-biao-zhun/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要包括结构(Structure)、表现(Presentation)和行为(Behavior)三个方面</p></blockquote><table><thead><tr><th align="center">标准</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">结构</td><td align="left">对网页元素进行整理和分类，HTML</td></tr><tr><td align="center">表现</td><td align="left">设置网页元素的外观样式，css</td></tr><tr><td align="center">行为</td><td align="left">网页模型的定义以及交互的编写，javaScript</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷化-VSCode代码格式化</title>
      <link href="/2020/04/15/kuai-jie-hua-vscode-dai-ma-ge-shi-hua/"/>
      <url>/2020/04/15/kuai-jie-hua-vscode-dai-ma-ge-shi-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode代码格式化快捷键及保存时自动格式化"><a href="#VSCode代码格式化快捷键及保存时自动格式化" class="headerlink" title="VSCode代码格式化快捷键及保存时自动格式化"></a>VSCode代码格式化快捷键及保存时自动格式化</h1><h2 id="VSCode代码格式化"><a href="#VSCode代码格式化" class="headerlink" title="VSCode代码格式化"></a>VSCode代码格式化</h2><blockquote><p>shift + alt + F</p></blockquote><h2 id="保存代码格式化"><a href="#保存代码格式化" class="headerlink" title="保存代码格式化"></a>保存代码格式化</h2><ol><li><p>点击左下角的设置图标，进入设置</p><p><img src="Snipaste_2020-04-09_16-29-38.png" alt=""></p></li></ol><ol start="2"><li><p>搜索emmet，进入settings.json</p><p><img src="Snipaste_2020-04-09_16-33-16.png" alt=""></p></li></ol><ol start="3"><li><p>添加<code>"editor.formatOnType": true,  "editor.formatOnSave": true</code></p><p><img src="Snipaste_2020-04-09_16-34-44.png" alt=""></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 快捷化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode快捷化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-onClick使用箭头函数的问题</title>
      <link href="/2020/04/15/react-onclick-shi-yong-jian-tou-han-shu-de-wen-ti/"/>
      <url>/2020/04/15/react-onclick-shi-yong-jian-tou-han-shu-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Reac中onClick使用箭头函数的疑问"><a href="#Reac中onClick使用箭头函数的疑问" class="headerlink" title="Reac中onClick使用箭头函数的疑问"></a>Reac中onClick使用箭头函数的疑问</h1><p>如果直接写：</p><pre><code>onClock = {this.handleClick(i)}</code></pre><p>这样的话，在render的时候就已经执行了，肯定不行。</p><p>写成这样：</p><pre><code>onClick= {this.handleClick}</code></pre><p>需要携带参数过去的话就不好解决。</p><p>就需要匿名函数将参数带过去：</p><pre><code>onClick = {()=&gt; handleClick(i)}</code></pre><p>闭包让<code>i</code> 保持对renderSquare的 <code>i</code> 的引用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疑惑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-git常用命令</title>
      <link href="/2020/04/15/git-git-chang-yong-ming-ling/"/>
      <url>/2020/04/15/git-git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><blockquote><p>由于每次使用git命令的时候都要去google，特意写文章记录下，按照一个空白项目的开发流程来记录。</p></blockquote><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><blockquote><p> git clone  远程仓库的地址</p></blockquote><p><img src="1.png" alt=""></p><h2 id="建立本地跟远程仓库的连接"><a href="#建立本地跟远程仓库的连接" class="headerlink" title="建立本地跟远程仓库的连接"></a>建立本地跟远程仓库的连接</h2><blockquote><p>git remote add origin 远程仓库的地址</p><blockquote><p>其中remote 是指远程仓库，origin是给远程仓库添加别名</p></blockquote></blockquote><h2 id="建立本地分支跟远程分支的关联"><a href="#建立本地分支跟远程分支的关联" class="headerlink" title="建立本地分支跟远程分支的关联"></a>建立本地分支跟远程分支的关联</h2><blockquote><p>git branch –set-upstream-to 远程分支名 本地分支名</p></blockquote><h2 id="将工作区的更改移到暂存区"><a href="#将工作区的更改移到暂存区" class="headerlink" title="将工作区的更改移到暂存区"></a>将工作区的更改移到暂存区</h2><blockquote><p>git add  [ 需要移动的范围]</p></blockquote><ul><li><code>git add .</code> 将所有文件移到暂存区</li><li><code>git add &lt;filename1&gt; &lt;filename2&gt; ...</code> 将指定文件移到暂存区</li><li><code>git add [dir1] [dit2] ..</code> 将指定文件夹移到暂存区</li></ul><h2 id="将暂存区的更改提交到本地仓库"><a href="#将暂存区的更改提交到本地仓库" class="headerlink" title="将暂存区的更改提交到本地仓库"></a>将暂存区的更改提交到本地仓库</h2><blockquote><p>git commit -m ‘对于本次提交的留言’</p></blockquote><h2 id="撤销上次提交"><a href="#撤销上次提交" class="headerlink" title="撤销上次提交"></a>撤销上次提交</h2><blockquote><p>git commit –amend</p></blockquote><h2 id="将本地仓库分支推送到对应的远程仓库的分支"><a href="#将本地仓库分支推送到对应的远程仓库的分支" class="headerlink" title="将本地仓库分支推送到对应的远程仓库的分支"></a>将本地仓库分支推送到对应的远程仓库的分支</h2><blockquote><p>git push 远程仓库的名字 远程仓库分支名</p></blockquote><h2 id="将本地仓库分支推送到远程仓库的某分支"><a href="#将本地仓库分支推送到远程仓库的某分支" class="headerlink" title="将本地仓库分支推送到远程仓库的某分支"></a>将本地仓库分支推送到远程仓库的某分支</h2><blockquote><p>git push 远程仓库名 本地分支名：远程分支名</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-export 和 export default的区别</title>
      <link href="/2020/04/15/react-export-he-export-default-de-qu-bie/"/>
      <url>/2020/04/15/react-export-he-export-default-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="export-default-和-export-的区别"><a href="#export-default-和-export-的区别" class="headerlink" title="export default 和 export 的区别"></a>export default 和 export 的区别</h1><blockquote><p>export 用于导出常量、函数、文件、模块等。</p></blockquote><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>通过export导出，导入时需要加{}，export defalut 导出的则不需要</li><li>export default为模块指定默认输出，不需要知道加载模块的变量名</li><li>一个文件或模块里面，只能存在一个export default，import 和 export可以存在任意个。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疑惑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emmet语法</title>
      <link href="/2020/04/15/emmet-yu-fa/"/>
      <url>/2020/04/15/emmet-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h1><h2 id="快速生成HTML结构"><a href="#快速生成HTML结构" class="headerlink" title="快速生成HTML结构"></a>快速生成HTML结构</h2><blockquote><p><code>!</code>，然后按下Table生成</p></blockquote><h2 id="id-和class"><a href="#id-和class" class="headerlink" title="id 和class"></a>id 和class</h2><blockquote><p><code>#</code> : 设置id</p><p><code>.</code>: 设置class</p></blockquote><p><img src="Snipaste_2020-04-09_15-58-54.png" alt=""></p><h2 id="子节点和兄弟节点"><a href="#子节点和兄弟节点" class="headerlink" title="子节点和兄弟节点"></a>子节点和兄弟节点</h2><blockquote><p><code>&gt;</code>:设置子节点</p><p><code>+</code>:设置兄弟节点</p></blockquote><p><img src="Snipaste_2020-04-09_16-01-35.png" alt=""></p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><blockquote><p><code>*</code> : 重复生成某个结构</p></blockquote><p><img src="Snipaste_2020-04-09_16-05-40.png" alt=""></p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><blockquote><p><code>()</code>: 将多个标签分为一组，表示括号内的结构与括号外的结构同层</p></blockquote><p><img src="Snipaste_2020-04-09_16-09-05.png" alt=""></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote><p><code>[]</code>: 括号里面添加标签属性</p></blockquote><p><img src="Snipaste_2020-04-09_16-11-05.png" alt=""></p><h2 id="编号-自增符"><a href="#编号-自增符" class="headerlink" title="编号 自增符"></a>编号 自增符</h2><blockquote><p><code>$</code> : 一个$代表一位数字，两个$代表两位数字，以此类推生成$(1) $(01)</p><p>如果想自定义从几开始递增就用: $@+数字</p></blockquote><p><img src="Snipaste_2020-04-09_16-19-37.png" alt=""></p><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><blockquote><p><code>{}</code>:里面添加描述文字</p></blockquote><p><img src="Snipaste_2020-04-09_16-20-39.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-字体属性</title>
      <link href="/2020/04/15/css-zi-ti-shu-xing/"/>
      <url>/2020/04/15/css-zi-ti-shu-xing/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>font-family</td><td>‘Microsoft YaHei’</td><td>设置字体，通常设置在body标签内。可以使用多个字体，会遍历字体，找到了就是要，没有找到使用浏览器默认字体。</td></tr><tr><td>font-size</td><td>20px</td><td>设置字体大小，通常在body中使用，标题标签需要单独指定文字大小</td></tr><tr><td>font-weight</td><td>bold,bolder,lighter,number:[100|200|….|900]</td><td>设置字体粗细</td></tr><tr><td>font-style</td><td>字体样式</td><td>设置文本样式,斜体…</td></tr><tr><td>font</td><td>复合属性</td><td>遵循顺序：font-style font-weight font-size/line-weight  font-family</td></tr></tbody></table><p><img src="image-20200331113710518.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-语法规范</title>
      <link href="/2020/04/15/css-yu-fa-gui-fan/"/>
      <url>/2020/04/15/css-yu-fa-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="css语法规范"><a href="#css语法规范" class="headerlink" title="css语法规范"></a>css语法规范</h1><h2 id="样式格式书写"><a href="#样式格式书写" class="headerlink" title="样式格式书写"></a>样式格式书写</h2><blockquote><p>用宽松式风格</p></blockquote><pre class=" language-css"><code class="language-css"><span class="token selector">error: p </span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token property">fond-size</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">right: p </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>t  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="样式大小写书写风格"><a href="#样式大小写书写风格" class="headerlink" title="样式大小写书写风格"></a>样式大小写书写风格</h2><blockquote><p>使用小写</p></blockquote><pre class=" language-css"><code class="language-css"><span class="token selector">error: p </span><span class="token punctuation">{</span>    <span class="token property">COLOR</span><span class="token punctuation">:</span> RED<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">right: p </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="样式空格风格"><a href="#样式空格风格" class="headerlink" title="样式空格风格"></a>样式空格风格</h2><blockquote><p>选择器和大括号中间保留空格</p><p>属性值前面，冒号后面保留空格</p></blockquote><pre><code>p {    color: red;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-引入方式</title>
      <link href="/2020/04/15/css-yin-ru-fang-shi/"/>
      <url>/2020/04/15/css-yin-ru-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="css引入方式"><a href="#css引入方式" class="headerlink" title="css引入方式"></a>css引入方式</h1><ul><li>行内样式表</li><li>内部样式表</li><li>外部样式表</li></ul><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><blockquote><p>将css抽取出来，使用sytle标签包围</p></blockquote><p><img src="Snipaste_2020-04-09_08-49-51.png" alt=""></p><h2 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h2><blockquote><p>在标签内部使用style属性</p></blockquote><p><img src="Snipaste_2020-04-09_09-02-17.png" alt=""></p><h2 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h2><blockquote><p>通过link 标签引入外部样式，href表示引入的路径</p></blockquote><p><img src="Snipaste_2020-04-09_09-04-34.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-文本属性</title>
      <link href="/2020/04/15/css-wen-ben-shu-xing/"/>
      <url>/2020/04/15/css-wen-ben-shu-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS文本属性"><a href="#CSS文本属性" class="headerlink" title="CSS文本属性"></a>CSS文本属性</h1><blockquote><p>可定义文本的外观，文本颜色、对齐文本、装饰文本、文本缩进、行间距等</p></blockquote><h2 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h2><blockquote><p>可以通过color属性定义文本颜色</p></blockquote><pre class=" language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th>表示</th><th>属性值</th></tr></thead><tbody><tr><td>预定义颜色</td><td>red green blue</td></tr><tr><td>十六进制</td><td>#fff000 （开发用的最多）</td></tr><tr><td>RGB</td><td>reg(255,255,255)</td></tr></tbody></table><h2 id="对齐文本"><a href="#对齐文本" class="headerlink" title="对齐文本"></a>对齐文本</h2><blockquote><p>text-align属性设置文本的水平对齐方式</p></blockquote><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>left</td><td>左对齐,默认对齐方式</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>right</td><td>右对齐</td></tr></tbody></table><h2 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h2><blockquote><p>text-decoration属性设置文本装饰</p></blockquote><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>默认值，没有装饰</td></tr><tr><td>underline</td><td>下划线</td></tr><tr><td>overline</td><td>上划线</td></tr><tr><td>line-through</td><td>删除线</td></tr></tbody></table><h2 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h2><blockquote><p>text-indent设置首行缩进</p></blockquote><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>像素点 20px</td><td>缩进值</td></tr><tr><td>em ： 2em</td><td>相对当前文字大小距离，相对单位</td></tr></tbody></table><h2 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h2><blockquote><p>line-height 设置行间距离，设置行间距改变的是上下间距</p></blockquote><p><img src="image-20200331150959563.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-三大特性</title>
      <link href="/2020/04/15/css-san-da-te-xing/"/>
      <url>/2020/04/15/css-san-da-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="css三大特性"><a href="#css三大特性" class="headerlink" title="css三大特性"></a>css三大特性</h1><blockquote><p>重叠性、继承性和权重选择</p></blockquote><h2 id="重叠性"><a href="#重叠性" class="headerlink" title="重叠性"></a>重叠性</h2><blockquote><p>对于同一个标签使用的样式，后面的样式会覆盖前面的样式</p></blockquote><p><img src="Snipaste_2020-04-13_10-13-24.png" alt=""></p><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><blockquote><p>子标签会继承父标签的样式，主要是文字样式</p></blockquote><p><img src="Snipaste_2020-04-13_10-15-19.png" alt=""></p><p><img src="Snipaste_2020-04-13_10-18-06.png" alt="Snipaste_2020-04-13_10-18-06"></p><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><blockquote><p>不同类型的选择器选择了相同的标签，会根据权重进行选择使用</p></blockquote><table><thead><tr><th>选择器类型</th><th>权重</th></tr></thead><tbody><tr><td>继承 或 通配符选择器</td><td>0,0,0,0</td></tr><tr><td>标签选择器</td><td>0,0,0,1</td></tr><tr><td>类选择器</td><td>0,0,1,0</td></tr><tr><td>ID选择器</td><td>0,1,0,0</td></tr><tr><td>行内样式</td><td>1,0,0,0</td></tr><tr><td>import</td><td>无穷大</td></tr></tbody></table><p><img src="Snipaste_2020-04-13_10-32-15.png" alt=""></p><p><img src="Snipaste_2020-04-13_10-32-34.png" alt="Snipaste_2020-04-13_10-32-34"></p><p><strong>范围越小，权重越大</strong></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>继承的权重为0</li></ul><p><img src="/Snipaste_2020-04-14_09-43-14.png" alt=""></p><p>虽然span的父级的类选择器的权重比span标签选择器的权重高，但是span标签是继承父类选择器的权重为0</p><ul><li>关于a标签的继承</li></ul><p><img src="Snipaste_2020-04-14_09-48-03.png" alt=""></p><p>虽然a标签直接继承父级选折起的样式，但是颜色却没有变红，是应为浏览器默认给a标签加了一个样式(蓝色字体+下划线)</p><ul><li>权重叠加</li></ul><p><img src="Snipaste_2020-04-14_09-55-56.png" alt=""></p><p>虽然都选择了a标签，一个是<code>类选择器+标签选择器</code> ，另一个是<code>标签选择器</code> ,但是呈现的效果第一个选择器，是因为选择器权重的叠加(0,0,1,0) + (0,0,01) &gt; (0,0,0,1), <strong>请注意权重叠加不会产生进位，也就是六个标签选择器叠加也没有一个类选择器权重大，量变无法引起质变</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-简介</title>
      <link href="/2020/04/15/css-jian-jie/"/>
      <url>/2020/04/15/css-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="css简介"><a href="#css简介" class="headerlink" title="css简介"></a>css简介</h1><blockquote><p>层叠样式表</p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>选择器{样式}</p><ul><li>选择器：给谁改样式</li><li>样式： 改什么样的样式</li><li>选择器：HTML的标签</li><li>样式是键值对 key:value</li><li>不同样式用;分隔</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-盒子模型</title>
      <link href="/2020/04/15/css-he-zi-mo-xing/"/>
      <url>/2020/04/15/css-he-zi-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="css盒子模型"><a href="#css盒子模型" class="headerlink" title="css盒子模型"></a>css盒子模型</h1><blockquote><p>盒子模型包含四个部分：内容(centent)、内边距(padding)、边框(border)和外边距(margin)</p></blockquote><p><img src="Snipaste_2020-04-15_08-44-07.png" alt=""></p><h2 id="边框-border"><a href="#边框-border" class="headerlink" title="边框(border)"></a>边框(border)</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>border-style</td><td>设置边框的样式，常用 dotted:点线 dashed：虚线 solid：实线</td></tr><tr><td>border-width</td><td>设置边框的宽度，一般用像素点设置</td></tr><tr><td>border-color</td><td>设置边框的颜色</td></tr></tbody></table><p><img src="Snipaste_2020-04-15_10-16-34.png" alt=""></p><p>表格有自己的边框，单元格也有自己的边框，如果两个叠加在一起会造成边框比较宽，可以使用<code>border-collapse</code>设置表格行和单元格的行是否合并。</p><table><thead><tr><th>属性</th><th>属性值</th></tr></thead><tbody><tr><td>border-collapse</td><td><strong>separate</strong>：边框独立(标准html)  <strong>collapse</strong>：相邻边框被合并</td></tr></tbody></table><ul><li><p>每条边框可以分别设置</p><blockquote><p>通过指定top left buttom right 设置单个边框的样式</p></blockquote><p><img src="Snipaste_2020-04-15_10-29-20.png" alt=""></p></li><li><p>border的复合写法</p><blockquote><p>border: color style size,顺序没有严格要求</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>border会影响盒子实际大小</strong></p></li></ul><p><img src="Snipaste_2020-04-15_10-31-47.png" alt=""></p><p>像这种带边框的盒子，边框大小会影响盒子实际大小</p><p>解决方案：</p><pre><code>   1. 量盒子宽度的时候不要把边框算进去            2. 对盒子大小进行调整，减去边框的宽度</code></pre><h2 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h2><blockquote><p>内边距设置的是内容与边框之间的距离</p></blockquote><p>padding同border一样，可以设置上下左右内边距，padding的不同写法。</p><table><thead><tr><th>写法</th><th>说明</th></tr></thead><tbody><tr><td>padding: 15px</td><td>一个数值，设定了<code>上下左右</code>的内边距</td></tr><tr><td>padding: 15px 15px</td><td>两个数值，设定的是<code>上下</code> 和 <code>左右</code> 的内边距</td></tr><tr><td>padding: 15px 20px 34px</td><td>三个数值，设定的是<code>上</code> <code>左右</code> <code>下</code>的内边距</td></tr><tr><td>padding: 15px 23px 12px 23px</td><td>四个数值，设定的是<code>上</code>  <code>右</code>  <code>下</code>  <code>左</code>，顺时针方向设定内边距</td></tr></tbody></table><p>可能的值：</p><p><img src="Snipaste_2020-04-16_19-38-22.png" alt=""></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>​    <strong>内边距也会影响盒子的实际大小，会把盒子撑大</strong></p><p>​    <strong>解决办法</strong>： 设置盒子大小的时候减去内边距</p><p>​    <strong>应用</strong>： 解决盒子之间的距离问题</p><p>​    <img src="Snipaste_2020-04-16_19-20-55.png" alt=""></p><p>没有使用内边距，由于文字长度的原因，文字之间的距离不相等。</p><p><img src="Snipaste_2020-04-16_19-53-35.png" alt=""></p><p>使用了内边距就可以解决这样的问题。</p><h2 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h2><blockquote><p>控制盒子与盒子之间的距离</p></blockquote><p>没有使用margin</p><p><img src="Snipaste_2020-04-18_11-00-52.png" alt=""></p><p>使用了margin</p><p>![]Snipaste_2020-04-18_11-01-59.png)</p><h3 id="margin的写法"><a href="#margin的写法" class="headerlink" title="margin的写法"></a>margin的写法</h3><blockquote><p>margin跟padding一样有种写法，遵循的规则也一样</p></blockquote><h2 id="margin的典型应用-块级元素水平居中"><a href="#margin的典型应用-块级元素水平居中" class="headerlink" title="margin的典型应用-块级元素水平居中"></a>margin的典型应用-块级元素水平居中</h2><blockquote><p>盒子默认位置是靠左显示，设置水平居中需要满足两个条件</p><blockquote><p>1: 必须指定盒子的宽度</p><p>2：左右外边距需要指定为auto</p></blockquote></blockquote><p><img src="Snipaste_2020-04-18_11-27-20.png" alt=""></p><p>设置水平居中的写法有三种：</p><ul><li>margin-left : auto, margin-right : auto</li><li>margin : auto</li><li><strong>margin : 0 auto</strong></li></ul><p>最后一种最常用</p><p><img src="Snipaste_2020-04-18_11-15-37.png" alt=""></p><h2 id="行内元素跟行内块元素的水平居中"><a href="#行内元素跟行内块元素的水平居中" class="headerlink" title="行内元素跟行内块元素的水平居中"></a>行内元素跟行内块元素的水平居中</h2><blockquote><p>把他们看为文字类型一样，使用<code>text-align = ecnter</code></p></blockquote><p><img src="Snipaste_2020-04-18_11-20-33.png" alt=""></p><h2 id="外边距的合并"><a href="#外边距的合并" class="headerlink" title="外边距的合并"></a>外边距的合并</h2><blockquote><p>当两个垂直外边距相遇时，它们将形成一个外边距，合并后的外边距等于发生合并外边距的高度的较大者</p></blockquote><h3 id="元素相互独立时的合并"><a href="#元素相互独立时的合并" class="headerlink" title="元素相互独立时的合并"></a>元素相互独立时的合并</h3><p><img src="Snipaste_2020-04-18_14-31-15.png" alt=""></p><h3 id="元素包含时的合并"><a href="#元素包含时的合并" class="headerlink" title="元素包含时的合并"></a>元素包含时的合并</h3><p><img src="Snipaste_2020-04-18_14-31-50.png" alt=""></p><h3 id="外边距的自身合并"><a href="#外边距的自身合并" class="headerlink" title="外边距的自身合并"></a>外边距的自身合并</h3><p>​    假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并</p><p><img src="Snipaste_2020-04-18_14-33-08.png" alt=""></p><p>​    如果这个外边距遇到另一个元素的外边距，它还会发生合并：</p><p><img src="Snipaste_2020-04-18_14-33-36.png" alt=""></p><h2 id="清除元素的内外边距"><a href="#清除元素的内外边距" class="headerlink" title="清除元素的内外边距"></a>清除元素的内外边距</h2><p><img src="Snipaste_2020-04-18_11-21-50.png" alt=""></p><p> 元素会默认带上内外边距，使用通配符选择器去清除</p><pre><code>* {    padding : 0;    margin : 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-基础选择器</title>
      <link href="/2020/04/15/css-ji-chu-xuan-ze-qi/"/>
      <url>/2020/04/15/css-ji-chu-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h1><blockquote><p>分为标签选择器、id选择器、类选择器和通用符选择器</p></blockquote><h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>以html的标签名作为选择器，进行选择</p><pre class=" language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>样式点定义 结构类调用 一个或多个  开发最常用</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.red</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>不能使用纯数字或中文作为类名</li><li>类名名字过长用-分隔</li></ul><p>可以给clas属性使用多个类名，只需使用空格分开。</p><ul><li>对于多个类，属性值重复的时候怎么解决？</li></ul><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>样式#定义 结构id调用 只能调用一次  别人切勿使用</p><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;style>    <span class="token id">#pink</span> </span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>&lt;/style>&lt;div id=<span class="token string">"pink"</span>>&lt;/div></code></pre><h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><blockquote><p>* 通配符，会修改所用标签的样式，不需要调用</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-复合选择器</title>
      <link href="/2020/04/15/css-fu-he-xuan-ze-qi/"/>
      <url>/2020/04/15/css-fu-he-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="css复合选择器"><a href="#css复合选择器" class="headerlink" title="css复合选择器"></a>css复合选择器</h1><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><blockquote><p>选择父选择器的的所有符合条件的子选择器，父选择器和子选择器可以是任意的基础选着器</p></blockquote><pre class=" language-javascript"><code class="language-javascript">父选择器 子选择器 <span class="token punctuation">{</span>    设置属性<span class="token punctuation">}</span></code></pre><p><img src="Snipaste_2020-04-09_17-15-05.png" alt=""></p><h2 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h2><blockquote><p>选择直接关联的子选择器</p></blockquote><pre class=" language-javascript"><code class="language-javascript">父选择器 子选择器<span class="token punctuation">{</span>    设置属性<span class="token punctuation">}</span></code></pre><p><img src="Snipaste_2020-04-09_18-01-39.png" alt=""></p><h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><blockquote><p>实现多个选择起的集体声明</p></blockquote><p><img src="Snipaste_2020-04-09_18-11-37.png" alt=""></p><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><blockquote><p>伪类选择器通过<code>:</code>声明</p></blockquote><h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><table><thead><tr><th>名称</th><th>效果</th></tr></thead><tbody><tr><td>a:hove</td><td>鼠标放上去触发</td></tr><tr><td>a:active</td><td>点击链接时触发</td></tr><tr><td>a:link</td><td>未访问链接</td></tr><tr><td>a:visited</td><td>链接被点击时触发</td></tr></tbody></table><p><img src="Snipaste_2020-04-12_10-36-44.png" alt=""></p><p>注意使用链接伪类的顺序： link =&gt; visited =&gt; hover =&gt; active</p><p>使用这种顺序的原因是为了防止前面触发的效果被后面出发的效果覆盖。</p><p>未点击链接前，link伪类长期处于激活状态，鼠标悬停（或点击）时，<a>链接同时处于link和hover(或active)状态，由于它们特指度相同，在同时激活的情况下，后出现的伪类样式会覆盖前面的伪类样式，故link状态必须写在hover(或active)之前。</a></p><a><p>再讨论hover和active的顺序，若把hover放在active后面，当点击链接一瞬，实际你在激活active状态的同时触发了hover伪类,hover在后面覆盖了active的颜色，所以无法看到active的颜色。故hover在active之前</p><p>其次，若把visited放在hover后面，那已访问过的链接一直触发着visited伪类，会覆盖hover样式。</p><p>最后，其实link、visited两个伪类之间顺序无所谓。（因为它俩不可能同时触发，即又未访问同时又已访问。）</p></a><h2 id="focus伪类"><a></a><a href="#focus伪类" class="headerlink" title="focus伪类"></a>focus伪类</h2><blockquote><p>元素获取焦点时，添加样式，一般用于input表单</p></blockquote><p><img src="Snipaste_2020-04-12_10-44-19.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-背景</title>
      <link href="/2020/04/15/css-bei-jing/"/>
      <url>/2020/04/15/css-bei-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="css背景"><a href="#css背景" class="headerlink" title="css背景"></a>css背景</h1><blockquote><p>主要分为背景颜色、背景图片、背景颜色的重复以及背景颜色的定位</p></blockquote><h2 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h2><blockquote><p>默认是transparent（透明），可以用16进制、RGB以及直接设置颜色来设置</p></blockquote><pre><code>p { background-color: silver }div { background-color: rgb(223,71,177) } body { background-color: #98AB6F }pre { background-color: transparent; } </code></pre><h2 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h2><blockquote><p>设置背景图片，使用背景图片是为了更好的控制图片的位置（相对于imag标签），使用url导入</p></blockquote><pre><code>code { background-image: url("comet.jpg"); }blockquote { background-image: url("c:\InetPub\MyPixs\comet.jpg"); } br { background-image: url(http://Fred.com/ImageFile/Q.gif); } body { background-image: none; </code></pre><h3 id="设置背景颜色透明度"><a href="#设置背景颜色透明度" class="headerlink" title="设置背景颜色透明度"></a>设置背景颜色透明度</h3><pre><code>background-color: rgba(255, 0, 0,0.3)// a 指的是alpha（透明度），取值在0~1之间</code></pre><h2 id="backgroung-repeat"><a href="#backgroung-repeat" class="headerlink" title="backgroung-repeat"></a>backgroung-repeat</h2><blockquote><p>设置背景图片的平铺方法，默认为repeat</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>repeat</td><td>图像在x、y轴平铺</td></tr><tr><td>no-repeat</td><td>图像不平铺</td></tr><tr><td>repeat-x</td><td>图像延x轴平铺</td></tr><tr><td>repeat-y</td><td>图像延y轴平铺</td></tr></tbody></table><pre><code>menu { background: url("images/aardvark.gif"); background-repeat: repeat-y; } p { background: url("images/aardvark.gif"); background-repeat: no-repeat; } </code></pre><h2 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h2><blockquote><p>设置背景图片的位置，可以使用具体数值排列、方位排列和混合排列</p></blockquote><h3 id="具体数字排列"><a href="#具体数字排列" class="headerlink" title="具体数字排列"></a>具体数字排列</h3><blockquote><p>具体数值：百分数 | 由浮点数字和单位标识符组成的长度值</p></blockquote><pre class=" language-background-position:20px"><code class="language-background-position:20px">background-position:20px 40px;background-position:20px;</code></pre><p>如果指定两个数值，第一个是x轴，第二个是y轴</p><p>如果只指定一个数值，默认指定为x轴，y轴默认居中</p><p><img src="Snipaste_2020-04-13_09-41-27.png" alt=""></p><h2 id="方位排列"><a href="#方位排列" class="headerlink" title="方位排列"></a>方位排列</h2><blockquote><p>使用top,buttom,left,right,center来设置</p></blockquote><pre><code>background-position: top right;background-position: top;</code></pre><p>如果只指定一个，默认指定为x轴，y轴默认为center</p><h2 id="混合排列"><a href="#混合排列" class="headerlink" title="混合排列"></a>混合排列</h2><blockquote><p>结合数值排列和方位排列</p></blockquote><pre><code>background-position:20px top;</code></pre><p>第一个是x轴数值，第二个是y轴数值，如果指定的是不合法的定位，图片会定位为默认状态（x:0px , y:0px）</p><h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><blockquote><p>设置背景图片的滚动和固定</p></blockquote><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>scroll</td><td>背景图片可滚动</td></tr><tr><td>fixed</td><td>背景图片固定</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-元素显示模式及转换</title>
      <link href="/2020/04/15/css-yuan-su-xian-shi-mo-shi-ji-zhuan-huan/"/>
      <url>/2020/04/15/css-yuan-su-xian-shi-mo-shi-ji-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="css元素显示模式"><a href="#css元素显示模式" class="headerlink" title="css元素显示模式"></a>css元素显示模式</h1><blockquote><p>元素显示模式分为：块级元素、行内元素以及块级行内元素</p></blockquote><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><blockquote><p>代表元素： div、h1-h6、 p…..</p></blockquote><ul><li>块级元素独占一行</li><li>块级元素可以设置元素的宽高，如果没有设置，默认为父级元素的宽高</li><li>块级元素内可以插入其它块级元素以及行内元素</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>  p标签内不能插入div标签</p><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><blockquote><p>代表元素：span、a…..</p></blockquote><ul><li>行内元素可以并列在一行</li><li>行内元素不能直接设置宽高，默认的宽是里面包含内容的长度</li><li>行内元素里面只能插入行内元素</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>a标签内可以插入块级元素</p><h2 id="块级行内元素"><a href="#块级行内元素" class="headerlink" title="块级行内元素"></a>块级行内元素</h2><blockquote><p>既具有块级元素的特点也具有行内元素的特点，代表元素：img、input、td…</p></blockquote><ul><li>一行可以排列多个，但之间会留有缝隙</li><li>默认宽度是里面包含类容的长度</li><li>可以设置宽高、内外边距</li></ul><h1 id="元素显示模式的转换"><a href="#元素显示模式的转换" class="headerlink" title="元素显示模式的转换"></a>元素显示模式的转换</h1><blockquote><p>行内元素 、 块级元素、行内块元素的相互转换，使其拥有其它显示模式的特性</p></blockquote><pre><code>display:block; //可以将元素转换成块级元素dispaly:inline;//将元素转换成行内元素dispaly:inline-block;//将元素转换成行内块元素</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-文本格式化标签</title>
      <link href="/2020/04/15/html-wen-ben-ge-shi-hua-biao-qian/"/>
      <url>/2020/04/15/html-wen-ben-ge-shi-hua-biao-qian/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt; &lt;/strong&gt;</code>  or  <code>&lt;b&gt;&lt;/b&gt;</code></td><td>推荐使用strong</td></tr><tr><td>倾斜</td><td><em></em>  or <i></i></td><td>推荐使用em</td></tr><tr><td>删除线</td><td><del></del> or <s></s></td><td>推荐使用del</td></tr><tr><td>下划线</td><td><ins></ins> or <u></u></td><td>推荐使用ins</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-列表</title>
      <link href="/2020/04/15/html-lie-biao/"/>
      <url>/2020/04/15/html-lie-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><blockquote><p>ul里面只能加li</p></blockquote><p>&lt;ul&gt; <br> &lt;li&gt;任意元素 &lt;/li&gt; <br>&lt;/ul&gt;</p><p>喜欢的食物</p><ul><li>榴莲</li><li>鲱鱼罐头</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><blockquote><p>ol进行包含，li描述每一列</p></blockquote><p>&lt;ol&gt; <br> &lt;li&gt;任意元素 &lt;/li&gt; <br>&lt;/ol&gt;</p><p>粉丝排行榜</p><ol><li>徐勇</li><li>徐小贱</li></ol><h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><blockquote><p>dl包含 dt,dd,dd是对dt的解释</p></blockquote><p>&lt;dl&gt; <br> &lt;dt&gt;名词&lt;/dt&gt; <br>&lt;dd&gt;对名词的解释&lt;/dd&gt;<br>&lt;/dl&gt;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-表格</title>
      <link href="/2020/04/15/html-biao-ge/"/>
      <url>/2020/04/15/html-biao-ge/</url>
      
        <content type="html"><![CDATA[<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>&lt;table 属性：&gt; <br><br> &lt;tr&gt;  &lt;th&gt; &nbsp; 表头 &nbsp;&lt;/th&gt; &lt;/tr&gt; <br><br> &lt;tr&gt; &lt;td&gt; &nbsp; 普通单元格 &nbsp;&lt;/td&gt; &lt;/tr&gt; <br><br>&lt;/table&gt;</p><table><thead><tr><th align="center">属性名</th><th align="center">作用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">width</td><td align="center">设置表格的宽</td><td align="center">跟height搭配使用时，只需要设置其中一个属性，另一个自适应</td></tr><tr><td align="center">height</td><td align="center">设置表格的高</td><td align="center">同上</td></tr><tr><td align="center">cellspacing</td><td align="center">设置单元格与单元格之间的间隙</td><td align="center"></td></tr><tr><td align="center">border</td><td align="center">设置表格边界宽度</td><td align="center"></td></tr><tr><td align="center">cellpadding</td><td align="center">设置单元格内容与单元格的间隙</td><td align="center"></td></tr><tr><td align="center">align</td><td align="center">设置表格相对于周围元素的位置</td><td align="center"></td></tr></tbody></table><h2 id="表单区域"><a href="#表单区域" class="headerlink" title="表单区域"></a>表单区域</h2><blockquote><p>thead 和 tbody, thead区别于th标签,thead表示的是表头区域，th表示表头单元格</p></blockquote><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><blockquote><p>跨行合并: rowspan =’合并单元格的的个数’，操作的目标单元格是操作的最上的单元格</p><p>跨列合并：colspan =’合并单元格的个数’，操作的目标单元格是操作的最左的单元格</p></blockquote><h3 id="合并单元格的步骤"><a href="#合并单元格的步骤" class="headerlink" title="合并单元格的步骤"></a>合并单元格的步骤</h3><ol><li>确定跨行还是跨列合并</li><li>操作目标单元格</li><li>删除多余的单元格</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-表单</title>
      <link href="/2020/04/15/html-biao-dan/"/>
      <url>/2020/04/15/html-biao-dan/</url>
      
        <content type="html"><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><blockquote><p>由三部分组成，表单域，表单元素和提示信息</p></blockquote><h2 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h2><blockquote><p> form 设置表单域</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url地址<span class="token punctuation">"</span></span>  <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>提交方式<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>表单域名称<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    表单元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span></code></pre><h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><blockquote><p>允许用户输入或选择的内容控件</p></blockquote><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>属性值<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span></code></pre><ul><li>根据type的不同可以指定不同的控件类型</li></ul><h4 id="其他常用属性"><a href="#其他常用属性" class="headerlink" title="其他常用属性"></a>其他常用属性</h4><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>用户自定义</td><td>定义input元素的名称</td></tr><tr><td>value</td><td>用户自定义</td><td>规定input元素的值</td></tr><tr><td>checked</td><td>checked</td><td>设置是否被选中</td></tr><tr><td>maxlength</td><td>正整数</td><td>input的最大输入长度</td></tr></tbody></table><ul><li>对于单选和复选需要设定相同的name</li><li>checked是对单复选框使用的</li></ul><h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><blockquote><p>绑定表单元素，当点击lable标签包含的文本时，浏览器会自动将焦点转到对应的表单元素上去</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lable</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>sex<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lable</span><span class="token punctuation">></span></span>&lt;input type='radio' name = 'sex'  id = 'sex' /></code></pre><ul><li>lable标签的for属性要与相关标签的id属性相同</li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><pre class=" language-html1"><code class="language-html1"><select>    <option>选项名</option>    ...........</select></code></pre><ul><li>可以设置option的selected属性为’selected’选中</li></ul><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><blockquote><p>定义多行文本控件</p></blockquote><pre><code>&lt;textarea&gt;&lt;/textarea&gt;</code></pre><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>clos</td><td>每行中的字符</td><td>实际开发中不会使用，通过css控制</td></tr><tr><td>rows</td><td>自大输入行数</td><td>实际开发中不会使用，通过css控制</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
